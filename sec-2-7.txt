Disassembly of section 2/7:

0000000000000000 <tail_handle_ipv4>:
; {
       0:	b7 03 00 00 00 00 00 00	r3 = 0
; 	struct ipv4_ct_tuple tuple = {};
       1:	6b 3a 8c ff 00 00 00 00	*(u16 *)(r10 - 116) = r3
       2:	63 3a 88 ff 00 00 00 00	*(u32 *)(r10 - 120) = r3
       3:	7b 3a 80 ff 00 00 00 00	*(u64 *)(r10 - 128) = r3
; 	union macaddr router_mac = NODE_MAC;
       4:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
       6:	6b 2a 7c ff 00 00 00 00	*(u16 *)(r10 - 132) = r2
       7:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
       9:	63 2a 78 ff 00 00 00 00	*(u32 *)(r10 - 136) = r2
; 	struct ct_state ct_state = {};
      10:	63 3a 70 ff 00 00 00 00	*(u32 *)(r10 - 144) = r3
      11:	7b 3a 68 ff 00 00 00 00	*(u64 *)(r10 - 152) = r3
      12:	7b 3a 60 ff 00 00 00 00	*(u64 *)(r10 - 160) = r3
; 	return (void *)(unsigned long)ctx->data_end;
      13:	61 13 50 00 00 00 00 00	r3 = *(u32 *)(r1 + 80)
      14:	7b 1a 40 ff 00 00 00 00	*(u64 *)(r10 - 192) = r1
; 	return (void *)(unsigned long)ctx->data;
      15:	61 16 4c 00 00 00 00 00	r6 = *(u32 *)(r1 + 76)
; 	if (data + tot_len > data_end)
      16:	bf 62 00 00 00 00 00 00	r2 = r6
      17:	07 02 00 00 22 00 00 00	r2 += 34
      18:	b7 05 00 00 00 00 00 00	r5 = 0
      19:	18 08 00 00 7a ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967162 ll
; 	if (data + tot_len > data_end)
      21:	2d 32 ca 01 00 00 00 00	if r2 > r3 goto +458 <LBB13_87>
; 	return ip4->frag_off & bpf_htons(0x1FFF);
      22:	69 64 14 00 00 00 00 00	r4 = *(u16 *)(r6 + 20)
; 	tuple.nexthdr = ip4->protocol;
      23:	71 61 17 00 00 00 00 00	r1 = *(u8 *)(r6 + 23)
      24:	73 1a 8c ff 00 00 00 00	*(u8 *)(r10 - 116) = r1
      25:	18 08 00 00 7c ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967164 ll
; 	return ip4->saddr == LXC_IPV4;
      27:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
      29:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
      31:	67 02 00 00 20 00 00 00	r2 <<= 32
      32:	77 02 00 00 20 00 00 00	r2 >>= 32
      33:	61 63 1a 00 00 00 00 00	r3 = *(u32 *)(r6 + 26)
      34:	b7 05 00 00 00 00 00 00	r5 = 0
; 	if (unlikely(!is_valid_lxc_src_ipv4(ip4)))
      35:	5d 23 bc 01 00 00 00 00	if r3 != r2 goto +444 <LBB13_87>
      36:	57 04 00 00 1f ff ff ff	r4 &= -225
      37:	7b 4a 18 ff 00 00 00 00	*(u64 *)(r10 - 232) = r4
; 	tuple.daddr = ip4->daddr;
      38:	61 62 1e 00 00 00 00 00	r2 = *(u32 *)(r6 + 30)
; 	tuple.saddr = ip4->saddr;
      39:	63 1a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r1
; 	tuple.daddr = ip4->daddr;
      40:	63 2a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r2
; 	return ip4->ihl * 4;
      41:	71 62 0e 00 00 00 00 00	r2 = *(u8 *)(r6 + 14)
      42:	b7 01 00 00 00 00 00 00	r1 = 0
; 	key->proto = 0;
      43:	63 1a 50 ff 00 00 00 00	*(u32 *)(r10 - 176) = r1
      44:	63 1a 4c ff 00 00 00 00	*(u32 *)(r10 - 180) = r1
; 	key->address = (dir == CT_INGRESS) ? ip4->saddr : ip4->daddr;
      45:	61 60 1e 00 00 00 00 00	r0 = *(u32 *)(r6 + 30)
      46:	63 0a 48 ff 00 00 00 00	*(u32 *)(r10 - 184) = r0
; 	return ip4->ihl * 4;
      47:	67 02 00 00 02 00 00 00	r2 <<= 2
      48:	57 02 00 00 3c 00 00 00	r2 &= 60
; 	l4_off = l3_off + ipv4_hdrlen(ip4);
      49:	07 02 00 00 0e 00 00 00	r2 += 14
      50:	7b 2a 38 ff 00 00 00 00	*(u64 *)(r10 - 200) = r2
      51:	71 63 17 00 00 00 00 00	r3 = *(u8 *)(r6 + 23)
; 	return ip4->frag_off & bpf_htons(0x1FFF);
      52:	69 62 14 00 00 00 00 00	r2 = *(u16 *)(r6 + 20)
      53:	bf 24 00 00 00 00 00 00	r4 = r2
      54:	57 04 00 00 1f ff 00 00	r4 &= 65311
      55:	7b 6a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r6
; 	if (ipv4_has_l4_header(ip4))
      56:	55 04 16 00 00 00 00 00	if r4 != 0 goto +22 <LBB13_8>
      57:	b7 05 00 00 10 00 00 00	r5 = 16
      58:	b7 04 00 00 00 00 00 00	r4 = 0
; 	switch (nexthdr) {
      59:	7b 4a 20 ff 00 00 00 00	*(u64 *)(r10 - 224) = r4
      60:	15 03 0e 00 06 00 00 00	if r3 == 6 goto +14 <LBB13_7>
      61:	b7 04 00 00 02 00 00 00	r4 = 2
      62:	7b 4a 28 ff 00 00 00 00	*(u64 *)(r10 - 216) = r4
      63:	b7 09 00 00 00 00 00 00	r9 = 0
      64:	b7 08 00 00 00 00 00 00	r8 = 0
      65:	b7 06 00 00 00 00 00 00	r6 = 0
      66:	b7 07 00 00 00 00 00 00	r7 = 0
      67:	b7 05 00 00 00 00 00 00	r5 = 0
      68:	b7 04 00 00 00 00 00 00	r4 = 0
; 	switch (nexthdr) {
      69:	15 03 8b 00 3a 00 00 00	if r3 == 58 goto +139 <LBB13_26>
      70:	55 03 08 00 11 00 00 00	if r3 != 17 goto +8 <LBB13_8>
      71:	b7 03 00 00 11 00 00 00	r3 = 17
      72:	b7 05 00 00 06 00 00 00	r5 = 6
      73:	b7 04 00 00 20 00 00 00	r4 = 32
      74:	7b 4a 20 ff 00 00 00 00	*(u64 *)(r10 - 224) = r4

0000000000000258 <LBB13_7>:
      75:	7b 5a 28 ff 00 00 00 00	*(u64 *)(r10 - 216) = r5
      76:	bf a1 00 00 00 00 00 00	r1 = r10
      77:	07 01 00 00 98 ff ff ff	r1 += -104
      78:	05 00 12 00 00 00 00 00	goto +18 <LBB13_10>

0000000000000278 <LBB13_8>:
      79:	bf a1 00 00 00 00 00 00	r1 = r10
      80:	07 01 00 00 98 ff ff ff	r1 += -104
      81:	b7 04 00 00 00 00 00 00	r4 = 0
      82:	7b 4a 20 ff 00 00 00 00	*(u64 *)(r10 - 224) = r4
      83:	b7 04 00 00 00 00 00 00	r4 = 0
; 	switch (nexthdr) {
      84:	7b 4a 28 ff 00 00 00 00	*(u64 *)(r10 - 216) = r4
      85:	15 03 0b 00 11 00 00 00	if r3 == 17 goto +11 <LBB13_10>
      86:	b7 04 00 00 00 00 00 00	r4 = 0
      87:	7b 4a 20 ff 00 00 00 00	*(u64 *)(r10 - 224) = r4
      88:	b7 04 00 00 00 00 00 00	r4 = 0
      89:	7b 4a 28 ff 00 00 00 00	*(u64 *)(r10 - 216) = r4
      90:	b7 09 00 00 00 00 00 00	r9 = 0
      91:	b7 08 00 00 00 00 00 00	r8 = 0
      92:	b7 06 00 00 00 00 00 00	r6 = 0
      93:	b7 07 00 00 00 00 00 00	r7 = 0
      94:	b7 05 00 00 00 00 00 00	r5 = 0
      95:	b7 04 00 00 00 00 00 00	r4 = 0
; 	switch (nexthdr) {
      96:	55 03 70 00 06 00 00 00	if r3 != 6 goto +112 <LBB13_26>

0000000000000308 <LBB13_10>:
      97:	bf 17 00 00 00 00 00 00	r7 = r1
      98:	b7 04 00 00 00 00 00 00	r4 = 0
; 			struct ipv4_frag_l4ports ports = { };
      99:	63 4a 98 ff 00 00 00 00	*(u32 *)(r10 - 104) = r4
; 	struct ipv4_frag_id frag_id = {
     100:	63 0a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r0
     101:	79 a6 30 ff 00 00 00 00	r6 = *(u64 *)(r10 - 208)
; 		.saddr = ip4->saddr,
     102:	61 61 1a 00 00 00 00 00	r1 = *(u32 *)(r6 + 26)
; 	struct ipv4_frag_id frag_id = {
     103:	63 1a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r1
; 		.id = ip4->id,
     104:	69 61 12 00 00 00 00 00	r1 = *(u16 *)(r6 + 18)
; 	struct ipv4_frag_id frag_id = {
     105:	73 4a e3 ff 00 00 00 00	*(u8 *)(r10 - 29) = r4
     106:	73 3a e2 ff 00 00 00 00	*(u8 *)(r10 - 30) = r3
     107:	6b 1a e0 ff 00 00 00 00	*(u16 *)(r10 - 32) = r1
; 	return ip4->frag_off & bpf_htons(0x3FFF);
     108:	57 02 00 00 3f ff 00 00	r2 &= 65343
; 	if (unlikely(is_fragment)) {
     109:	55 02 1a 00 00 00 00 00	if r2 != 0 goto +26 <LBB13_16>
     110:	bf a3 00 00 00 00 00 00	r3 = r10
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
     111:	07 03 00 00 98 ff ff ff	r3 += -104
     112:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     113:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
     114:	b7 04 00 00 04 00 00 00	r4 = 4
     115:	85 00 00 00 1a 00 00 00	call 26
     116:	67 00 00 00 20 00 00 00	r0 <<= 32
     117:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     118:	b7 01 00 00 01 00 00 00	r1 = 1
; 	if (ret < 0)
     119:	65 00 01 00 ff ff ff ff	if r0 s> -1 goto +1 <LBB13_13>
     120:	b7 01 00 00 00 00 00 00	r1 = 0

00000000000003c8 <LBB13_13>:
; 			if (IS_ERR(ret))
     121:	57 01 00 00 01 00 00 00	r1 &= 1
     122:	55 01 39 00 00 00 00 00	if r1 != 0 goto +57 <LBB13_23>
     123:	65 00 38 00 ff ff ff ff	if r0 s> -1 goto +56 <LBB13_23>
     124:	b7 09 00 00 00 00 00 00	r9 = 0
     125:	bf 03 00 00 00 00 00 00	r3 = r0
; 			if (ret == DROP_NO_SERVICE || ret == DROP_UNKNOWN_L4)
     126:	bf 01 00 00 00 00 00 00	r1 = r0
     127:	57 01 00 00 ef ff ff ff	r1 &= -17
     128:	b7 08 00 00 00 00 00 00	r8 = 0
     129:	b7 06 00 00 00 00 00 00	r6 = 0
     130:	b7 07 00 00 00 00 00 00	r7 = 0
     131:	b7 05 00 00 00 00 00 00	r5 = 0
     132:	b7 04 00 00 00 00 00 00	r4 = 0
     133:	79 a2 40 ff 00 00 00 00	r2 = *(u64 *)(r10 - 192)
     134:	15 01 4a 00 62 ff ff ff	if r1 == -158 goto +74 <LBB13_26>
     135:	05 00 56 01 00 00 00 00	goto +342 <LBB13_86>

0000000000000440 <LBB13_16>:
     136:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
     137:	61 18 00 00 00 00 00 00	r8 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
     138:	7b 4a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r4
     139:	7b 4a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r4
     140:	b7 01 00 00 09 02 00 00	r1 = 521
; 	struct metrics_key key = {};
     141:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
     142:	bf a2 00 00 00 00 00 00	r2 = r10
     143:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
     144:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     146:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
     147:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_18>
; 		entry->count += 1;
     148:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
     149:	07 01 00 00 01 00 00 00	r1 += 1
     150:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
     151:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
     152:	0f 81 00 00 00 00 00 00	r1 += r8
     153:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
     154:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_19>

00000000000004d8 <LBB13_18>:
; 		newEntry.bytes = bytes;
     155:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
     156:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
     157:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     158:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
     159:	07 02 00 00 f8 ff ff ff	r2 += -8
     160:	bf a3 00 00 00 00 00 00	r3 = r10
     161:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
     162:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     164:	b7 04 00 00 00 00 00 00	r4 = 0
     165:	85 00 00 00 02 00 00 00	call 2

0000000000000530 <LBB13_19>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
     166:	69 61 14 00 00 00 00 00	r1 = *(u16 *)(r6 + 20)
     167:	57 01 00 00 1f ff 00 00	r1 &= 65311
; 		if (likely(not_first_fragment))
     168:	15 01 5a 03 00 00 00 00	if r1 == 0 goto +858 <LBB13_309>
     169:	bf a2 00 00 00 00 00 00	r2 = r10
     170:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	tmp = map_lookup_elem(&IPV4_FRAG_DATAGRAMS_MAP, frag_id);
     171:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     173:	85 00 00 00 01 00 00 00	call 1
; 	if (!tmp)
     174:	55 00 03 00 00 00 00 00	if r0 != 0 goto +3 <LBB13_22>
     175:	18 03 00 00 51 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967121 ll
     177:	05 00 2b 01 00 00 00 00	goto +299 <LBB13_85>

0000000000000590 <LBB13_22>:
; 	case  4: __it_mob(d, s, 32);
     178:	61 01 00 00 00 00 00 00	r1 = *(u32 *)(r0 + 0)
     179:	63 1a 98 ff 00 00 00 00	*(u32 *)(r10 - 104) = r1

00000000000005a0 <LBB13_23>:
; 			*port = ports.dport;
     180:	69 71 02 00 00 00 00 00	r1 = *(u16 *)(r7 + 2)
     181:	6b 1a 4c ff 00 00 00 00	*(u16 *)(r10 - 180) = r1
     182:	b7 09 00 00 00 00 00 00	r9 = 0
; 	key->scope = LB_LOOKUP_SCOPE_EXT;
     183:	73 9a 51 ff 00 00 00 00	*(u8 *)(r10 - 175) = r9
; 	key->backend_slot = 0;
     184:	6b 9a 4e ff 00 00 00 00	*(u16 *)(r10 - 178) = r9
     185:	bf a2 00 00 00 00 00 00	r2 = r10
; 			*port = ports.dport;
     186:	07 02 00 00 48 ff ff ff	r2 += -184
; 	svc = map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
     187:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     189:	85 00 00 00 01 00 00 00	call 1
     190:	b7 08 00 00 00 00 00 00	r8 = 0
     191:	b7 06 00 00 00 00 00 00	r6 = 0
     192:	b7 07 00 00 00 00 00 00	r7 = 0
     193:	b7 05 00 00 00 00 00 00	r5 = 0
     194:	b7 04 00 00 00 00 00 00	r4 = 0
     195:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	if (svc) {
     196:	15 00 0c 00 00 00 00 00	if r0 == 0 goto +12 <LBB13_26>
; 	return svc->flags & SVC_FLAG_LOCAL_SCOPE;
     197:	71 01 08 00 00 00 00 00	r1 = *(u8 *)(r0 + 8)
     198:	57 01 00 00 04 00 00 00	r1 &= 4
; 		if (!scope_switch || !lb4_svc_is_local_scope(svc))
     199:	55 01 4a 00 00 00 00 00	if r1 != 0 goto +74 <LBB13_40>
     200:	b7 09 00 00 00 00 00 00	r9 = 0
; 			return svc->count ? svc : NULL;
     201:	69 01 04 00 00 00 00 00	r1 = *(u16 *)(r0 + 4)
     202:	b7 08 00 00 00 00 00 00	r8 = 0
     203:	b7 06 00 00 00 00 00 00	r6 = 0
     204:	b7 07 00 00 00 00 00 00	r7 = 0
     205:	b7 05 00 00 00 00 00 00	r5 = 0
     206:	b7 04 00 00 00 00 00 00	r4 = 0
     207:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_26>
     208:	05 00 57 00 00 00 00 00	goto +87 <LBB13_42>

0000000000000688 <LBB13_26>:
     209:	7b 4a 10 ff 00 00 00 00	*(u64 *)(r10 - 240) = r4
     210:	7b 9a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r9
     211:	7b 7a e8 fe 00 00 00 00	*(u64 *)(r10 - 280) = r7
     212:	b7 01 00 00 01 00 00 00	r1 = 1
; 		tuple->flags = TUPLE_F_IN;
     213:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
; 	orig_dip = tuple.daddr;
     214:	61 a1 80 ff 00 00 00 00	r1 = *(u32 *)(r10 - 128)
; 	if (tuple->nexthdr == IPPROTO_TCP)
     215:	7b 1a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r1
     216:	71 a2 8c ff 00 00 00 00	r2 = *(u8 *)(r10 - 116)
     217:	b7 01 00 00 00 00 00 00	r1 = 0
; 	union tcp_flags tcp_flags = { .value = 0 };
     218:	63 1a f8 ff 00 00 00 00	*(u32 *)(r10 - 8) = r1
; 	ret = ct_lookup4(get_ct_map4(&tuple), &tuple, ctx, l4_off, CT_EGRESS,
     219:	18 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r9 = 0 ll
     221:	15 02 02 00 06 00 00 00	if r2 == 6 goto +2 <LBB13_28>
     222:	18 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r9 = 0 ll

0000000000000700 <LBB13_28>:
; 	switch (tuple->nexthdr) {
     224:	7b 5a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r5
     225:	7b 6a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r6
     226:	7b 2a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r2
     227:	15 02 82 00 11 00 00 00	if r2 == 17 goto +130 <LBB13_62>
     228:	15 02 b8 03 06 00 00 00	if r2 == 6 goto +952 <LBB13_56>
     229:	18 03 00 00 77 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967159 ll
     231:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
; 	switch (tuple->nexthdr) {
     232:	55 02 f5 00 01 00 00 00	if r2 != 1 goto +245 <LBB13_86>
     233:	b7 01 00 00 00 00 00 00	r1 = 0
; 			__be16 identifier = 0;
     234:	6b 1a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r1
     235:	bf a3 00 00 00 00 00 00	r3 = r10
     236:	07 03 00 00 d8 ff ff ff	r3 += -40
     237:	bf 57 00 00 00 00 00 00	r7 = r5
; 			if (ctx_load_bytes(ctx, off, &type, 1) < 0)
     238:	bf 51 00 00 00 00 00 00	r1 = r5
     239:	79 a6 38 ff 00 00 00 00	r6 = *(u64 *)(r10 - 200)
     240:	bf 62 00 00 00 00 00 00	r2 = r6
     241:	b7 04 00 00 01 00 00 00	r4 = 1
     242:	85 00 00 00 1a 00 00 00	call 26
     243:	67 00 00 00 20 00 00 00	r0 <<= 32
     244:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     245:	c5 00 92 00 00 00 00 00	if r0 s< 0 goto +146 <LBB13_65>
; 			if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) &&
     246:	71 a1 d8 ff 00 00 00 00	r1 = *(u8 *)(r10 - 40)
     247:	bf 12 00 00 00 00 00 00	r2 = r1
     248:	47 02 00 00 08 00 00 00	r2 |= 8
     249:	15 02 01 00 08 00 00 00	if r2 == 8 goto +1 <LBB13_33>
     250:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_35>

00000000000007d8 <LBB13_33>:
; 			     ctx_load_bytes(ctx, off + offsetof(struct icmphdr, un.echo.id),
     251:	07 06 00 00 04 00 00 00	r6 += 4
     252:	bf a3 00 00 00 00 00 00	r3 = r10
     253:	07 03 00 00 a0 ff ff ff	r3 += -96
; 			     ctx_load_bytes(ctx, off + offsetof(struct icmphdr, un.echo.id),
     254:	bf 71 00 00 00 00 00 00	r1 = r7
     255:	bf 62 00 00 00 00 00 00	r2 = r6
     256:	b7 04 00 00 02 00 00 00	r4 = 2
     257:	85 00 00 00 1a 00 00 00	call 26
     258:	67 00 00 00 20 00 00 00	r0 <<= 32
     259:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 			if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) &&
     260:	c5 00 83 00 00 00 00 00	if r0 s< 0 goto +131 <LBB13_65>
; 			switch (type) {
     261:	71 a1 d8 ff 00 00 00 00	r1 = *(u8 *)(r10 - 40)

0000000000000830 <LBB13_35>:
     262:	b7 02 00 00 00 00 00 00	r2 = 0
; 			tuple->dport = 0;
     263:	63 2a 88 ff 00 00 00 00	*(u32 *)(r10 - 120) = r2
     264:	b7 06 00 00 01 00 00 00	r6 = 1
; 			switch (type) {
     265:	65 01 c7 00 0a 00 00 00	if r1 s> 10 goto +199 <LBB13_80>
     266:	bf 87 00 00 00 00 00 00	r7 = r8
; 			switch (type) {
     267:	15 01 fc 00 00 00 00 00	if r1 == 0 goto +252 <LBB13_92>
     268:	15 01 c7 00 03 00 00 00	if r1 == 3 goto +199 <LBB13_81>
     269:	15 01 01 00 08 00 00 00	if r1 == 8 goto +1 <LBB13_39>
     270:	05 00 c1 03 00 00 00 00	goto +961 <LBB13_94>

0000000000000878 <LBB13_39>:
; 				tuple->dport = identifier;
     271:	69 a1 a0 ff 00 00 00 00	r1 = *(u16 *)(r10 - 96)
     272:	6b 1a 88 ff 00 00 00 00	*(u16 *)(r10 - 120) = r1
     273:	05 00 be 03 00 00 00 00	goto +958 <LBB13_94>

0000000000000890 <LBB13_40>:
     274:	b7 01 00 00 01 00 00 00	r1 = 1
; 		key->scope = LB_LOOKUP_SCOPE_INT;
     275:	73 1a 51 ff 00 00 00 00	*(u8 *)(r10 - 175) = r1
     276:	bf a2 00 00 00 00 00 00	r2 = r10
     277:	07 02 00 00 48 ff ff ff	r2 += -184
; 		svc = map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
     278:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     280:	85 00 00 00 01 00 00 00	call 1
     281:	b7 09 00 00 00 00 00 00	r9 = 0
     282:	b7 08 00 00 00 00 00 00	r8 = 0
     283:	b7 06 00 00 00 00 00 00	r6 = 0
     284:	b7 07 00 00 00 00 00 00	r7 = 0
     285:	b7 05 00 00 00 00 00 00	r5 = 0
     286:	b7 04 00 00 00 00 00 00	r4 = 0
; 		if (svc && svc->count)
     287:	15 00 b1 ff 00 00 00 00	if r0 == 0 goto -79 <LBB13_26>
     288:	b7 09 00 00 00 00 00 00	r9 = 0
; 		if (svc && svc->count)
     289:	69 01 04 00 00 00 00 00	r1 = *(u16 *)(r0 + 4)
     290:	b7 08 00 00 00 00 00 00	r8 = 0
     291:	b7 06 00 00 00 00 00 00	r6 = 0
     292:	b7 07 00 00 00 00 00 00	r7 = 0
     293:	b7 05 00 00 00 00 00 00	r5 = 0
     294:	b7 04 00 00 00 00 00 00	r4 = 0
; 		if (svc && svc->count)
     295:	15 01 a9 ff 00 00 00 00	if r1 == 0 goto -87 <LBB13_26>

0000000000000940 <LBB13_42>:
     296:	7b 0a 10 ff 00 00 00 00	*(u64 *)(r10 - 240) = r0
; 					ip4->saddr, has_l4_header, false);
     297:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
     298:	61 17 1a 00 00 00 00 00	r7 = *(u32 *)(r1 + 26)
; 	__u8 flags = tuple->flags;
     299:	71 a9 8d ff 00 00 00 00	r9 = *(u8 *)(r10 - 115)
     300:	b7 01 00 00 04 00 00 00	r1 = 4
; 		tuple->flags = TUPLE_F_SERVICE;
     301:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
; 	if (tuple->nexthdr == IPPROTO_TCP)
     302:	71 a5 8c ff 00 00 00 00	r5 = *(u8 *)(r10 - 116)
     303:	b7 01 00 00 00 00 00 00	r1 = 0
; 	__be32 new_saddr = 0, new_daddr;
     304:	63 1a 94 ff 00 00 00 00	*(u32 *)(r10 - 108) = r1
; 	union tcp_flags tcp_flags = { .value = 0 };
     305:	63 1a 98 ff 00 00 00 00	*(u32 *)(r10 - 104) = r1
; 			ret = lb4_local(get_ct_map4(&tuple), ctx, l3_off, l4_off,
     306:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
     308:	15 05 02 00 06 00 00 00	if r5 == 6 goto +2 <LBB13_44>
     309:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll

00000000000009b8 <LBB13_44>:
     311:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	switch (tuple->nexthdr) {
     312:	15 05 52 00 11 00 00 00	if r5 == 17 goto +82 <LBB13_72>
     313:	15 05 36 06 06 00 00 00	if r5 == 6 goto +1590 <LBB13_66>
     314:	55 05 9e 00 01 00 00 00	if r5 != 1 goto +158 <LBB13_83>
     315:	7b 5a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r5
     316:	7b 3a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r3
     317:	b7 01 00 00 00 00 00 00	r1 = 0
; 			__be16 identifier = 0;
     318:	6b 1a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r1
     319:	bf a3 00 00 00 00 00 00	r3 = r10
     320:	07 03 00 00 d8 ff ff ff	r3 += -40
; 			if (ctx_load_bytes(ctx, off, &type, 1) < 0)
     321:	bf 41 00 00 00 00 00 00	r1 = r4
     322:	79 a6 38 ff 00 00 00 00	r6 = *(u64 *)(r10 - 200)
     323:	bf 62 00 00 00 00 00 00	r2 = r6
     324:	b7 04 00 00 01 00 00 00	r4 = 1
     325:	85 00 00 00 1a 00 00 00	call 26
     326:	67 00 00 00 20 00 00 00	r0 <<= 32
     327:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     328:	c5 00 8f 00 00 00 00 00	if r0 s< 0 goto +143 <LBB13_82>
; 			if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) &&
     329:	71 a1 d8 ff 00 00 00 00	r1 = *(u8 *)(r10 - 40)
     330:	bf 12 00 00 00 00 00 00	r2 = r1
     331:	47 02 00 00 08 00 00 00	r2 |= 8
     332:	15 02 01 00 08 00 00 00	if r2 == 8 goto +1 <LBB13_49>
     333:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_51>

0000000000000a70 <LBB13_49>:
; 			     ctx_load_bytes(ctx, off + offsetof(struct icmphdr, un.echo.id),
     334:	07 06 00 00 04 00 00 00	r6 += 4
     335:	bf a3 00 00 00 00 00 00	r3 = r10
     336:	07 03 00 00 a0 ff ff ff	r3 += -96
; 			     ctx_load_bytes(ctx, off + offsetof(struct icmphdr, un.echo.id),
     337:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     338:	bf 62 00 00 00 00 00 00	r2 = r6
     339:	b7 04 00 00 02 00 00 00	r4 = 2
     340:	85 00 00 00 1a 00 00 00	call 26
     341:	67 00 00 00 20 00 00 00	r0 <<= 32
     342:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 			if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) &&
     343:	c5 00 80 00 00 00 00 00	if r0 s< 0 goto +128 <LBB13_82>
; 			switch (type) {
     344:	71 a1 d8 ff 00 00 00 00	r1 = *(u8 *)(r10 - 40)

0000000000000ac8 <LBB13_51>:
     345:	b7 02 00 00 00 00 00 00	r2 = 0
; 			tuple->dport = 0;
     346:	63 2a 88 ff 00 00 00 00	*(u32 *)(r10 - 120) = r2
     347:	b7 06 00 00 01 00 00 00	r6 = 1
; 			switch (type) {
     348:	7b 7a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r7
     349:	7b 9a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r9
     350:	65 01 ad 00 0a 00 00 00	if r1 s> 10 goto +173 <LBB13_173>
     351:	15 01 eb 00 00 00 00 00	if r1 == 0 goto +235 <LBB13_178>
     352:	15 01 ad 00 03 00 00 00	if r1 == 3 goto +173 <LBB13_174>
     353:	15 01 01 00 08 00 00 00	if r1 == 8 goto +1 <LBB13_55>
     354:	05 00 3e 06 00 00 00 00	goto +1598 <LBB13_180>

0000000000000b18 <LBB13_55>:
; 				tuple->dport = identifier;
     355:	69 a1 a0 ff 00 00 00 00	r1 = *(u16 *)(r10 - 96)
     356:	6b 1a 88 ff 00 00 00 00	*(u16 *)(r10 - 120) = r1
     357:	05 00 3b 06 00 00 00 00	goto +1595 <LBB13_180>

0000000000000b30 <LBB13_62>:
     358:	18 03 00 00 79 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967161 ll
     360:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
; 	return (void *)(unsigned long)ctx->data_end;
     361:	61 51 50 00 00 00 00 00	r1 = *(u32 *)(r5 + 80)
; 	return (void *)(unsigned long)ctx->data;
     362:	61 56 4c 00 00 00 00 00	r6 = *(u32 *)(r5 + 76)
; 	if (data + tot_len > data_end)
     363:	bf 62 00 00 00 00 00 00	r2 = r6
     364:	07 02 00 00 22 00 00 00	r2 += 34
     365:	2d 12 70 00 00 00 00 00	if r2 > r1 goto +112 <LBB13_86>
     366:	bf 87 00 00 00 00 00 00	r7 = r8
; 		.daddr = ip4->daddr,
     367:	61 61 1e 00 00 00 00 00	r1 = *(u32 *)(r6 + 30)
; 	struct ipv4_frag_id frag_id = {
     368:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 		.saddr = ip4->saddr,
     369:	61 61 1a 00 00 00 00 00	r1 = *(u32 *)(r6 + 26)
; 	struct ipv4_frag_id frag_id = {
     370:	63 1a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r1
; 		.id = ip4->id,
     371:	69 61 12 00 00 00 00 00	r1 = *(u16 *)(r6 + 18)
; 	struct ipv4_frag_id frag_id = {
     372:	6b 1a e0 ff 00 00 00 00	*(u16 *)(r10 - 32) = r1
     373:	b7 01 00 00 00 00 00 00	r1 = 0
; 		.proto = ip4->protocol,
     374:	71 62 17 00 00 00 00 00	r2 = *(u8 *)(r6 + 23)
; 	struct ipv4_frag_id frag_id = {
     375:	73 1a e3 ff 00 00 00 00	*(u8 *)(r10 - 29) = r1
     376:	73 2a e2 ff 00 00 00 00	*(u8 *)(r10 - 30) = r2
; 				    (struct ipv4_frag_l4ports *)&tuple->dport,
     377:	bf a3 00 00 00 00 00 00	r3 = r10
     378:	07 03 00 00 88 ff ff ff	r3 += -120
; 	return ip4->frag_off & bpf_htons(0x3FFF);
     379:	69 62 14 00 00 00 00 00	r2 = *(u16 *)(r6 + 20)
     380:	57 02 00 00 3f ff 00 00	r2 &= 65343
; 	if (unlikely(is_fragment)) {
     381:	55 02 35 02 00 00 00 00	if r2 != 0 goto +565 <LBB13_280>
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
     382:	bf 51 00 00 00 00 00 00	r1 = r5
     383:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
     384:	b7 04 00 00 04 00 00 00	r4 = 4
     385:	85 00 00 00 1a 00 00 00	call 26
     386:	b7 06 00 00 01 00 00 00	r6 = 1
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
     387:	67 00 00 00 20 00 00 00	r0 <<= 32
     388:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     389:	bf 03 00 00 00 00 00 00	r3 = r0
; 		if (err < 0)
     390:	c5 00 57 00 00 00 00 00	if r0 s< 0 goto +87 <LBB13_86>
     391:	05 00 48 03 00 00 00 00	goto +840 <LBB13_94>

0000000000000c40 <LBB13_65>:
     392:	18 03 00 00 79 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967161 ll
     394:	05 00 53 00 00 00 00 00	goto +83 <LBB13_86>

0000000000000c58 <LBB13_72>:
; 	return (void *)(unsigned long)ctx->data_end;
     395:	61 41 50 00 00 00 00 00	r1 = *(u32 *)(r4 + 80)
; 	return (void *)(unsigned long)ctx->data;
     396:	61 46 4c 00 00 00 00 00	r6 = *(u32 *)(r4 + 76)
; 	if (data + tot_len > data_end)
     397:	bf 62 00 00 00 00 00 00	r2 = r6
     398:	07 02 00 00 22 00 00 00	r2 += 34
     399:	2d 12 49 00 00 00 00 00	if r2 > r1 goto +73 <LBB13_83>
     400:	7b 5a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r5
     401:	7b 3a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r3
     402:	7b 9a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r9
     403:	7b 7a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r7
; 		.daddr = ip4->daddr,
     404:	61 61 1e 00 00 00 00 00	r1 = *(u32 *)(r6 + 30)
; 	struct ipv4_frag_id frag_id = {
     405:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 		.saddr = ip4->saddr,
     406:	61 61 1a 00 00 00 00 00	r1 = *(u32 *)(r6 + 26)
; 	struct ipv4_frag_id frag_id = {
     407:	63 1a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r1
; 		.id = ip4->id,
     408:	69 61 12 00 00 00 00 00	r1 = *(u16 *)(r6 + 18)
; 	struct ipv4_frag_id frag_id = {
     409:	6b 1a e0 ff 00 00 00 00	*(u16 *)(r10 - 32) = r1
     410:	b7 01 00 00 00 00 00 00	r1 = 0
; 		.proto = ip4->protocol,
     411:	71 62 17 00 00 00 00 00	r2 = *(u8 *)(r6 + 23)
; 	struct ipv4_frag_id frag_id = {
     412:	73 1a e3 ff 00 00 00 00	*(u8 *)(r10 - 29) = r1
     413:	73 2a e2 ff 00 00 00 00	*(u8 *)(r10 - 30) = r2
; 				    (struct ipv4_frag_l4ports *)&tuple->dport,
     414:	bf a7 00 00 00 00 00 00	r7 = r10
     415:	07 07 00 00 88 ff ff ff	r7 += -120
; 	return ip4->frag_off & bpf_htons(0x3FFF);
     416:	69 62 14 00 00 00 00 00	r2 = *(u16 *)(r6 + 20)
     417:	57 02 00 00 3f ff 00 00	r2 &= 65343
; 	if (unlikely(is_fragment)) {
     418:	55 02 39 02 00 00 00 00	if r2 != 0 goto +569 <LBB13_297>
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
     419:	bf 41 00 00 00 00 00 00	r1 = r4
     420:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
     421:	bf 73 00 00 00 00 00 00	r3 = r7
     422:	b7 04 00 00 04 00 00 00	r4 = 4
     423:	85 00 00 00 1a 00 00 00	call 26
     424:	b7 06 00 00 01 00 00 00	r6 = 1
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
     425:	67 00 00 00 20 00 00 00	r0 <<= 32
     426:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 		if (err < 0)
     427:	c5 00 01 00 00 00 00 00	if r0 s< 0 goto +1 <LBB13_75>
     428:	05 00 f4 05 00 00 00 00	goto +1524 <LBB13_180>

0000000000000d68 <LBB13_75>:
     429:	b7 01 00 00 00 00 00 00	r1 = 0
; 	switch (ret) {
     430:	7b 1a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r1
     431:	67 00 00 00 20 00 00 00	r0 <<= 32
     432:	77 00 00 00 20 00 00 00	r0 >>= 32
     433:	bf 01 00 00 00 00 00 00	r1 = r0
     434:	07 01 00 00 ff ff ff ff	r1 += -1
     435:	b7 02 00 00 00 00 00 00	r2 = 0
     436:	7b 2a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r2
     437:	b7 02 00 00 00 00 00 00	r2 = 0
     438:	7b 2a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r2
     439:	a5 01 87 06 04 00 00 00	if r1 < 4 goto +1671 <LBB13_203>
     440:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
; 	switch (ret) {
     441:	55 00 1f 00 00 00 00 00	if r0 != 0 goto +31 <LBB13_83>

0000000000000dd0 <LBB13_77>:
; 	return svc->flags & SVC_FLAG_AFFINITY;
     442:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
     443:	71 11 08 00 00 00 00 00	r1 = *(u8 *)(r1 + 8)
     444:	57 01 00 00 10 00 00 00	r1 &= 16
; 		if (lb4_svc_is_affinity(svc)) {
     445:	7b 9a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r9
     446:	15 01 b1 00 00 00 00 00	if r1 == 0 goto +177 <LBB13_229>
     447:	79 a7 e0 fe 00 00 00 00	r7 = *(u64 *)(r10 - 288)
; 		.client_id	= *id,
     448:	7b 7a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r7
     449:	79 a8 10 ff 00 00 00 00	r8 = *(u64 *)(r10 - 240)
; 		.rev_nat_id	= svc->rev_nat_index,
     450:	69 81 06 00 00 00 00 00	r1 = *(u16 *)(r8 + 6)
     451:	b7 06 00 00 00 00 00 00	r6 = 0
; 	struct lb4_affinity_key key = {
     452:	63 6a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r6
     453:	6b 6a aa ff 00 00 00 00	*(u16 *)(r10 - 86) = r6
     454:	6b 1a a8 ff 00 00 00 00	*(u16 *)(r10 - 88) = r1
     455:	bf a2 00 00 00 00 00 00	r2 = r10
     456:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	val = map_lookup_elem(&LB4_AFFINITY_MAP, &key);
     457:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     459:	85 00 00 00 01 00 00 00	call 1
     460:	bf 09 00 00 00 00 00 00	r9 = r0
; 	if (val != NULL) {
     461:	7b 7a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r7
     462:	55 09 43 00 00 00 00 00	if r9 != 0 goto +67 <LBB13_175>
     463:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
     464:	05 00 9f 00 00 00 00 00	goto +159 <LBB13_229>

0000000000000e88 <LBB13_80>:
; 			switch (type) {
     465:	07 01 00 00 f5 ff ff ff	r1 += -11
     466:	bf 87 00 00 00 00 00 00	r7 = r8
     467:	25 01 fc 02 01 00 00 00	if r1 > 1 goto +764 <LBB13_94>

0000000000000ea0 <LBB13_81>:
; 				tuple->flags |= TUPLE_F_RELATED;
     468:	71 a1 8d ff 00 00 00 00	r1 = *(u8 *)(r10 - 115)
     469:	47 01 00 00 02 00 00 00	r1 |= 2
     470:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
     471:	05 00 32 00 00 00 00 00	goto +50 <LBB13_93>

0000000000000ec0 <LBB13_82>:
     472:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)

0000000000000ec8 <LBB13_83>:
; 		tuple->flags = flags;
     473:	73 9a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r9
     474:	18 08 00 00 62 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967138 ll

0000000000000ee0 <LBB13_84>:
     476:	bf 83 00 00 00 00 00 00	r3 = r8

0000000000000ee8 <LBB13_85>:
     477:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)

0000000000000ef0 <LBB13_86>:
     478:	b7 05 00 00 00 00 00 00	r5 = 0
     479:	bf 38 00 00 00 00 00 00	r8 = r3

0000000000000f00 <LBB13_87>:
; 	if (IS_ERR(ret))
     480:	bf 81 00 00 00 00 00 00	r1 = r8
     481:	67 01 00 00 20 00 00 00	r1 <<= 32
     482:	77 01 00 00 20 00 00 00	r1 >>= 32
     483:	b7 02 00 00 01 00 00 00	r2 = 1
     484:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_89>
     485:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000000f30 <LBB13_89>:
     486:	77 01 00 00 1f 00 00 00	r1 >>= 31
     487:	4f 21 00 00 00 00 00 00	r1 |= r2
     488:	15 01 c8 01 00 00 00 00	if r1 == 0 goto +456 <LBB13_277>
     489:	b7 01 00 00 02 00 00 00	r1 = 2
     490:	79 a2 40 ff 00 00 00 00	r2 = *(u64 *)(r10 - 192)
; 	ctx->cb[off] = data;
     491:	63 12 40 00 00 00 00 00	*(u32 *)(r2 + 64) = r1
     492:	63 52 34 00 00 00 00 00	*(u32 *)(r2 + 52) = r5
     493:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     495:	63 12 30 00 00 00 00 00	*(u32 *)(r2 + 48) = r1
     496:	b7 01 00 00 00 00 00 00	r1 = 0
     497:	63 12 3c 00 00 00 00 00	*(u32 *)(r2 + 60) = r1
     498:	63 82 38 00 00 00 00 00	*(u32 *)(r2 + 56) = r8
     499:	bf 27 00 00 00 00 00 00	r7 = r2
; 	return ctx->len;
     500:	61 26 00 00 00 00 00 00	r6 = *(u32 *)(r2 + 0)
; 	struct metrics_value *entry, newEntry = {};
     501:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
     502:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     503:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
     504:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; 	update_metrics(ctx_full_len(ctx), direction, -reason);
     505:	87 08 00 00 00 00 00 00	r8 = -r8
; 	key.reason = reason;
     506:	73 8a d8 ff 00 00 00 00	*(u8 *)(r10 - 40) = r8
     507:	bf a2 00 00 00 00 00 00	r2 = r10
     508:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
     509:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     511:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
     512:	15 00 9e 01 00 00 00 00	if r0 == 0 goto +414 <LBB13_275>
; 		entry->count += 1;
     513:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
     514:	07 01 00 00 01 00 00 00	r1 += 1
     515:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
     516:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
     517:	0f 61 00 00 00 00 00 00	r1 += r6
     518:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
     519:	05 00 a2 01 00 00 00 00	goto +418 <LBB13_276>

0000000000001040 <LBB13_92>:
; 				tuple->sport = identifier;
     520:	69 a1 a0 ff 00 00 00 00	r1 = *(u16 *)(r10 - 96)
     521:	6b 1a 8a ff 00 00 00 00	*(u16 *)(r10 - 118) = r1

0000000000001050 <LBB13_93>:
     522:	b7 06 00 00 00 00 00 00	r6 = 0
     523:	05 00 c4 02 00 00 00 00	goto +708 <LBB13_94>

0000000000001060 <LBB13_173>:
; 			switch (type) {
     524:	07 01 00 00 f5 ff ff ff	r1 += -11
     525:	25 01 93 05 01 00 00 00	if r1 > 1 goto +1427 <LBB13_180>

0000000000001070 <LBB13_174>:
; 				tuple->flags |= TUPLE_F_RELATED;
     526:	71 a1 8d ff 00 00 00 00	r1 = *(u8 *)(r10 - 115)
     527:	47 01 00 00 02 00 00 00	r1 |= 2
     528:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
     529:	05 00 3b 00 00 00 00 00	goto +59 <LBB13_179>

0000000000001090 <LBB13_175>:
; 		__u32 now = bpf_mono_now();
     530:	85 00 00 00 05 00 00 00	call 5
     531:	bf 07 00 00 00 00 00 00	r7 = r0
; 			.backend_id	= val->backend_id,
     532:	71 91 09 00 00 00 00 00	r1 = *(u8 *)(r9 + 9)
     533:	67 01 00 00 08 00 00 00	r1 <<= 8
     534:	71 92 08 00 00 00 00 00	r2 = *(u8 *)(r9 + 8)
     535:	4f 21 00 00 00 00 00 00	r1 |= r2
     536:	71 92 0b 00 00 00 00 00	r2 = *(u8 *)(r9 + 11)
     537:	67 02 00 00 08 00 00 00	r2 <<= 8
     538:	71 93 0a 00 00 00 00 00	r3 = *(u8 *)(r9 + 10)
     539:	4f 32 00 00 00 00 00 00	r2 |= r3
     540:	67 02 00 00 10 00 00 00	r2 <<= 16
     541:	4f 12 00 00 00 00 00 00	r2 |= r1
; 		struct lb_affinity_match match = {
     542:	63 2a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r2
; 			.rev_nat_id	= svc->rev_nat_index,
     543:	69 81 06 00 00 00 00 00	r1 = *(u16 *)(r8 + 6)
; 		struct lb_affinity_match match = {
     544:	6b 6a de ff 00 00 00 00	*(u16 *)(r10 - 34) = r6
     545:	6b 1a dc ff 00 00 00 00	*(u16 *)(r10 - 36) = r1
; 		if (READ_ONCE(val->last_used) +
     546:	71 92 01 00 00 00 00 00	r2 = *(u8 *)(r9 + 1)
     547:	67 02 00 00 08 00 00 00	r2 <<= 8
     548:	71 91 00 00 00 00 00 00	r1 = *(u8 *)(r9 + 0)
     549:	4f 12 00 00 00 00 00 00	r2 |= r1
     550:	71 91 03 00 00 00 00 00	r1 = *(u8 *)(r9 + 3)
     551:	67 01 00 00 08 00 00 00	r1 <<= 8
     552:	71 93 02 00 00 00 00 00	r3 = *(u8 *)(r9 + 2)
     553:	4f 31 00 00 00 00 00 00	r1 |= r3
     554:	67 01 00 00 10 00 00 00	r1 <<= 16
     555:	4f 21 00 00 00 00 00 00	r1 |= r2
     556:	71 92 05 00 00 00 00 00	r2 = *(u8 *)(r9 + 5)
     557:	67 02 00 00 08 00 00 00	r2 <<= 8
     558:	71 93 04 00 00 00 00 00	r3 = *(u8 *)(r9 + 4)
     559:	4f 32 00 00 00 00 00 00	r2 |= r3
     560:	71 93 06 00 00 00 00 00	r3 = *(u8 *)(r9 + 6)
     561:	71 94 07 00 00 00 00 00	r4 = *(u8 *)(r9 + 7)
     562:	67 04 00 00 08 00 00 00	r4 <<= 8
     563:	4f 34 00 00 00 00 00 00	r4 |= r3
     564:	67 04 00 00 10 00 00 00	r4 <<= 16
     565:	4f 24 00 00 00 00 00 00	r4 |= r2
     566:	67 04 00 00 20 00 00 00	r4 <<= 32
     567:	4f 14 00 00 00 00 00 00	r4 |= r1
; 		    bpf_sec_to_mono(svc->affinity_timeout) <= now) {
     568:	61 81 00 00 00 00 00 00	r1 = *(u32 *)(r8 + 0)
; 		if (READ_ONCE(val->last_used) +
     569:	0f 14 00 00 00 00 00 00	r4 += r1
; 		__u32 now = bpf_mono_now();
     570:	37 07 00 00 00 ca 9a 3b	r7 /= 1000000000
; 		    bpf_sec_to_mono(svc->affinity_timeout) <= now) {
     571:	67 07 00 00 20 00 00 00	r7 <<= 32
     572:	77 07 00 00 20 00 00 00	r7 >>= 32
; 		if (READ_ONCE(val->last_used) +
     573:	bd 74 06 00 00 00 00 00	if r4 <= r7 goto +6 <LBB13_177>
     574:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (!map_lookup_elem(&LB_AFFINITY_MATCH_MAP, &match)) {
     575:	07 02 00 00 d8 ff ff ff	r2 += -40
     576:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     578:	85 00 00 00 01 00 00 00	call 1
     579:	55 00 0b 00 00 00 00 00	if r0 != 0 goto +11 <LBB13_227>

0000000000001220 <LBB13_177>:
     580:	bf a2 00 00 00 00 00 00	r2 = r10
     581:	07 02 00 00 a0 ff ff ff	r2 += -96
     582:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     584:	85 00 00 00 03 00 00 00	call 3
     585:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
     586:	05 00 25 00 00 00 00 00	goto +37 <LBB13_229>

0000000000001258 <LBB13_178>:
; 				tuple->sport = identifier;
     587:	69 a1 a0 ff 00 00 00 00	r1 = *(u16 *)(r10 - 96)
     588:	6b 1a 8a ff 00 00 00 00	*(u16 *)(r10 - 118) = r1

0000000000001268 <LBB13_179>:
     589:	b7 06 00 00 00 00 00 00	r6 = 0
     590:	05 00 52 05 00 00 00 00	goto +1362 <LBB13_180>

0000000000001278 <LBB13_227>:
     591:	b7 01 00 00 00 00 00 00	r1 = 0
; 		WRITE_ONCE(val->last_used, now);
     592:	73 19 07 00 00 00 00 00	*(u8 *)(r9 + 7) = r1
     593:	73 19 06 00 00 00 00 00	*(u8 *)(r9 + 6) = r1
     594:	73 19 05 00 00 00 00 00	*(u8 *)(r9 + 5) = r1
     595:	73 19 04 00 00 00 00 00	*(u8 *)(r9 + 4) = r1
     596:	bf 71 00 00 00 00 00 00	r1 = r7
     597:	77 01 00 00 18 00 00 00	r1 >>= 24
     598:	73 19 03 00 00 00 00 00	*(u8 *)(r9 + 3) = r1
     599:	bf 71 00 00 00 00 00 00	r1 = r7
     600:	77 01 00 00 10 00 00 00	r1 >>= 16
     601:	73 19 02 00 00 00 00 00	*(u8 *)(r9 + 2) = r1
     602:	73 79 00 00 00 00 00 00	*(u8 *)(r9 + 0) = r7
     603:	77 07 00 00 08 00 00 00	r7 >>= 8
     604:	73 79 01 00 00 00 00 00	*(u8 *)(r9 + 1) = r7
; 		return val->backend_id;
     605:	71 91 09 00 00 00 00 00	r1 = *(u8 *)(r9 + 9)
     606:	67 01 00 00 08 00 00 00	r1 <<= 8
     607:	71 92 08 00 00 00 00 00	r2 = *(u8 *)(r9 + 8)
     608:	4f 21 00 00 00 00 00 00	r1 |= r2
     609:	71 92 0a 00 00 00 00 00	r2 = *(u8 *)(r9 + 10)
     610:	71 96 0b 00 00 00 00 00	r6 = *(u8 *)(r9 + 11)
     611:	67 06 00 00 08 00 00 00	r6 <<= 8
     612:	4f 26 00 00 00 00 00 00	r6 |= r2
     613:	67 06 00 00 10 00 00 00	r6 <<= 16
     614:	4f 16 00 00 00 00 00 00	r6 |= r1
     615:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
; 			if (backend_id != 0) {
     616:	15 06 07 00 00 00 00 00	if r6 == 0 goto +7 <LBB13_229>
     617:	6b 6a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r6
     618:	bf a2 00 00 00 00 00 00	r2 = r10
     619:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(&LB4_BACKEND_MAP, &backend_id);
     620:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     622:	85 00 00 00 01 00 00 00	call 1
     623:	55 00 1a 00 00 00 00 00	if r0 != 0 goto +26 <LBB13_232>

0000000000001380 <LBB13_229>:
; 	__u32 slot = (get_prandom_u32() % svc->count) + 1;
     624:	85 00 00 00 07 00 00 00	call 7
     625:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
     626:	69 11 04 00 00 00 00 00	r1 = *(u16 *)(r1 + 4)
     627:	bf 02 00 00 00 00 00 00	r2 = r0
     628:	67 02 00 00 20 00 00 00	r2 <<= 32
     629:	77 02 00 00 20 00 00 00	r2 >>= 32
     630:	3f 12 00 00 00 00 00 00	r2 /= r1
     631:	2f 12 00 00 00 00 00 00	r2 *= r1
     632:	1f 20 00 00 00 00 00 00	r0 -= r2
; 	struct lb4_service *be = lb4_lookup_backend_slot(ctx, key, slot);
     633:	07 00 00 00 01 00 00 00	r0 += 1
; 	key->backend_slot = slot;
     634:	6b 0a 4e ff 00 00 00 00	*(u16 *)(r10 - 178) = r0
     635:	bf a2 00 00 00 00 00 00	r2 = r10
     636:	07 02 00 00 48 ff ff ff	r2 += -184
; 	return map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
     637:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     639:	85 00 00 00 01 00 00 00	call 1
     640:	b7 06 00 00 00 00 00 00	r6 = 0
; 	return be ? be->backend_id : 0;
     641:	15 00 01 00 00 00 00 00	if r0 == 0 goto +1 <LBB13_231>
     642:	61 06 00 00 00 00 00 00	r6 = *(u32 *)(r0 + 0)

0000000000001418 <LBB13_231>:
     643:	6b 6a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r6
     644:	bf a2 00 00 00 00 00 00	r2 = r10
     645:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(&LB4_BACKEND_MAP, &backend_id);
     646:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     648:	85 00 00 00 01 00 00 00	call 1
; 			if (backend == NULL)
     649:	15 00 4f ff 00 00 00 00	if r0 == 0 goto -177 <LBB13_83>

0000000000001450 <LBB13_232>:
     650:	7b 0a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r0
; 		state->rev_nat_index = svc->rev_nat_index;
     651:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
     652:	69 18 06 00 00 00 00 00	r8 = *(u16 *)(r1 + 6)
     653:	b7 07 00 00 00 00 00 00	r7 = 0
; 	struct ct_entry entry = { };
     654:	7b 7a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r7
     655:	7b 7a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r7
     656:	7b 7a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r7
     657:	7b 7a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r7
     658:	7b 7a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r7
     659:	7b 7a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r7
     660:	7b 7a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r7
; 	bool is_tcp = tuple->nexthdr == IPPROTO_TCP;
     661:	71 a9 8c ff 00 00 00 00	r9 = *(u8 *)(r10 - 116)
;        volatile int __maybe_unused id = get_smp_processor_id();
     662:	85 00 00 00 08 00 00 00	call 8
     663:	63 0a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r0
; 	entry.rev_nat_index = ct_state->rev_nat_index;
     664:	6b 8a c6 ff 00 00 00 00	*(u16 *)(r10 - 58) = r8
     665:	7b 6a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r6
; 		entry.backend_id = ct_state->backend_id;
     666:	57 06 00 00 ff ff 00 00	r6 &= 65535
     667:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
; 	entry.ifindex = ct_state->ifindex;
     668:	6b 7a c8 ff 00 00 00 00	*(u16 *)(r10 - 56) = r7
; 	entry.dsr = ct_state->dsr;
     669:	6b 7a c4 ff 00 00 00 00	*(u16 *)(r10 - 60) = r7
     670:	b7 06 00 00 01 00 00 00	r6 = 1
; 	bool is_tcp = tuple->nexthdr == IPPROTO_TCP;
     671:	15 09 01 00 06 00 00 00	if r9 == 6 goto +1 <LBB13_234>
     672:	b7 06 00 00 00 00 00 00	r6 = 0

0000000000001508 <LBB13_234>:
     673:	b7 07 00 00 3c 00 00 00	r7 = 60
     674:	67 06 00 00 01 00 00 00	r6 <<= 1
; 	if (tcp) {
     675:	55 09 08 00 06 00 00 00	if r9 != 6 goto +8 <LBB13_238>
     676:	bf 61 00 00 00 00 00 00	r1 = r6
     677:	67 01 00 00 03 00 00 00	r1 <<= 3
; 		entry->seen_non_syn |= !syn;
     678:	a7 01 00 00 10 00 00 00	r1 ^= 16
     679:	57 01 00 00 f8 00 00 00	r1 &= 248
     680:	b7 07 00 00 3c 00 00 00	r7 = 60
     681:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_237>
     682:	b7 07 00 00 60 54 00 00	r7 = 21600

0000000000001558 <LBB13_237>:
; 		entry->seen_non_syn |= !syn;
     683:	6b 1a c4 ff 00 00 00 00	*(u16 *)(r10 - 60) = r1

0000000000001560 <LBB13_238>:
; 	__u32 now = bpf_mono_now();
     684:	85 00 00 00 05 00 00 00	call 5
     685:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
     686:	0f 07 00 00 00 00 00 00	r7 += r0
     687:	63 7a c0 ff 00 00 00 00	*(u32 *)(r10 - 64) = r7
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
     688:	71 a3 ca ff 00 00 00 00	r3 = *(u8 *)(r10 - 54)
; 		last_report = READ_ONCE(entry->last_tx_report);
     689:	61 a2 d0 ff 00 00 00 00	r2 = *(u32 *)(r10 - 48)
; 	seen_flags |= accumulated_flags;
     690:	bf 31 00 00 00 00 00 00	r1 = r3
     691:	4f 61 00 00 00 00 00 00	r1 |= r6
     692:	bf 14 00 00 00 00 00 00	r4 = r1
     693:	57 04 00 00 ff 00 00 00	r4 &= 255
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
     694:	5d 43 07 00 00 00 00 00	if r3 != r4 goto +7 <LBB13_240>
     695:	07 02 00 00 05 00 00 00	r2 += 5
     696:	bf 03 00 00 00 00 00 00	r3 = r0
     697:	67 03 00 00 20 00 00 00	r3 <<= 32
     698:	77 03 00 00 20 00 00 00	r3 >>= 32
     699:	67 02 00 00 20 00 00 00	r2 <<= 32
     700:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
     701:	3d 32 02 00 00 00 00 00	if r2 >= r3 goto +2 <LBB13_241>

00000000000015f0 <LBB13_240>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
     702:	73 1a ca ff 00 00 00 00	*(u8 *)(r10 - 54) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
     703:	63 0a d0 ff 00 00 00 00	*(u32 *)(r10 - 48) = r0

0000000000001600 <LBB13_241>:
     704:	b7 01 00 00 00 00 00 00	r1 = 0
     705:	b7 02 00 00 00 00 00 00	r2 = 0
; 	entry.src_sec_id = ct_state->src_sec_id;
     706:	7b 2a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r2
     707:	63 1a cc ff 00 00 00 00	*(u32 *)(r10 - 52) = r1
     708:	bf a2 00 00 00 00 00 00	r2 = r10
     709:	07 02 00 00 80 ff ff ff	r2 += -128
     710:	bf a3 00 00 00 00 00 00	r3 = r10
     711:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	if (map_update_elem(map_main, tuple, &entry, 0) < 0) {
     712:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
     713:	b7 04 00 00 00 00 00 00	r4 = 0
     714:	85 00 00 00 02 00 00 00	call 2
     715:	67 00 00 00 20 00 00 00	r0 <<= 32
     716:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     717:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
     718:	79 a6 f0 fe 00 00 00 00	r6 = *(u64 *)(r10 - 272)
     719:	c5 00 c3 00 00 00 00 00	if r0 s< 0 goto +195 <LBB13_273>
; 	struct ct_state ct_state_new = {};
     720:	b7 01 00 00 00 00 00 00	r1 = 0
; 		if (IS_ERR(ret))
     721:	7b 1a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r1
     722:	79 a5 f8 fe 00 00 00 00	r5 = *(u64 *)(r10 - 264)

0000000000001698 <LBB13_243>:
; 	tuple->flags = flags;
     723:	73 9a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r9
; 	state->addr = new_daddr = backend->address;
     724:	61 53 00 00 00 00 00 00	r3 = *(u32 *)(r5 + 0)
     725:	79 a8 10 ff 00 00 00 00	r8 = *(u64 *)(r10 - 240)
; 	state->rev_nat_index = svc->rev_nat_index;
     726:	69 89 06 00 00 00 00 00	r9 = *(u16 *)(r8 + 6)
; 	state->addr = new_daddr = backend->address;
     727:	63 3a 90 ff 00 00 00 00	*(u32 *)(r10 - 112) = r3
; 	return svc->flags & SVC_FLAG_AFFINITY;
     728:	71 81 08 00 00 00 00 00	r1 = *(u8 *)(r8 + 8)
     729:	57 01 00 00 10 00 00 00	r1 &= 16
     730:	7b 5a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r5
; 	if (lb4_svc_is_affinity(svc))
     731:	15 01 1a 00 00 00 00 00	if r1 == 0 goto +26 <LBB13_245>
     732:	bf 37 00 00 00 00 00 00	r7 = r3
; 	__u32 now = bpf_mono_now();
     733:	85 00 00 00 05 00 00 00	call 5
; 		.client_id	= *id,
     734:	79 a1 e0 fe 00 00 00 00	r1 = *(u64 *)(r10 - 288)
     735:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
; 		.rev_nat_id	= svc->rev_nat_index,
     736:	69 81 06 00 00 00 00 00	r1 = *(u16 *)(r8 + 6)
; 	struct lb4_affinity_key key = {
     737:	6b 1a a8 ff 00 00 00 00	*(u16 *)(r10 - 88) = r1
     738:	b7 01 00 00 00 00 00 00	r1 = 0
     739:	63 1a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r1
     740:	6b 1a aa ff 00 00 00 00	*(u16 *)(r10 - 86) = r1
; 					    state->backend_id);
     741:	57 06 00 00 ff ff 00 00	r6 &= 65535
; 	struct lb_affinity_val val = {
     742:	63 6a e0 ff 00 00 00 00	*(u32 *)(r10 - 32) = r6
; 	__u32 now = bpf_mono_now();
     743:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 		.last_used	= now,
     744:	67 00 00 00 20 00 00 00	r0 <<= 32
     745:	77 00 00 00 20 00 00 00	r0 >>= 32
; 	struct lb_affinity_val val = {
     746:	7b 0a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r0
     747:	63 1a e4 ff 00 00 00 00	*(u32 *)(r10 - 28) = r1
     748:	bf a2 00 00 00 00 00 00	r2 = r10
     749:	07 02 00 00 a0 ff ff ff	r2 += -96
     750:	bf a3 00 00 00 00 00 00	r3 = r10
     751:	07 03 00 00 d8 ff ff ff	r3 += -40
; 	map_update_elem(&LB4_AFFINITY_MAP, &key, &val, 0);
     752:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     754:	b7 04 00 00 00 00 00 00	r4 = 0
     755:	85 00 00 00 02 00 00 00	call 2
     756:	79 a5 f8 fe 00 00 00 00	r5 = *(u64 *)(r10 - 264)
     757:	bf 73 00 00 00 00 00 00	r3 = r7

00000000000017b0 <LBB13_245>:
     758:	b7 04 00 00 00 00 00 00	r4 = 0
; 	if (saddr == backend->address) {
     759:	61 52 00 00 00 00 00 00	r2 = *(u32 *)(r5 + 0)
     760:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     761:	79 a6 d8 fe 00 00 00 00	r6 = *(u64 *)(r10 - 296)
     762:	79 a7 e0 fe 00 00 00 00	r7 = *(u64 *)(r10 - 288)
     763:	5d 72 04 00 00 00 00 00	if r2 != r7 goto +4 <LBB13_247>
     764:	b7 03 00 00 0a f5 ff 1f	r3 = 536868106
; 		new_saddr = IPV4_LOOPBACK;
     765:	63 3a 94 ff 00 00 00 00	*(u32 *)(r10 - 108) = r3
; 		state->loopback = 1;
     766:	47 06 00 00 01 00 00 00	r6 |= 1
     767:	bf 74 00 00 00 00 00 00	r4 = r7

0000000000001800 <LBB13_247>:
     768:	7b 9a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r9
     769:	7b 4a e8 fe 00 00 00 00	*(u64 *)(r10 - 280) = r4
     770:	7b 3a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r3
     771:	7b 6a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r6
; 	if (!state->loopback)
     772:	57 06 00 00 01 00 00 00	r6 &= 1
     773:	55 06 02 00 00 00 00 00	if r6 != 0 goto +2 <LBB13_249>
; 		tuple->daddr = backend->address;
     774:	61 52 00 00 00 00 00 00	r2 = *(u32 *)(r5 + 0)
     775:	63 2a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r2

0000000000001840 <LBB13_249>:
; 			 tuple->nexthdr, l3_off, l4_off, csum_off, key,
     776:	71 a2 8c ff 00 00 00 00	r2 = *(u8 *)(r10 - 116)
; 	ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, daddr),
     777:	7b 2a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r2
     778:	bf a3 00 00 00 00 00 00	r3 = r10
; 			 tuple->nexthdr, l3_off, l4_off, csum_off, key,
     779:	07 03 00 00 90 ff ff ff	r3 += -112
; 	ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, daddr),
     780:	b7 02 00 00 1e 00 00 00	r2 = 30
     781:	b7 04 00 00 04 00 00 00	r4 = 4
     782:	b7 05 00 00 00 00 00 00	r5 = 0
     783:	85 00 00 00 09 00 00 00	call 9
     784:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, daddr),
     786:	67 00 00 00 20 00 00 00	r0 <<= 32
     787:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (ret < 0)
     788:	c5 00 c7 fe 00 00 00 00	if r0 s< 0 goto -313 <LBB13_84>
     789:	61 a1 48 ff 00 00 00 00	r1 = *(u32 *)(r10 - 184)
     790:	a7 01 00 00 ff ff ff ff	r1 ^= -1
     791:	67 01 00 00 20 00 00 00	r1 <<= 32
     792:	77 01 00 00 20 00 00 00	r1 >>= 32
     793:	61 a9 90 ff 00 00 00 00	r9 = *(u32 *)(r10 - 112)
     794:	0f 19 00 00 00 00 00 00	r9 += r1
     795:	bf 92 00 00 00 00 00 00	r2 = r9
     796:	67 02 00 00 20 00 00 00	r2 <<= 32
     797:	77 02 00 00 20 00 00 00	r2 >>= 32
     798:	b7 01 00 00 01 00 00 00	r1 = 1
     799:	5d 92 01 00 00 00 00 00	if r2 != r9 goto +1 <LBB13_252>
     800:	b7 01 00 00 00 00 00 00	r1 = 0

0000000000001908 <LBB13_252>:
     801:	0f 19 00 00 00 00 00 00	r9 += r1
; 	if (new_saddr && *new_saddr) {
     802:	61 a2 94 ff 00 00 00 00	r2 = *(u32 *)(r10 - 108)
     803:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	if (new_saddr && *new_saddr) {
     804:	15 02 23 00 00 00 00 00	if r2 == 0 goto +35 <LBB13_259>
     805:	bf a3 00 00 00 00 00 00	r3 = r10
; 		ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, saddr),
     806:	07 03 00 00 94 ff ff ff	r3 += -108
     807:	b7 02 00 00 1a 00 00 00	r2 = 26
     808:	b7 04 00 00 04 00 00 00	r4 = 4
     809:	b7 05 00 00 00 00 00 00	r5 = 0
     810:	85 00 00 00 09 00 00 00	call 9
     811:	67 00 00 00 20 00 00 00	r0 <<= 32
     812:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 		if (ret < 0)
     813:	c5 00 ae fe 00 00 00 00	if r0 s< 0 goto -338 <LBB13_84>
     814:	18 01 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967295 ll
     816:	af 17 00 00 00 00 00 00	r7 ^= r1
     817:	61 a5 94 ff 00 00 00 00	r5 = *(u32 *)(r10 - 108)
     818:	0f 75 00 00 00 00 00 00	r5 += r7
     819:	bf 54 00 00 00 00 00 00	r4 = r5
     820:	67 04 00 00 20 00 00 00	r4 <<= 32
     821:	77 04 00 00 20 00 00 00	r4 >>= 32
     822:	b7 02 00 00 01 00 00 00	r2 = 1
     823:	b7 03 00 00 01 00 00 00	r3 = 1
     824:	5d 54 01 00 00 00 00 00	if r4 != r5 goto +1 <LBB13_256>
     825:	b7 03 00 00 00 00 00 00	r3 = 0

00000000000019d0 <LBB13_256>:
     826:	0f 35 00 00 00 00 00 00	r5 += r3
     827:	67 05 00 00 20 00 00 00	r5 <<= 32
; 	csum += addend;
     828:	67 09 00 00 20 00 00 00	r9 <<= 32
     829:	77 05 00 00 20 00 00 00	r5 >>= 32
; 	csum += addend;
     830:	77 09 00 00 20 00 00 00	r9 >>= 32
     831:	0f 95 00 00 00 00 00 00	r5 += r9
     832:	bf 53 00 00 00 00 00 00	r3 = r5
     833:	67 03 00 00 20 00 00 00	r3 <<= 32
     834:	77 03 00 00 20 00 00 00	r3 >>= 32
     835:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     836:	5d 53 01 00 00 00 00 00	if r3 != r5 goto +1 <LBB13_258>
     837:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000001a30 <LBB13_258>:
; 	return csum + (csum < addend);
     838:	0f 25 00 00 00 00 00 00	r5 += r2
     839:	bf 59 00 00 00 00 00 00	r9 = r5

0000000000001a40 <LBB13_259>:
; 	if (l3_csum_replace(ctx, l3_off + offsetof(struct iphdr, check),
     840:	b7 02 00 00 18 00 00 00	r2 = 24
     841:	b7 03 00 00 00 00 00 00	r3 = 0
     842:	bf 94 00 00 00 00 00 00	r4 = r9
     843:	b7 05 00 00 00 00 00 00	r5 = 0
     844:	85 00 00 00 0a 00 00 00	call 10
     845:	18 08 00 00 67 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967143 ll
; 	if (l3_csum_replace(ctx, l3_off + offsetof(struct iphdr, check),
     847:	67 00 00 00 20 00 00 00	r0 <<= 32
     848:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     849:	c5 00 8a fe 00 00 00 00	if r0 s< 0 goto -374 <LBB13_84>
; 	if (csum_off->offset) {
     850:	79 a1 28 ff 00 00 00 00	r1 = *(u64 *)(r10 - 216)
     851:	15 01 0e 00 00 00 00 00	if r1 == 0 goto +14 <LBB13_262>
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
     852:	79 a2 28 ff 00 00 00 00	r2 = *(u64 *)(r10 - 216)
     853:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
     854:	0f 12 00 00 00 00 00 00	r2 += r1
     855:	79 a5 20 ff 00 00 00 00	r5 = *(u64 *)(r10 - 224)
     856:	47 05 00 00 10 00 00 00	r5 |= 16
     857:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     858:	b7 03 00 00 00 00 00 00	r3 = 0
     859:	bf 94 00 00 00 00 00 00	r4 = r9
     860:	85 00 00 00 0b 00 00 00	call 11
     861:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
     863:	67 00 00 00 20 00 00 00	r0 <<= 32
     864:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 		if (csum_l4_replace(ctx, l4_off, csum_off, 0, sum,
     865:	c5 00 7a fe 00 00 00 00	if r0 s< 0 goto -390 <LBB13_84>

0000000000001b10 <LBB13_262>:
; 	if (likely(backend->port) && key->dport != backend->port &&
     866:	79 a1 f8 fe 00 00 00 00	r1 = *(u64 *)(r10 - 264)
     867:	69 14 04 00 00 00 00 00	r4 = *(u16 *)(r1 + 4)
     868:	15 04 24 00 00 00 00 00	if r4 == 0 goto +36 <LBB13_270>
     869:	69 a3 4c ff 00 00 00 00	r3 = *(u16 *)(r10 - 180)
     870:	1d 43 22 00 00 00 00 00	if r3 == r4 goto +34 <LBB13_270>
; 	    (nexthdr == IPPROTO_TCP || nexthdr == IPPROTO_UDP) &&
     871:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
     872:	15 01 02 00 11 00 00 00	if r1 == 17 goto +2 <LBB13_266>
     873:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
     874:	55 01 1e 00 06 00 00 00	if r1 != 6 goto +30 <LBB13_270>

0000000000001b58 <LBB13_266>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
     875:	79 a1 18 ff 00 00 00 00	r1 = *(u64 *)(r10 - 232)
     876:	57 01 00 00 ff ff 00 00	r1 &= 65535
; 	if (likely(backend->port) && key->dport != backend->port &&
     877:	55 01 1b 00 00 00 00 00	if r1 != 0 goto +27 <LBB13_270>
     878:	6b 4a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r4
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
     879:	79 a2 28 ff 00 00 00 00	r2 = *(u64 *)(r10 - 216)
     880:	79 a7 38 ff 00 00 00 00	r7 = *(u64 *)(r10 - 200)
     881:	0f 72 00 00 00 00 00 00	r2 += r7
     882:	79 a5 20 ff 00 00 00 00	r5 = *(u64 *)(r10 - 224)
     883:	47 05 00 00 02 00 00 00	r5 |= 2
     884:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     885:	85 00 00 00 0b 00 00 00	call 11
     886:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
     888:	67 00 00 00 20 00 00 00	r0 <<= 32
     889:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (csum_l4_replace(ctx, l4_off, csum_off, old_port, port, sizeof(port)) < 0)
     890:	c5 00 0d 00 00 00 00 00	if r0 s< 0 goto +13 <LBB13_269>
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
     891:	bf 72 00 00 00 00 00 00	r2 = r7
     892:	07 02 00 00 02 00 00 00	r2 += 2
     893:	bf a3 00 00 00 00 00 00	r3 = r10
     894:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
     895:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     896:	b7 04 00 00 02 00 00 00	r4 = 2
     897:	b7 05 00 00 00 00 00 00	r5 = 0
     898:	85 00 00 00 09 00 00 00	call 9
     899:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
     901:	67 00 00 00 20 00 00 00	r0 <<= 32
     902:	c7 00 00 00 20 00 00 00	r0 s>>= 32
     903:	65 00 01 00 ff ff ff ff	if r0 s> -1 goto +1 <LBB13_270>

0000000000001c40 <LBB13_269>:
     904:	05 00 53 fe 00 00 00 00	goto -429 <LBB13_84>

0000000000001c48 <LBB13_270>:
     905:	b7 04 00 00 01 00 00 00	r4 = 1
; 			hairpin_flow |= ct_state_new.loopback;
     906:	55 06 01 00 00 00 00 00	if r6 != 0 goto +1 <LBB13_272>
     907:	b7 04 00 00 00 00 00 00	r4 = 0

0000000000001c60 <LBB13_272>:
     908:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     909:	79 a8 d8 fe 00 00 00 00	r8 = *(u64 *)(r10 - 296)
     910:	79 a5 00 ff 00 00 00 00	r5 = *(u64 *)(r10 - 256)
     911:	79 a6 f0 fe 00 00 00 00	r6 = *(u64 *)(r10 - 272)
     912:	79 a7 e8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 280)
     913:	79 a9 08 ff 00 00 00 00	r9 = *(u64 *)(r10 - 248)
     914:	05 00 3e fd 00 00 00 00	goto -706 <LBB13_26>

0000000000001c98 <LBB13_273>:
     915:	b7 01 00 00 01 00 00 00	r1 = 1
; 	struct signal_msg msg = {
     916:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
     917:	bf a4 00 00 00 00 00 00	r4 = r10
     918:	07 04 00 00 d8 ff ff ff	r4 += -40
; 	ctx_event_output(ctx, &SIGNAL_MAP, BPF_F_CURRENT_CPU,
     919:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
     920:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
     922:	18 03 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967295 ll
     924:	b7 05 00 00 08 00 00 00	r5 = 8
     925:	85 00 00 00 19 00 00 00	call 25
     926:	05 00 3a fe 00 00 00 00	goto -454 <LBB13_83>

0000000000001cf8 <LBB13_275>:
; 		newEntry.bytes = bytes;
     927:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
     928:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
     929:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     930:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
     931:	07 02 00 00 d8 ff ff ff	r2 += -40
     932:	bf a3 00 00 00 00 00 00	r3 = r10
     933:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
     934:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     936:	b7 04 00 00 00 00 00 00	r4 = 0
     937:	85 00 00 00 02 00 00 00	call 2

0000000000001d50 <LBB13_276>:
; 	asm volatile("r1 = %[ctx]\n\t"
     938:	18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r6 = 0 ll
     940:	bf 71 00 00 00 00 00 00	r1 = r7
     941:	bf 62 00 00 00 00 00 00	r2 = r6
     942:	b7 03 00 00 01 00 00 00	r3 = 1
     943:	85 00 00 00 0c 00 00 00	call 12
     944:	b7 08 00 00 02 00 00 00	r8 = 2

0000000000001d88 <LBB13_277>:
; }
     945:	bf 80 00 00 00 00 00 00	r0 = r8
     946:	95 00 00 00 00 00 00 00	exit

0000000000001d98 <LBB13_280>:
     947:	7b 3a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r3
     948:	79 a2 30 ff 00 00 00 00	r2 = *(u64 *)(r10 - 208)
; 	return ctx->len;
     949:	61 58 00 00 00 00 00 00	r8 = *(u32 *)(r5 + 0)
; 	struct metrics_value *entry, newEntry = {};
     950:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
     951:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     952:	b7 01 00 00 09 02 00 00	r1 = 521
; 	struct metrics_key key = {};
     953:	7b 1a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r1
     954:	bf a2 00 00 00 00 00 00	r2 = r10
     955:	07 02 00 00 48 ff ff ff	r2 += -184
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
     956:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     958:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
     959:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_286>
; 		entry->count += 1;
     960:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
     961:	07 01 00 00 01 00 00 00	r1 += 1
     962:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
     963:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
     964:	0f 81 00 00 00 00 00 00	r1 += r8
     965:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
     966:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_287>

0000000000001e38 <LBB13_286>:
; 		newEntry.bytes = bytes;
     967:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
     968:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
     969:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     970:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
     971:	07 02 00 00 48 ff ff ff	r2 += -184
     972:	bf a3 00 00 00 00 00 00	r3 = r10
     973:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
     974:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     976:	b7 04 00 00 00 00 00 00	r4 = 0
     977:	85 00 00 00 02 00 00 00	call 2

0000000000001e90 <LBB13_287>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
     978:	69 61 14 00 00 00 00 00	r1 = *(u16 *)(r6 + 20)
     979:	57 01 00 00 1f ff 00 00	r1 &= 65311
; 		if (likely(not_first_fragment))
     980:	15 01 57 00 00 00 00 00	if r1 == 0 goto +87 <LBB13_317>
     981:	bf a2 00 00 00 00 00 00	r2 = r10
     982:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	tmp = map_lookup_elem(&IPV4_FRAG_DATAGRAMS_MAP, frag_id);
     983:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     985:	85 00 00 00 01 00 00 00	call 1
; 	if (!tmp)
     986:	55 00 41 03 00 00 00 00	if r0 != 0 goto +833 <LBB13_290>
     987:	05 00 3c 03 00 00 00 00	goto +828 <LBB13_285>

0000000000001ee0 <LBB13_297>:
; 	return ctx->len;
     988:	61 48 00 00 00 00 00 00	r8 = *(u32 *)(r4 + 0)
; 	struct metrics_value *entry, newEntry = {};
     989:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
     990:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
     991:	b7 01 00 00 09 03 00 00	r1 = 777
; 	struct metrics_key key = {};
     992:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
     993:	bf a2 00 00 00 00 00 00	r2 = r10
     994:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
     995:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
     997:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
     998:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_303>
; 		entry->count += 1;
     999:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1000:	07 01 00 00 01 00 00 00	r1 += 1
    1001:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1002:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1003:	0f 81 00 00 00 00 00 00	r1 += r8
    1004:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1005:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_304>

0000000000001f70 <LBB13_303>:
; 		newEntry.bytes = bytes;
    1006:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    1007:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1008:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1009:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1010:	07 02 00 00 f8 ff ff ff	r2 += -8
    1011:	bf a3 00 00 00 00 00 00	r3 = r10
    1012:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1013:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1015:	b7 04 00 00 00 00 00 00	r4 = 0
    1016:	85 00 00 00 02 00 00 00	call 2

0000000000001fc8 <LBB13_304>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
    1017:	69 61 14 00 00 00 00 00	r1 = *(u16 *)(r6 + 20)
    1018:	57 01 00 00 1f ff 00 00	r1 &= 65311
; 		if (likely(not_first_fragment))
    1019:	15 01 63 00 00 00 00 00	if r1 == 0 goto +99 <LBB13_331>
    1020:	bf a2 00 00 00 00 00 00	r2 = r10
    1021:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	tmp = map_lookup_elem(&IPV4_FRAG_DATAGRAMS_MAP, frag_id);
    1022:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1024:	85 00 00 00 01 00 00 00	call 1
; 	if (!tmp)
    1025:	55 00 3b 05 00 00 00 00	if r0 != 0 goto +1339 <LBB13_307>
    1026:	05 00 37 05 00 00 00 00	goto +1335 <LBB13_302>

0000000000002018 <LBB13_309>:
    1027:	bf a3 00 00 00 00 00 00	r3 = r10
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1028:	07 03 00 00 98 ff ff ff	r3 += -104
    1029:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1030:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1031:	b7 04 00 00 04 00 00 00	r4 = 4
    1032:	85 00 00 00 1a 00 00 00	call 26
    1033:	b7 01 00 00 00 00 00 00	r1 = 0
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1034:	67 00 00 00 20 00 00 00	r0 <<= 32
    1035:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (ret < 0)
    1036:	c5 00 6c fc 00 00 00 00	if r0 s< 0 goto -916 <LBB13_13>
    1037:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (map_update_elem(&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))
    1038:	07 02 00 00 d8 ff ff ff	r2 += -40
    1039:	bf a3 00 00 00 00 00 00	r3 = r10
    1040:	07 03 00 00 98 ff ff ff	r3 += -104
    1041:	b7 08 00 00 00 00 00 00	r8 = 0
    1042:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1044:	b7 04 00 00 00 00 00 00	r4 = 0
    1045:	85 00 00 00 02 00 00 00	call 2
    1046:	67 00 00 00 20 00 00 00	r0 <<= 32
    1047:	77 00 00 00 20 00 00 00	r0 >>= 32
    1048:	15 00 9b fc 00 00 00 00	if r0 == 0 goto -869 <LBB13_23>
; 	return ctx->len;
    1049:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1050:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    1051:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    1052:	7b 8a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r8
    1053:	b7 01 00 00 0a 02 00 00	r1 = 522
; 	struct metrics_key key = {};
    1054:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
    1055:	bf a2 00 00 00 00 00 00	r2 = r10
    1056:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    1057:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1059:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    1060:	15 00 2e 00 00 00 00 00	if r0 == 0 goto +46 <LBB13_321>
; 		entry->count += 1;
    1061:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1062:	07 01 00 00 01 00 00 00	r1 += 1
    1063:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1064:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1065:	0f 61 00 00 00 00 00 00	r1 += r6
    1066:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1067:	05 00 88 fc 00 00 00 00	goto -888 <LBB13_23>

0000000000002160 <LBB13_317>:
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1068:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1069:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1070:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1071:	b7 04 00 00 04 00 00 00	r4 = 4
    1072:	85 00 00 00 1a 00 00 00	call 26
    1073:	67 00 00 00 20 00 00 00	r0 <<= 32
    1074:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1075:	bf 03 00 00 00 00 00 00	r3 = r0
; 	if (ret < 0)
    1076:	c5 00 2b 03 00 00 00 00	if r0 s< 0 goto +811 <LBB13_323>
    1077:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (map_update_elem(&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))
    1078:	07 02 00 00 d8 ff ff ff	r2 += -40
    1079:	b7 08 00 00 00 00 00 00	r8 = 0
    1080:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1082:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1083:	b7 04 00 00 00 00 00 00	r4 = 0
    1084:	85 00 00 00 02 00 00 00	call 2
    1085:	67 00 00 00 20 00 00 00	r0 <<= 32
    1086:	77 00 00 00 20 00 00 00	r0 >>= 32
    1087:	15 00 de 02 00 00 00 00	if r0 == 0 goto +734 <LBB13_291>
; 	return ctx->len;
    1088:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1089:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    1090:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    1091:	7b 8a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r8
    1092:	b7 01 00 00 0a 02 00 00	r1 = 522
; 	struct metrics_key key = {};
    1093:	7b 1a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r1
    1094:	bf a2 00 00 00 00 00 00	r2 = r10
    1095:	07 02 00 00 48 ff ff ff	r2 += -184
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    1096:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1098:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    1099:	15 00 39 00 00 00 00 00	if r0 == 0 goto +57 <LBB13_337>
; 		entry->count += 1;
    1100:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1101:	07 01 00 00 01 00 00 00	r1 += 1
    1102:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1103:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1104:	0f 61 00 00 00 00 00 00	r1 += r6
    1105:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1106:	05 00 cb 02 00 00 00 00	goto +715 <LBB13_291>

0000000000002298 <LBB13_321>:
; 		newEntry.bytes = bytes;
    1107:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    1108:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1109:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1110:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1111:	07 02 00 00 f8 ff ff ff	r2 += -8
    1112:	bf a3 00 00 00 00 00 00	r3 = r10
    1113:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1114:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1116:	b7 04 00 00 00 00 00 00	r4 = 0
    1117:	85 00 00 00 02 00 00 00	call 2
    1118:	05 00 55 fc 00 00 00 00	goto -939 <LBB13_23>

00000000000022f8 <LBB13_331>:
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1119:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1120:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1121:	bf 73 00 00 00 00 00 00	r3 = r7
    1122:	b7 04 00 00 04 00 00 00	r4 = 4
    1123:	85 00 00 00 1a 00 00 00	call 26
    1124:	67 00 00 00 20 00 00 00	r0 <<= 32
    1125:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (ret < 0)
    1126:	c5 00 46 fd 00 00 00 00	if r0 s< 0 goto -698 <LBB13_75>
    1127:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (map_update_elem(&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))
    1128:	07 02 00 00 d8 ff ff ff	r2 += -40
    1129:	b7 09 00 00 00 00 00 00	r9 = 0
    1130:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1132:	bf 73 00 00 00 00 00 00	r3 = r7
    1133:	b7 04 00 00 00 00 00 00	r4 = 0
    1134:	85 00 00 00 02 00 00 00	call 2
    1135:	67 00 00 00 20 00 00 00	r0 <<= 32
    1136:	77 00 00 00 20 00 00 00	r0 >>= 32
    1137:	15 00 cd 04 00 00 00 00	if r0 == 0 goto +1229 <LBB13_308>
; 	return ctx->len;
    1138:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1139:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    1140:	7b 9a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r9
    1141:	7b 9a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r9
    1142:	b7 01 00 00 0a 03 00 00	r1 = 778
; 	struct metrics_key key = {};
    1143:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
    1144:	bf a2 00 00 00 00 00 00	r2 = r10
    1145:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    1146:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1148:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    1149:	15 00 13 00 00 00 00 00	if r0 == 0 goto +19 <LBB13_339>
; 		entry->count += 1;
    1150:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1151:	07 01 00 00 01 00 00 00	r1 += 1
    1152:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1153:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1154:	0f 61 00 00 00 00 00 00	r1 += r6
    1155:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1156:	05 00 ba 04 00 00 00 00	goto +1210 <LBB13_308>

0000000000002428 <LBB13_337>:
; 		newEntry.bytes = bytes;
    1157:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    1158:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1159:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1160:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1161:	07 02 00 00 48 ff ff ff	r2 += -184
    1162:	bf a3 00 00 00 00 00 00	r3 = r10
    1163:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1164:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1166:	b7 04 00 00 00 00 00 00	r4 = 0
    1167:	85 00 00 00 02 00 00 00	call 2
    1168:	05 00 8d 02 00 00 00 00	goto +653 <LBB13_291>

0000000000002488 <LBB13_339>:
; 		newEntry.bytes = bytes;
    1169:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    1170:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1171:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1172:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1173:	07 02 00 00 f8 ff ff ff	r2 += -8
    1174:	bf a3 00 00 00 00 00 00	r3 = r10
    1175:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1176:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1178:	b7 04 00 00 00 00 00 00	r4 = 0
    1179:	85 00 00 00 02 00 00 00	call 2
    1180:	05 00 a2 04 00 00 00 00	goto +1186 <LBB13_308>

00000000000024e8 <LBB13_56>:
    1181:	18 03 00 00 79 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967161 ll
    1183:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
; 	return (void *)(unsigned long)ctx->data_end;
    1184:	61 51 50 00 00 00 00 00	r1 = *(u32 *)(r5 + 80)
; 	return (void *)(unsigned long)ctx->data;
    1185:	61 56 4c 00 00 00 00 00	r6 = *(u32 *)(r5 + 76)
; 	if (data + tot_len > data_end)
    1186:	bf 62 00 00 00 00 00 00	r2 = r6
    1187:	07 02 00 00 22 00 00 00	r2 += 34
    1188:	2d 12 39 fd 00 00 00 00	if r2 > r1 goto -711 <LBB13_86>
    1189:	bf 87 00 00 00 00 00 00	r7 = r8
; 		.daddr = ip4->daddr,
    1190:	61 61 1e 00 00 00 00 00	r1 = *(u32 *)(r6 + 30)
; 	struct ipv4_frag_id frag_id = {
    1191:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 		.saddr = ip4->saddr,
    1192:	61 61 1a 00 00 00 00 00	r1 = *(u32 *)(r6 + 26)
; 	struct ipv4_frag_id frag_id = {
    1193:	63 1a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r1
; 		.id = ip4->id,
    1194:	69 61 12 00 00 00 00 00	r1 = *(u16 *)(r6 + 18)
; 	struct ipv4_frag_id frag_id = {
    1195:	6b 1a e0 ff 00 00 00 00	*(u16 *)(r10 - 32) = r1
    1196:	b7 01 00 00 00 00 00 00	r1 = 0
; 		.proto = ip4->protocol,
    1197:	71 62 17 00 00 00 00 00	r2 = *(u8 *)(r6 + 23)
; 	struct ipv4_frag_id frag_id = {
    1198:	73 1a e3 ff 00 00 00 00	*(u8 *)(r10 - 29) = r1
    1199:	73 2a e2 ff 00 00 00 00	*(u8 *)(r10 - 30) = r2
; 				    (struct ipv4_frag_l4ports *)&tuple->dport,
    1200:	bf a3 00 00 00 00 00 00	r3 = r10
    1201:	07 03 00 00 88 ff ff ff	r3 += -120
; 	return ip4->frag_off & bpf_htons(0x3FFF);
    1202:	69 62 14 00 00 00 00 00	r2 = *(u16 *)(r6 + 20)
    1203:	57 02 00 00 3f ff 00 00	r2 &= 65343
; 	if (unlikely(is_fragment)) {
    1204:	55 02 3b 02 00 00 00 00	if r2 != 0 goto +571 <LBB13_278>
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1205:	bf 51 00 00 00 00 00 00	r1 = r5
    1206:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1207:	b7 04 00 00 04 00 00 00	r4 = 4
    1208:	bf 56 00 00 00 00 00 00	r6 = r5
    1209:	85 00 00 00 1a 00 00 00	call 26
    1210:	bf 65 00 00 00 00 00 00	r5 = r6
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1211:	67 00 00 00 20 00 00 00	r0 <<= 32
    1212:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1213:	bf 03 00 00 00 00 00 00	r3 = r0
; 		if (err < 0)
    1214:	c5 00 1f fd 00 00 00 00	if r0 s< 0 goto -737 <LBB13_86>

00000000000025f8 <LBB13_59>:
; 			if (ctx_load_bytes(ctx, off + 12, &tcp_flags, 2) < 0)
    1215:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1216:	07 02 00 00 0c 00 00 00	r2 += 12
    1217:	bf a3 00 00 00 00 00 00	r3 = r10
    1218:	07 03 00 00 f8 ff ff ff	r3 += -8
    1219:	bf 51 00 00 00 00 00 00	r1 = r5
    1220:	b7 04 00 00 02 00 00 00	r4 = 2
    1221:	85 00 00 00 1a 00 00 00	call 26
    1222:	67 00 00 00 20 00 00 00	r0 <<= 32
    1223:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1224:	18 03 00 00 79 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967161 ll
    1226:	c5 00 13 fd 00 00 00 00	if r0 s< 0 goto -749 <LBB13_86>
; 			if (unlikely(tcp_flags.value & (TCP_FLAG_RST|TCP_FLAG_FIN)))
    1227:	61 a1 f8 ff 00 00 00 00	r1 = *(u32 *)(r10 - 8)
    1228:	57 01 00 00 00 05 00 00	r1 &= 1280
    1229:	b7 06 00 00 01 00 00 00	r6 = 1
    1230:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_94>
    1231:	b7 06 00 00 02 00 00 00	r6 = 2

0000000000002680 <LBB13_94>:
    1232:	7b 7a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r7
    1233:	71 a1 f9 ff 00 00 00 00	r1 = *(u8 *)(r10 - 7)
;        volatile int __maybe_unused id = get_smp_processor_id();
    1234:	7b 1a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r1
    1235:	85 00 00 00 08 00 00 00	call 8
    1236:	63 0a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r0
    1237:	bf a2 00 00 00 00 00 00	r2 = r10
    1238:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    1239:	bf 91 00 00 00 00 00 00	r1 = r9
    1240:	85 00 00 00 01 00 00 00	call 1
    1241:	bf 08 00 00 00 00 00 00	r8 = r0
; 	if (entry) {
    1242:	15 08 7e 00 00 00 00 00	if r8 == 0 goto +126 <LBB13_111>
    1243:	b7 05 00 00 00 00 00 00	r5 = 0
; 	return !entry->rx_closing || !entry->tx_closing;
    1244:	69 81 24 00 00 00 00 00	r1 = *(u16 *)(r8 + 36)
    1245:	bf 12 00 00 00 00 00 00	r2 = r1
    1246:	57 02 00 00 03 00 00 00	r2 &= 3
    1247:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
; 		if (ct_entry_alive(entry))
    1248:	15 02 28 00 03 00 00 00	if r2 == 3 goto +40 <LBB13_102>
    1249:	bf 97 00 00 00 00 00 00	r7 = r9
    1250:	b7 09 00 00 3c 00 00 00	r9 = 60
; 	if (tcp) {
    1251:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    1252:	55 02 0d 00 06 00 00 00	if r2 != 6 goto +13 <LBB13_99>
    1253:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1254:	67 02 00 00 03 00 00 00	r2 <<= 3
    1255:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    1256:	bf 13 00 00 00 00 00 00	r3 = r1
    1257:	4f 23 00 00 00 00 00 00	r3 |= r2
    1258:	57 03 00 00 10 00 00 00	r3 &= 16
    1259:	57 01 00 00 ef ff 00 00	r1 &= 65519
    1260:	bf 32 00 00 00 00 00 00	r2 = r3
    1261:	4f 12 00 00 00 00 00 00	r2 |= r1
    1262:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1263:	b7 09 00 00 3c 00 00 00	r9 = 60
    1264:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_99>
    1265:	b7 09 00 00 60 54 00 00	r9 = 21600

0000000000002790 <LBB13_99>:
; 	__u32 now = bpf_mono_now();
    1266:	85 00 00 00 05 00 00 00	call 5
    1267:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1268:	0f 09 00 00 00 00 00 00	r9 += r0
    1269:	63 98 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r9
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1270:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1271:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1272:	79 a4 e0 fe 00 00 00 00	r4 = *(u64 *)(r10 - 288)
    1273:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    1274:	bf 31 00 00 00 00 00 00	r1 = r3
    1275:	4f 41 00 00 00 00 00 00	r1 |= r4
    1276:	bf 79 00 00 00 00 00 00	r9 = r7
    1277:	b7 05 00 00 00 00 00 00	r5 = 0
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1278:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_101>
    1279:	07 02 00 00 05 00 00 00	r2 += 5
    1280:	bf 03 00 00 00 00 00 00	r3 = r0
    1281:	67 03 00 00 20 00 00 00	r3 <<= 32
    1282:	77 03 00 00 20 00 00 00	r3 >>= 32
    1283:	67 02 00 00 20 00 00 00	r2 <<= 32
    1284:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1285:	3d 32 03 00 00 00 00 00	if r2 >= r3 goto +3 <LBB13_102>

0000000000002830 <LBB13_101>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1286:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1287:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0
    1288:	b7 05 00 00 80 00 00 00	r5 = 128

0000000000002848 <LBB13_102>:
; 			ct_state->rev_nat_index = entry->rev_nat_index;
    1289:	69 81 26 00 00 00 00 00	r1 = *(u16 *)(r8 + 38)
    1290:	6b 1a 60 ff 00 00 00 00	*(u16 *)(r10 - 160) = r1
; 			ct_state->loopback = entry->lb_loopback;
    1291:	69 81 24 00 00 00 00 00	r1 = *(u16 *)(r8 + 36)
; 			ct_state->ifindex = entry->ifindex;
    1292:	69 82 28 00 00 00 00 00	r2 = *(u16 *)(r8 + 40)
    1293:	6b 2a 70 ff 00 00 00 00	*(u16 *)(r10 - 144) = r2
; 			ct_state->loopback = entry->lb_loopback;
    1294:	69 a2 62 ff 00 00 00 00	r2 = *(u16 *)(r10 - 158)
    1295:	57 02 00 00 f0 ff 00 00	r2 &= 65520
    1296:	bf 13 00 00 00 00 00 00	r3 = r1
    1297:	77 03 00 00 03 00 00 00	r3 >>= 3
    1298:	57 03 00 00 01 00 00 00	r3 &= 1
    1299:	4f 32 00 00 00 00 00 00	r2 |= r3
; 			ct_state->node_port = entry->node_port;
    1300:	77 01 00 00 04 00 00 00	r1 >>= 4
    1301:	bf 13 00 00 00 00 00 00	r3 = r1
    1302:	57 03 00 00 02 00 00 00	r3 &= 2
    1303:	4f 32 00 00 00 00 00 00	r2 |= r3
; 			ct_state->dsr = entry->dsr;
    1304:	57 01 00 00 0c 00 00 00	r1 &= 12
; 			ct_state->proxy_redirect = entry->proxy_redirect;
    1305:	4f 12 00 00 00 00 00 00	r2 |= r1
    1306:	6b 2a 62 ff 00 00 00 00	*(u16 *)(r10 - 158) = r2
    1307:	b7 01 00 00 01 00 00 00	r1 = 1
; 			__sync_fetch_and_add(&entry->tx_packets, 1);
    1308:	db 18 10 00 00 00 00 00	lock *(u64 *)(r8 + 16) += r1
    1309:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    1310:	61 41 00 00 00 00 00 00	r1 = *(u32 *)(r4 + 0)
; 			__sync_fetch_and_add(&entry->tx_bytes, ctx_full_len(ctx));
    1311:	db 18 18 00 00 00 00 00	lock *(u64 *)(r8 + 24) += r1
; 		switch (action) {
    1312:	67 06 00 00 20 00 00 00	r6 <<= 32
    1313:	77 06 00 00 20 00 00 00	r6 >>= 32
    1314:	15 06 d0 00 02 00 00 00	if r6 == 2 goto +208 <LBB13_128>
    1315:	55 06 f1 00 01 00 00 00	if r6 != 1 goto +241 <LBB13_134>
; 			reopen = entry->rx_closing | entry->tx_closing;
    1316:	69 81 24 00 00 00 00 00	r1 = *(u16 *)(r8 + 36)
    1317:	bf 12 00 00 00 00 00 00	r2 = r1
    1318:	77 02 00 00 01 00 00 00	r2 >>= 1
    1319:	4f 12 00 00 00 00 00 00	r2 |= r1
    1320:	57 02 00 00 01 00 00 00	r2 &= 1
; 			reopen |= seen_flags.value & TCP_FLAG_SYN;
    1321:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1322:	67 03 00 00 08 00 00 00	r3 <<= 8
    1323:	57 03 00 00 00 02 00 00	r3 &= 512
    1324:	4f 23 00 00 00 00 00 00	r3 |= r2
; 			if (unlikely(reopen == (TCP_FLAG_SYN|0x1))) {
    1325:	55 03 e7 00 01 02 00 00	if r3 != 513 goto +231 <LBB13_134>
; 	entry->tx_closing = 0;
    1326:	bf 12 00 00 00 00 00 00	r2 = r1
    1327:	57 02 00 00 fc ff 00 00	r2 &= 65532
    1328:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1329:	b7 06 00 00 3c 00 00 00	r6 = 60
; 	if (tcp) {
    1330:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    1331:	55 02 0d 00 06 00 00 00	if r2 != 6 goto +13 <LBB13_108>
    1332:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1333:	67 02 00 00 03 00 00 00	r2 <<= 3
    1334:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    1335:	bf 13 00 00 00 00 00 00	r3 = r1
    1336:	4f 23 00 00 00 00 00 00	r3 |= r2
    1337:	57 03 00 00 10 00 00 00	r3 &= 16
    1338:	57 01 00 00 ec ff 00 00	r1 &= 65516
    1339:	bf 32 00 00 00 00 00 00	r2 = r3
    1340:	4f 12 00 00 00 00 00 00	r2 |= r1
    1341:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1342:	b7 06 00 00 3c 00 00 00	r6 = 60
    1343:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_108>
    1344:	b7 06 00 00 60 54 00 00	r6 = 21600

0000000000002a08 <LBB13_108>:
; 	__u32 now = bpf_mono_now();
    1345:	85 00 00 00 05 00 00 00	call 5
    1346:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1347:	0f 06 00 00 00 00 00 00	r6 += r0
    1348:	63 68 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r6
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1349:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1350:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
    1351:	79 a4 e0 fe 00 00 00 00	r4 = *(u64 *)(r10 - 288)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1352:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    1353:	bf 31 00 00 00 00 00 00	r1 = r3
    1354:	4f 41 00 00 00 00 00 00	r1 |= r4
    1355:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1356:	5d 13 08 00 00 00 00 00	if r3 != r1 goto +8 <LBB13_110>
    1357:	b7 05 00 00 00 00 00 00	r5 = 0
    1358:	07 02 00 00 05 00 00 00	r2 += 5
    1359:	bf 03 00 00 00 00 00 00	r3 = r0
    1360:	67 03 00 00 20 00 00 00	r3 <<= 32
    1361:	77 03 00 00 20 00 00 00	r3 >>= 32
    1362:	67 02 00 00 20 00 00 00	r2 <<= 32
    1363:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1364:	3d 32 c0 00 00 00 00 00	if r2 >= r3 goto +192 <LBB13_134>

0000000000002aa8 <LBB13_110>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1365:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1366:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0
    1367:	b7 05 00 00 80 00 00 00	r5 = 128
; 	barrier();
    1368:	05 00 bc 00 00 00 00 00	goto +188 <LBB13_134>

0000000000002ac8 <LBB13_111>:
;        volatile int __maybe_unused id = get_smp_processor_id();
    1369:	85 00 00 00 08 00 00 00	call 8
    1370:	63 0a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r0
; 	__be32 tmp_addr = tuple->saddr;
    1371:	61 a1 84 ff 00 00 00 00	r1 = *(u32 *)(r10 - 124)
; 	tuple->saddr = tuple->daddr;
    1372:	61 a2 80 ff 00 00 00 00	r2 = *(u32 *)(r10 - 128)
    1373:	63 2a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r2
; 	tuple->daddr = tmp_addr;
    1374:	63 1a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r1
; 	tmp = tuple->sport;
    1375:	69 a1 8a ff 00 00 00 00	r1 = *(u16 *)(r10 - 118)
; 	tuple->sport = tuple->dport;
    1376:	69 a2 88 ff 00 00 00 00	r2 = *(u16 *)(r10 - 120)
    1377:	6b 2a 8a ff 00 00 00 00	*(u16 *)(r10 - 118) = r2
; 	tuple->dport = tmp;
    1378:	6b 1a 88 ff 00 00 00 00	*(u16 *)(r10 - 120) = r1
; 	if (tuple->flags & TUPLE_F_IN)
    1379:	71 a1 8d ff 00 00 00 00	r1 = *(u8 *)(r10 - 115)
    1380:	a7 01 00 00 01 00 00 00	r1 ^= 1
    1381:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
    1382:	71 a1 f9 ff 00 00 00 00	r1 = *(u8 *)(r10 - 7)
;        volatile int __maybe_unused id = get_smp_processor_id();
    1383:	7b 1a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r1
    1384:	85 00 00 00 08 00 00 00	call 8
    1385:	63 0a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r0
    1386:	bf a2 00 00 00 00 00 00	r2 = r10
    1387:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    1388:	bf 91 00 00 00 00 00 00	r1 = r9
    1389:	85 00 00 00 01 00 00 00	call 1
    1390:	bf 08 00 00 00 00 00 00	r8 = r0
    1391:	b7 07 00 00 00 00 00 00	r7 = 0
    1392:	b7 05 00 00 80 00 00 00	r5 = 128
    1393:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    1394:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
; 	if (entry) {
    1395:	15 08 a6 00 00 00 00 00	if r8 == 0 goto +166 <LBB13_136>
; 	return !entry->rx_closing || !entry->tx_closing;
    1396:	69 81 24 00 00 00 00 00	r1 = *(u16 *)(r8 + 36)
    1397:	bf 12 00 00 00 00 00 00	r2 = r1
    1398:	57 02 00 00 03 00 00 00	r2 &= 3
    1399:	b7 05 00 00 80 00 00 00	r5 = 128
; 		if (ct_entry_alive(entry))
    1400:	15 02 29 00 03 00 00 00	if r2 == 3 goto +41 <LBB13_119>
    1401:	bf 97 00 00 00 00 00 00	r7 = r9
    1402:	b7 09 00 00 3c 00 00 00	r9 = 60
; 	if (tcp) {
    1403:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    1404:	55 02 0d 00 06 00 00 00	if r2 != 6 goto +13 <LBB13_116>
    1405:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1406:	67 02 00 00 03 00 00 00	r2 <<= 3
    1407:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    1408:	bf 13 00 00 00 00 00 00	r3 = r1
    1409:	4f 23 00 00 00 00 00 00	r3 |= r2
    1410:	57 03 00 00 10 00 00 00	r3 &= 16
    1411:	57 01 00 00 ef ff 00 00	r1 &= 65519
    1412:	bf 32 00 00 00 00 00 00	r2 = r3
    1413:	4f 12 00 00 00 00 00 00	r2 |= r1
    1414:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1415:	b7 09 00 00 3c 00 00 00	r9 = 60
    1416:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_116>
    1417:	b7 09 00 00 60 54 00 00	r9 = 21600

0000000000002c50 <LBB13_116>:
; 	__u32 now = bpf_mono_now();
    1418:	85 00 00 00 05 00 00 00	call 5
    1419:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1420:	0f 09 00 00 00 00 00 00	r9 += r0
    1421:	63 98 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r9
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1422:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1423:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1424:	79 a4 e0 fe 00 00 00 00	r4 = *(u64 *)(r10 - 288)
    1425:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    1426:	bf 31 00 00 00 00 00 00	r1 = r3
    1427:	4f 41 00 00 00 00 00 00	r1 |= r4
    1428:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    1429:	bf 79 00 00 00 00 00 00	r9 = r7
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1430:	5d 13 08 00 00 00 00 00	if r3 != r1 goto +8 <LBB13_118>
    1431:	b7 05 00 00 00 00 00 00	r5 = 0
    1432:	07 02 00 00 05 00 00 00	r2 += 5
    1433:	bf 03 00 00 00 00 00 00	r3 = r0
    1434:	67 03 00 00 20 00 00 00	r3 <<= 32
    1435:	77 03 00 00 20 00 00 00	r3 >>= 32
    1436:	67 02 00 00 20 00 00 00	r2 <<= 32
    1437:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1438:	3d 32 03 00 00 00 00 00	if r2 >= r3 goto +3 <LBB13_119>

0000000000002cf8 <LBB13_118>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1439:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1440:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0
    1441:	b7 05 00 00 80 00 00 00	r5 = 128

0000000000002d10 <LBB13_119>:
; 			ct_state->rev_nat_index = entry->rev_nat_index;
    1442:	69 81 26 00 00 00 00 00	r1 = *(u16 *)(r8 + 38)
    1443:	6b 1a 60 ff 00 00 00 00	*(u16 *)(r10 - 160) = r1
; 			ct_state->loopback = entry->lb_loopback;
    1444:	69 a1 62 ff 00 00 00 00	r1 = *(u16 *)(r10 - 158)
    1445:	57 01 00 00 f0 ff 00 00	r1 &= 65520
    1446:	69 82 24 00 00 00 00 00	r2 = *(u16 *)(r8 + 36)
    1447:	bf 23 00 00 00 00 00 00	r3 = r2
    1448:	77 03 00 00 03 00 00 00	r3 >>= 3
    1449:	57 03 00 00 01 00 00 00	r3 &= 1
    1450:	4f 31 00 00 00 00 00 00	r1 |= r3
; 			ct_state->ifindex = entry->ifindex;
    1451:	69 83 28 00 00 00 00 00	r3 = *(u16 *)(r8 + 40)
    1452:	6b 3a 70 ff 00 00 00 00	*(u16 *)(r10 - 144) = r3
; 			ct_state->node_port = entry->node_port;
    1453:	77 02 00 00 04 00 00 00	r2 >>= 4
    1454:	bf 23 00 00 00 00 00 00	r3 = r2
    1455:	57 03 00 00 02 00 00 00	r3 &= 2
    1456:	4f 31 00 00 00 00 00 00	r1 |= r3
; 			ct_state->dsr = entry->dsr;
    1457:	57 02 00 00 0c 00 00 00	r2 &= 12
; 			ct_state->proxy_redirect = entry->proxy_redirect;
    1458:	4f 21 00 00 00 00 00 00	r1 |= r2
    1459:	6b 1a 62 ff 00 00 00 00	*(u16 *)(r10 - 158) = r1
    1460:	b7 07 00 00 01 00 00 00	r7 = 1
; 			__sync_fetch_and_add(&entry->tx_packets, 1);
    1461:	b7 01 00 00 01 00 00 00	r1 = 1
    1462:	db 18 10 00 00 00 00 00	lock *(u64 *)(r8 + 16) += r1
; 	return ctx->len;
    1463:	61 41 00 00 00 00 00 00	r1 = *(u32 *)(r4 + 0)
; 			__sync_fetch_and_add(&entry->tx_bytes, ctx_full_len(ctx));
    1464:	db 18 18 00 00 00 00 00	lock *(u64 *)(r8 + 24) += r1
; 		switch (action) {
    1465:	67 06 00 00 20 00 00 00	r6 <<= 32
    1466:	77 06 00 00 20 00 00 00	r6 >>= 32
    1467:	15 06 0e 01 02 00 00 00	if r6 == 2 goto +270 <LBB13_167>
    1468:	55 06 5d 00 01 00 00 00	if r6 != 1 goto +93 <LBB13_136>
; 			reopen = entry->rx_closing | entry->tx_closing;
    1469:	69 81 24 00 00 00 00 00	r1 = *(u16 *)(r8 + 36)
    1470:	bf 12 00 00 00 00 00 00	r2 = r1
    1471:	77 02 00 00 01 00 00 00	r2 >>= 1
    1472:	4f 12 00 00 00 00 00 00	r2 |= r1
    1473:	57 02 00 00 01 00 00 00	r2 &= 1
; 			reopen |= seen_flags.value & TCP_FLAG_SYN;
    1474:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1475:	67 03 00 00 08 00 00 00	r3 <<= 8
    1476:	57 03 00 00 00 02 00 00	r3 &= 512
    1477:	4f 23 00 00 00 00 00 00	r3 |= r2
; 			if (unlikely(reopen == (TCP_FLAG_SYN|0x1))) {
    1478:	55 03 53 00 01 02 00 00	if r3 != 513 goto +83 <LBB13_136>
; 	entry->tx_closing = 0;
    1479:	bf 12 00 00 00 00 00 00	r2 = r1
    1480:	57 02 00 00 fc ff 00 00	r2 &= 65532
    1481:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1482:	b7 06 00 00 3c 00 00 00	r6 = 60
; 	if (tcp) {
    1483:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    1484:	55 02 0d 00 06 00 00 00	if r2 != 6 goto +13 <LBB13_125>
    1485:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1486:	67 02 00 00 03 00 00 00	r2 <<= 3
    1487:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    1488:	bf 13 00 00 00 00 00 00	r3 = r1
    1489:	4f 23 00 00 00 00 00 00	r3 |= r2
    1490:	57 03 00 00 10 00 00 00	r3 &= 16
    1491:	57 01 00 00 ec ff 00 00	r1 &= 65516
    1492:	bf 32 00 00 00 00 00 00	r2 = r3
    1493:	4f 12 00 00 00 00 00 00	r2 |= r1
    1494:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1495:	b7 06 00 00 3c 00 00 00	r6 = 60
    1496:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_125>
    1497:	b7 06 00 00 60 54 00 00	r6 = 21600

0000000000002ed0 <LBB13_125>:
; 	__u32 now = bpf_mono_now();
    1498:	85 00 00 00 05 00 00 00	call 5
    1499:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1500:	0f 06 00 00 00 00 00 00	r6 += r0
    1501:	63 68 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r6
    1502:	b7 07 00 00 04 00 00 00	r7 = 4
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1503:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1504:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
    1505:	79 a4 e0 fe 00 00 00 00	r4 = *(u64 *)(r10 - 288)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1506:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    1507:	bf 31 00 00 00 00 00 00	r1 = r3
    1508:	4f 41 00 00 00 00 00 00	r1 |= r4
    1509:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1510:	5d 13 08 00 00 00 00 00	if r3 != r1 goto +8 <LBB13_127>
    1511:	b7 05 00 00 00 00 00 00	r5 = 0
    1512:	07 02 00 00 05 00 00 00	r2 += 5
    1513:	bf 03 00 00 00 00 00 00	r3 = r0
    1514:	67 03 00 00 20 00 00 00	r3 <<= 32
    1515:	77 03 00 00 20 00 00 00	r3 >>= 32
    1516:	67 02 00 00 20 00 00 00	r2 <<= 32
    1517:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1518:	3d 32 2b 00 00 00 00 00	if r2 >= r3 goto +43 <LBB13_136>

0000000000002f78 <LBB13_127>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1519:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1520:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0
    1521:	b7 05 00 00 80 00 00 00	r5 = 128
; 	barrier();
    1522:	05 00 27 00 00 00 00 00	goto +39 <LBB13_136>

0000000000002f98 <LBB13_128>:
; 			    (seen_flags.value & TCP_FLAG_RST) &&
    1523:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1524:	57 02 00 00 04 00 00 00	r2 &= 4
    1525:	b7 01 00 00 02 00 00 00	r1 = 2
    1526:	15 02 01 00 00 00 00 00	if r2 == 0 goto +1 <LBB13_130>
    1527:	b7 01 00 00 03 00 00 00	r1 = 3

0000000000002fc0 <LBB13_130>:
    1528:	69 82 24 00 00 00 00 00	r2 = *(u16 *)(r8 + 36)
; 			    (seen_flags.value & TCP_FLAG_RST) &&
    1529:	4f 12 00 00 00 00 00 00	r2 |= r1
    1530:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1531:	b7 05 00 00 80 00 00 00	r5 = 128
; 	return !entry->rx_closing || !entry->tx_closing;
    1532:	57 02 00 00 03 00 00 00	r2 &= 3
; 			if (ct_entry_alive(entry))
    1533:	55 02 17 00 03 00 00 00	if r2 != 3 goto +23 <LBB13_134>
; 	__u32 now = bpf_mono_now();
    1534:	85 00 00 00 05 00 00 00	call 5
    1535:	b7 05 00 00 80 00 00 00	r5 = 128
    1536:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	__u32 now = bpf_mono_now();
    1537:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1538:	bf 01 00 00 00 00 00 00	r1 = r0
    1539:	07 01 00 00 0a 00 00 00	r1 += 10
    1540:	63 18 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r1
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1541:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1542:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
    1543:	79 a6 e0 fe 00 00 00 00	r6 = *(u64 *)(r10 - 288)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1544:	57 06 00 00 02 00 00 00	r6 &= 2
; 	seen_flags |= accumulated_flags;
    1545:	bf 31 00 00 00 00 00 00	r1 = r3
    1546:	4f 61 00 00 00 00 00 00	r1 |= r6
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1547:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_133>
    1548:	07 02 00 00 05 00 00 00	r2 += 5
    1549:	bf 03 00 00 00 00 00 00	r3 = r0
    1550:	67 03 00 00 20 00 00 00	r3 <<= 32
    1551:	77 03 00 00 20 00 00 00	r3 >>= 32
    1552:	67 02 00 00 20 00 00 00	r2 <<= 32
    1553:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1554:	3d 32 02 00 00 00 00 00	if r2 >= r3 goto +2 <LBB13_134>

0000000000003098 <LBB13_133>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1555:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1556:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0

00000000000030a8 <LBB13_134>:
; 			if (unlikely(tuple->flags & TUPLE_F_RELATED))
    1557:	71 a1 8d ff 00 00 00 00	r1 = *(u8 *)(r10 - 115)
    1558:	57 01 00 00 02 00 00 00	r1 &= 2
    1559:	b7 07 00 00 02 00 00 00	r7 = 2
    1560:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_136>
    1561:	b7 07 00 00 03 00 00 00	r7 = 3

00000000000030d0 <LBB13_136>:
    1562:	b7 02 00 00 dc 05 00 00	r2 = 1500
; 	if (conn_is_dns(tuple->dport))
    1563:	69 a1 88 ff 00 00 00 00	r1 = *(u16 *)(r10 - 120)
    1564:	15 01 01 00 00 35 00 00	if r1 == 13568 goto +1 <LBB13_138>
    1565:	bf 52 00 00 00 00 00 00	r2 = r5

00000000000030f0 <LBB13_138>:
    1566:	7b 7a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r7
; 	if ((ret == CT_REPLY || ret == CT_RELATED) && ct_state.proxy_redirect) {
    1567:	57 07 00 00 06 00 00 00	r7 &= 6
    1568:	15 07 01 00 02 00 00 00	if r7 == 2 goto +1 <LBB13_139>
    1569:	05 00 0c 00 00 00 00 00	goto +12 <LBB13_143>

0000000000003110 <LBB13_139>:
    1570:	69 a1 62 ff 00 00 00 00	r1 = *(u16 *)(r10 - 158)
    1571:	57 01 00 00 04 00 00 00	r1 &= 4
    1572:	15 01 09 00 00 00 00 00	if r1 == 0 goto +9 <LBB13_143>
    1573:	b7 01 00 00 00 02 00 00	r1 = 512
; 		ctx->mark = MARK_MAGIC_TO_PROXY | proxy_port << 16;
    1574:	63 14 08 00 00 00 00 00	*(u32 *)(r4 + 8) = r1
; 	ctx_change_type(ctx, PACKET_HOST); /* Required for ingress packets from overlay */
    1575:	bf 41 00 00 00 00 00 00	r1 = r4
    1576:	b7 02 00 00 00 00 00 00	r2 = 0
    1577:	85 00 00 00 20 00 00 00	call 32
    1578:	b7 05 00 00 00 00 00 00	r5 = 0

0000000000003158 <LBB13_141>:
    1579:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)

0000000000003160 <LBB13_142>:
    1580:	b7 08 00 00 00 00 00 00	r8 = 0
    1581:	05 00 b2 fb 00 00 00 00	goto -1102 <LBB13_87>

0000000000003170 <LBB13_143>:
    1582:	7b 2a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r2
; 		.ip4 = addr,
    1583:	63 9a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r9
    1584:	18 01 00 00 40 00 00 00 00 00 00 00 00 00 00 01	r1 = 72057594037928000 ll
; 		.lpm_key = { IPCACHE_PREFIX_LEN(prefix), {} },
    1586:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1587:	b7 06 00 00 00 00 00 00	r6 = 0
; 		.ip4 = addr,
    1588:	7b 6a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r6
    1589:	63 6a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r6
    1590:	bf a2 00 00 00 00 00 00	r2 = r10
    1591:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(map, &key);
    1592:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1594:	85 00 00 00 01 00 00 00	call 1
    1595:	b7 05 00 00 02 00 00 00	r5 = 2
    1596:	b7 09 00 00 00 00 00 00	r9 = 0
; 		if (info != NULL && info->sec_label) {
    1597:	15 00 0c 00 00 00 00 00	if r0 == 0 goto +12 <LBB13_146>
    1598:	61 08 00 00 00 00 00 00	r8 = *(u32 *)(r0 + 0)
    1599:	b7 09 00 00 00 00 00 00	r9 = 0
; 		if (info != NULL && info->sec_label) {
    1600:	15 08 09 00 00 00 00 00	if r8 == 0 goto +9 <LBB13_146>
; 			tunnel_endpoint = info->tunnel_endpoint;
    1601:	61 09 04 00 00 00 00 00	r9 = *(u32 *)(r0 + 4)
    1602:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct encrypt_key key = {.ctx = ctx};
    1603:	63 1a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r1
    1604:	bf a2 00 00 00 00 00 00	r2 = r10
; 			tunnel_endpoint = info->tunnel_endpoint;
    1605:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	cfg = map_lookup_elem(&ENCRYPT_MAP, &key);
    1606:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1608:	85 00 00 00 01 00 00 00	call 1
    1609:	bf 85 00 00 00 00 00 00	r5 = r8

0000000000003250 <LBB13_146>:
    1610:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
; 	if (hairpin_flow)
    1611:	bf 41 00 00 00 00 00 00	r1 = r4
    1612:	57 01 00 00 01 00 00 00	r1 &= 1
    1613:	b7 00 00 00 00 00 00 00	r0 = 0
    1614:	79 a2 40 ff 00 00 00 00	r2 = *(u64 *)(r10 - 192)
    1615:	7b 5a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r5
; 	if (hairpin_flow)
    1616:	55 01 5c 03 00 00 00 00	if r1 != 0 goto +860 <LBB13_344>
; 	return policy_can_egress(ctx, srcID, dstID, tuple->dport,
    1617:	69 a2 88 ff 00 00 00 00	r2 = *(u16 *)(r10 - 120)
; 				 tuple->nexthdr, match_type, audited);
    1618:	71 a1 8c ff 00 00 00 00	r1 = *(u8 *)(r10 - 116)
; 	if (srcID != HOST_ID && is_encap(dport, proto))
    1619:	55 01 0b 00 11 00 00 00	if r1 != 17 goto +11 <LBB13_152>
    1620:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
    1622:	67 03 00 00 20 00 00 00	r3 <<= 32
    1623:	77 03 00 00 20 00 00 00	r3 >>= 32
; 	if (srcID != HOST_ID && is_encap(dport, proto))
    1624:	15 03 06 00 01 00 00 00	if r3 == 1 goto +6 <LBB13_152>
    1625:	18 00 00 00 56 ff ff ff 00 00 00 00 00 00 00 00	r0 = 4294967126 ll
    1627:	b7 06 00 00 00 00 00 00	r6 = 0
; 		(dport == bpf_htons(PORT_UDP_VXLAN) ||
    1628:	15 02 39 00 21 18 00 00	if r2 == 6177 goto +57 <LBB13_161>
    1629:	15 02 38 00 12 b5 00 00	if r2 == 46354 goto +56 <LBB13_161>
    1630:	15 02 37 00 17 c1 00 00	if r2 == 49431 goto +55 <LBB13_161>

00000000000032f8 <LBB13_152>:
    1631:	b7 03 00 00 01 00 00 00	r3 = 1
; 	struct policy_key key = {
    1632:	73 3a a7 ff 00 00 00 00	*(u8 *)(r10 - 89) = r3
    1633:	6b 2a a4 ff 00 00 00 00	*(u16 *)(r10 - 92) = r2
    1634:	63 5a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r5
    1635:	73 1a a6 ff 00 00 00 00	*(u8 *)(r10 - 90) = r1
; 	if (proto == IPPROTO_ICMP) {
    1636:	55 01 19 00 01 00 00 00	if r1 != 1 goto +25 <LBB13_157>
    1637:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return (void *)(unsigned long)ctx->data_end;
    1638:	61 12 50 00 00 00 00 00	r2 = *(u32 *)(r1 + 80)
; 	return (void *)(unsigned long)ctx->data;
    1639:	61 11 4c 00 00 00 00 00	r1 = *(u32 *)(r1 + 76)
; 	if (data + tot_len > data_end)
    1640:	bf 13 00 00 00 00 00 00	r3 = r1
    1641:	07 03 00 00 22 00 00 00	r3 += 34
    1642:	2d 23 28 00 00 00 00 00	if r3 > r2 goto +40 <LBB13_160>
; 	return ip4->ihl * 4;
    1643:	71 12 0e 00 00 00 00 00	r2 = *(u8 *)(r1 + 14)
    1644:	67 02 00 00 02 00 00 00	r2 <<= 2
    1645:	57 02 00 00 3c 00 00 00	r2 &= 60
; 		off = ((void *)ip4 - data) + ipv4_hdrlen(ip4);
    1646:	07 02 00 00 0e 00 00 00	r2 += 14
    1647:	bf a3 00 00 00 00 00 00	r3 = r10
    1648:	07 03 00 00 d8 ff ff ff	r3 += -40
; 		if (ctx_load_bytes(ctx, off, &icmphdr, sizeof(icmphdr)) < 0)
    1649:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1650:	b7 04 00 00 08 00 00 00	r4 = 8
    1651:	85 00 00 00 1a 00 00 00	call 26
    1652:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    1653:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    1654:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 		if (ctx_load_bytes(ctx, off, &icmphdr, sizeof(icmphdr)) < 0)
    1655:	67 00 00 00 20 00 00 00	r0 <<= 32
    1656:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1657:	c5 00 19 00 00 00 00 00	if r0 s< 0 goto +25 <LBB13_160>
; 		if (icmphdr.type == ICMP_DEST_UNREACH &&
    1658:	71 a1 d8 ff 00 00 00 00	r1 = *(u8 *)(r10 - 40)
    1659:	55 01 02 00 03 00 00 00	if r1 != 3 goto +2 <LBB13_157>
; 		    icmphdr.code == ICMP_FRAG_NEEDED)
    1660:	71 a1 d9 ff 00 00 00 00	r1 = *(u8 *)(r10 - 39)
; 		if (icmphdr.type == ICMP_DEST_UNREACH &&
    1661:	15 01 6f 00 04 00 00 00	if r1 == 4 goto +111 <LBB13_274>

00000000000033f0 <LBB13_157>:
    1662:	bf a2 00 00 00 00 00 00	r2 = r10
; 		policy = map_lookup_elem(map, &key);
    1663:	07 02 00 00 a0 ff ff ff	r2 += -96
    1664:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1666:	85 00 00 00 01 00 00 00	call 1
; 		if (likely(policy)) {
    1667:	15 00 9e 00 00 00 00 00	if r0 == 0 goto +158 <LBB13_292>
    1668:	b7 01 00 00 01 00 00 00	r1 = 1
; 	__sync_fetch_and_add(&policy->packets, 1);
    1669:	db 10 08 00 00 00 00 00	lock *(u64 *)(r0 + 8) += r1
    1670:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    1671:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
; 	__sync_fetch_and_add(&policy->bytes, ctx_full_len(ctx));
    1672:	db 10 10 00 00 00 00 00	lock *(u64 *)(r0 + 16) += r1
    1673:	18 01 00 00 4b ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967115 ll
    1675:	b7 06 00 00 02 00 00 00	r6 = 2
; 			if (unlikely(policy->deny))
    1676:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    1677:	57 02 00 00 01 00 00 00	r2 &= 1
    1678:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    1679:	55 02 fa 02 00 00 00 00	if r2 != 0 goto +762 <LBB13_326>
    1680:	b7 06 00 00 02 00 00 00	r6 = 2
; 			return policy->proxy_port;
    1681:	69 00 00 00 00 00 00 00	r0 = *(u16 *)(r0 + 0)
    1682:	05 00 18 03 00 00 00 00	goto +792 <LBB13_343>

0000000000003498 <LBB13_160>:
    1683:	18 00 00 00 7a ff ff ff 00 00 00 00 00 00 00 00	r0 = 4294967162 ll
    1685:	b7 06 00 00 00 00 00 00	r6 = 0

00000000000034b0 <LBB13_161>:
; 	if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {
    1686:	15 07 16 03 02 00 00 00	if r7 == 2 goto +790 <LBB13_344>
; 	return ctx->len;
    1687:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1688:	61 17 00 00 00 00 00 00	r7 = *(u32 *)(r1 + 0)
; 					   tuple.nexthdr, POLICY_EGRESS, 0,
    1689:	71 a4 8c ff 00 00 00 00	r4 = *(u8 *)(r10 - 116)
; 		send_policy_verdict_notify(ctx, *dstID, tuple.dport,
    1690:	69 a2 88 ff 00 00 00 00	r2 = *(u16 *)(r10 - 120)
    1691:	b7 03 00 00 02 00 00 00	r3 = 2
; 	volatile __u8 d = dir;
    1692:	73 3a a0 ff 00 00 00 00	*(u8 *)(r10 - 96) = r3
; 	return ((filter & d) > 0);
    1693:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
    1695:	71 a5 a0 ff 00 00 00 00	r5 = *(u8 *)(r10 - 96)
    1696:	5f 35 00 00 00 00 00 00	r5 &= r3
; 	__u64 cap_len = min_t(__u64, TRACE_PAYLOAD_LEN, ctx_len);
    1697:	bf 73 00 00 00 00 00 00	r3 = r7
    1698:	a5 07 01 00 80 00 00 00	if r7 < 128 goto +1 <LBB13_164>
    1699:	b7 03 00 00 80 00 00 00	r3 = 128

0000000000003520 <LBB13_164>:
; 	if (!policy_verdict_filter_allow(POLICY_VERDICT_LOG_FILTER, dir))
    1700:	15 05 23 00 00 00 00 00	if r5 == 0 goto +35 <LBB13_166>
    1701:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    1702:	61 15 44 00 00 00 00 00	r5 = *(u32 *)(r1 + 68)
    1703:	bf 08 00 00 00 00 00 00	r8 = r0
    1704:	b7 00 00 00 00 00 00 00	r0 = 0
; 	msg = (typeof(msg)) {
    1705:	63 0a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r0
    1706:	73 4a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r4
    1707:	dc 02 00 00 10 00 00 00	r2 = be16 r2
    1708:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
    1709:	63 8a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r8
    1710:	79 a2 30 ff 00 00 00 00	r2 = *(u64 *)(r10 - 208)
    1711:	63 2a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r2
    1712:	b7 02 00 00 01 00 00 00	r2 = 1
    1713:	6b 2a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r2
    1714:	63 7a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r7
    1715:	63 5a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r5
    1716:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    1718:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    1719:	b7 02 00 00 05 00 00 00	r2 = 5
    1720:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    1721:	67 06 00 00 03 00 00 00	r6 <<= 3
    1722:	47 06 00 00 02 00 00 00	r6 |= 2
    1723:	73 6a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r6
    1724:	6b 3a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r3
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    1725:	67 03 00 00 20 00 00 00	r3 <<= 32
    1726:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    1728:	4f 23 00 00 00 00 00 00	r3 |= r2
    1729:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    1730:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    1731:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    1733:	b7 05 00 00 20 00 00 00	r5 = 32
    1734:	85 00 00 00 19 00 00 00	call 25
    1735:	bf 80 00 00 00 00 00 00	r0 = r8

0000000000003640 <LBB13_166>:
    1736:	bf 08 00 00 00 00 00 00	r8 = r0
    1737:	05 00 d8 04 00 00 00 00	goto +1240 <LBB13_420>

0000000000003650 <LBB13_167>:
; 			    (seen_flags.value & TCP_FLAG_RST) &&
    1738:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
    1739:	57 02 00 00 04 00 00 00	r2 &= 4
    1740:	b7 01 00 00 02 00 00 00	r1 = 2
    1741:	15 02 01 00 00 00 00 00	if r2 == 0 goto +1 <LBB13_169>
    1742:	b7 01 00 00 03 00 00 00	r1 = 3

0000000000003678 <LBB13_169>:
    1743:	69 82 24 00 00 00 00 00	r2 = *(u16 *)(r8 + 36)
; 			    (seen_flags.value & TCP_FLAG_RST) &&
    1744:	4f 12 00 00 00 00 00 00	r2 |= r1
    1745:	6b 28 24 00 00 00 00 00	*(u16 *)(r8 + 36) = r2
    1746:	b7 05 00 00 80 00 00 00	r5 = 128
; 	return !entry->rx_closing || !entry->tx_closing;
    1747:	57 02 00 00 03 00 00 00	r2 &= 3
; 			if (ct_entry_alive(entry))
    1748:	55 02 45 ff 03 00 00 00	if r2 != 3 goto -187 <LBB13_136>
; 	__u32 now = bpf_mono_now();
    1749:	85 00 00 00 05 00 00 00	call 5
    1750:	b7 05 00 00 80 00 00 00	r5 = 128
    1751:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
; 	__u32 now = bpf_mono_now();
    1752:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1753:	bf 01 00 00 00 00 00 00	r1 = r0
    1754:	07 01 00 00 0a 00 00 00	r1 += 10
    1755:	63 18 20 00 00 00 00 00	*(u32 *)(r8 + 32) = r1
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1756:	71 83 2a 00 00 00 00 00	r3 = *(u8 *)(r8 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1757:	61 82 30 00 00 00 00 00	r2 = *(u32 *)(r8 + 48)
    1758:	79 a6 e0 fe 00 00 00 00	r6 = *(u64 *)(r10 - 288)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1759:	57 06 00 00 02 00 00 00	r6 &= 2
; 	seen_flags |= accumulated_flags;
    1760:	bf 31 00 00 00 00 00 00	r1 = r3
    1761:	4f 61 00 00 00 00 00 00	r1 |= r6
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1762:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_172>
    1763:	07 02 00 00 05 00 00 00	r2 += 5
    1764:	bf 03 00 00 00 00 00 00	r3 = r0
    1765:	67 03 00 00 20 00 00 00	r3 <<= 32
    1766:	77 03 00 00 20 00 00 00	r3 >>= 32
    1767:	67 02 00 00 20 00 00 00	r2 <<= 32
    1768:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1769:	3d 32 30 ff 00 00 00 00	if r2 >= r3 goto -208 <LBB13_136>

0000000000003750 <LBB13_172>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    1770:	73 18 2a 00 00 00 00 00	*(u8 *)(r8 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    1771:	63 08 30 00 00 00 00 00	*(u32 *)(r8 + 48) = r0
; 	barrier();
    1772:	05 00 2d ff 00 00 00 00	goto -211 <LBB13_136>

0000000000003768 <LBB13_274>:
    1773:	b7 06 00 00 00 00 00 00	r6 = 0
    1774:	b7 00 00 00 00 00 00 00	r0 = 0
    1775:	05 00 bd 02 00 00 00 00	goto +701 <LBB13_344>

0000000000003780 <LBB13_278>:
    1776:	7b 3a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r3
    1777:	79 a2 30 ff 00 00 00 00	r2 = *(u64 *)(r10 - 208)
; 	return ctx->len;
    1778:	61 58 00 00 00 00 00 00	r8 = *(u32 *)(r5 + 0)
; 	struct metrics_value *entry, newEntry = {};
    1779:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    1780:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1781:	b7 01 00 00 09 02 00 00	r1 = 521
; 	struct metrics_key key = {};
    1782:	7b 1a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r1
    1783:	bf a2 00 00 00 00 00 00	r2 = r10
    1784:	07 02 00 00 48 ff ff ff	r2 += -184
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    1785:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1787:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    1788:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_282>
; 		entry->count += 1;
    1789:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1790:	07 01 00 00 01 00 00 00	r1 += 1
    1791:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1792:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1793:	0f 81 00 00 00 00 00 00	r1 += r8
    1794:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1795:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_283>

0000000000003820 <LBB13_282>:
; 		newEntry.bytes = bytes;
    1796:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    1797:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1798:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1799:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1800:	07 02 00 00 48 ff ff ff	r2 += -184
    1801:	bf a3 00 00 00 00 00 00	r3 = r10
    1802:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1803:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1805:	b7 04 00 00 00 00 00 00	r4 = 0
    1806:	85 00 00 00 02 00 00 00	call 2

0000000000003878 <LBB13_283>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
    1807:	69 61 14 00 00 00 00 00	r1 = *(u16 *)(r6 + 20)
    1808:	57 01 00 00 1f ff 00 00	r1 &= 65311
; 		if (likely(not_first_fragment))
    1809:	15 01 27 00 00 00 00 00	if r1 == 0 goto +39 <LBB13_313>
    1810:	bf a2 00 00 00 00 00 00	r2 = r10
    1811:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	tmp = map_lookup_elem(&IPV4_FRAG_DATAGRAMS_MAP, frag_id);
    1812:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1814:	85 00 00 00 01 00 00 00	call 1
; 	if (!tmp)
    1815:	55 00 04 00 00 00 00 00	if r0 != 0 goto +4 <LBB13_290>

00000000000038c0 <LBB13_285>:
    1816:	18 03 00 00 51 ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967121 ll
    1818:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
    1819:	05 00 c2 fa 00 00 00 00	goto -1342 <LBB13_86>

00000000000038e0 <LBB13_290>:
    1820:	61 01 00 00 00 00 00 00	r1 = *(u32 *)(r0 + 0)
    1821:	63 1a 88 ff 00 00 00 00	*(u32 *)(r10 - 120) = r1

00000000000038f0 <LBB13_291>:
    1822:	b7 06 00 00 01 00 00 00	r6 = 1
    1823:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
    1824:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
    1825:	05 00 ae fd 00 00 00 00	goto -594 <LBB13_94>

0000000000003910 <LBB13_292>:
    1826:	b7 06 00 00 00 00 00 00	r6 = 0
; 		key.sec_label = 0;
    1827:	63 6a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r6
    1828:	bf a2 00 00 00 00 00 00	r2 = r10
    1829:	07 02 00 00 a0 ff ff ff	r2 += -96
; 		policy = map_lookup_elem(map, &key);
    1830:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1832:	85 00 00 00 01 00 00 00	call 1
; 		if (likely(policy)) {
    1833:	15 00 49 02 00 00 00 00	if r0 == 0 goto +585 <LBB13_324>
    1834:	b7 01 00 00 01 00 00 00	r1 = 1
; 	__sync_fetch_and_add(&policy->packets, 1);
    1835:	db 10 08 00 00 00 00 00	lock *(u64 *)(r0 + 8) += r1
    1836:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    1837:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
; 	__sync_fetch_and_add(&policy->bytes, ctx_full_len(ctx));
    1838:	db 10 10 00 00 00 00 00	lock *(u64 *)(r0 + 16) += r1
    1839:	18 01 00 00 4b ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967115 ll
    1841:	b7 06 00 00 03 00 00 00	r6 = 3
; 			if (unlikely(policy->deny))
    1842:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    1843:	57 02 00 00 01 00 00 00	r2 &= 1
    1844:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    1845:	55 02 54 02 00 00 00 00	if r2 != 0 goto +596 <LBB13_326>
    1846:	b7 06 00 00 03 00 00 00	r6 = 3
; 			return policy->proxy_port;
    1847:	69 00 00 00 00 00 00 00	r0 = *(u16 *)(r0 + 0)
    1848:	05 00 72 02 00 00 00 00	goto +626 <LBB13_343>

00000000000039c8 <LBB13_313>:
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1849:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1850:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1851:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1852:	b7 04 00 00 04 00 00 00	r4 = 4
    1853:	85 00 00 00 1a 00 00 00	call 26
    1854:	67 00 00 00 20 00 00 00	r0 <<= 32
    1855:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1856:	bf 03 00 00 00 00 00 00	r3 = r0
; 	if (ret < 0)
    1857:	c5 00 1e 00 00 00 00 00	if r0 s< 0 goto +30 <LBB13_323>
    1858:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (map_update_elem(&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))
    1859:	07 02 00 00 d8 ff ff ff	r2 += -40
    1860:	b7 08 00 00 00 00 00 00	r8 = 0
    1861:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1863:	79 a3 e0 fe 00 00 00 00	r3 = *(u64 *)(r10 - 288)
    1864:	b7 04 00 00 00 00 00 00	r4 = 0
    1865:	85 00 00 00 02 00 00 00	call 2
    1866:	67 00 00 00 20 00 00 00	r0 <<= 32
    1867:	77 00 00 00 20 00 00 00	r0 >>= 32
    1868:	15 00 20 00 00 00 00 00	if r0 == 0 goto +32 <LBB13_336>
; 	return ctx->len;
    1869:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    1870:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    1871:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    1872:	7b 8a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r8
    1873:	b7 01 00 00 0a 02 00 00	r1 = 522
; 	struct metrics_key key = {};
    1874:	7b 1a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r1
    1875:	bf a2 00 00 00 00 00 00	r2 = r10
    1876:	07 02 00 00 48 ff ff ff	r2 += -184
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    1877:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1879:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    1880:	15 00 09 00 00 00 00 00	if r0 == 0 goto +9 <LBB13_335>
; 		entry->count += 1;
    1881:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    1882:	07 01 00 00 01 00 00 00	r1 += 1
    1883:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    1884:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    1885:	0f 61 00 00 00 00 00 00	r1 += r6
    1886:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    1887:	05 00 0d 00 00 00 00 00	goto +13 <LBB13_336>

0000000000003b00 <LBB13_323>:
    1888:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
    1889:	05 00 7c fa 00 00 00 00	goto -1412 <LBB13_86>

0000000000003b10 <LBB13_335>:
; 		newEntry.bytes = bytes;
    1890:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    1891:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    1892:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    1893:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    1894:	07 02 00 00 48 ff ff ff	r2 += -184
    1895:	bf a3 00 00 00 00 00 00	r3 = r10
    1896:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    1897:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    1899:	b7 04 00 00 00 00 00 00	r4 = 0
    1900:	85 00 00 00 02 00 00 00	call 2

0000000000003b68 <LBB13_336>:
    1901:	79 a5 40 ff 00 00 00 00	r5 = *(u64 *)(r10 - 192)
    1902:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
    1903:	05 00 4f fd 00 00 00 00	goto -689 <LBB13_59>

0000000000003b80 <LBB13_66>:
; 	return (void *)(unsigned long)ctx->data_end;
    1904:	61 41 50 00 00 00 00 00	r1 = *(u32 *)(r4 + 80)
; 	return (void *)(unsigned long)ctx->data;
    1905:	61 46 4c 00 00 00 00 00	r6 = *(u32 *)(r4 + 76)
; 	if (data + tot_len > data_end)
    1906:	bf 62 00 00 00 00 00 00	r2 = r6
    1907:	07 02 00 00 22 00 00 00	r2 += 34
    1908:	2d 12 64 fa 00 00 00 00	if r2 > r1 goto -1436 <LBB13_83>
    1909:	7b 5a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r5
    1910:	7b 3a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r3
    1911:	7b 9a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r9
    1912:	7b 7a e0 fe 00 00 00 00	*(u64 *)(r10 - 288) = r7
; 		.daddr = ip4->daddr,
    1913:	61 61 1e 00 00 00 00 00	r1 = *(u32 *)(r6 + 30)
; 	struct ipv4_frag_id frag_id = {
    1914:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 		.saddr = ip4->saddr,
    1915:	61 61 1a 00 00 00 00 00	r1 = *(u32 *)(r6 + 26)
; 	struct ipv4_frag_id frag_id = {
    1916:	63 1a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r1
; 		.id = ip4->id,
    1917:	69 61 12 00 00 00 00 00	r1 = *(u16 *)(r6 + 18)
; 	struct ipv4_frag_id frag_id = {
    1918:	6b 1a e0 ff 00 00 00 00	*(u16 *)(r10 - 32) = r1
    1919:	b7 01 00 00 00 00 00 00	r1 = 0
; 		.proto = ip4->protocol,
    1920:	71 62 17 00 00 00 00 00	r2 = *(u8 *)(r6 + 23)
; 	struct ipv4_frag_id frag_id = {
    1921:	73 1a e3 ff 00 00 00 00	*(u8 *)(r10 - 29) = r1
    1922:	73 2a e2 ff 00 00 00 00	*(u8 *)(r10 - 30) = r2
; 				    (struct ipv4_frag_l4ports *)&tuple->dport,
    1923:	bf a7 00 00 00 00 00 00	r7 = r10
    1924:	07 07 00 00 88 ff ff ff	r7 += -120
; 	return ip4->frag_off & bpf_htons(0x3FFF);
    1925:	69 62 14 00 00 00 00 00	r2 = *(u16 *)(r6 + 20)
    1926:	57 02 00 00 3f ff 00 00	r2 &= 65343
; 	if (unlikely(is_fragment)) {
    1927:	55 02 8c 01 00 00 00 00	if r2 != 0 goto +396 <LBB13_295>
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    1928:	bf 41 00 00 00 00 00 00	r1 = r4
    1929:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1930:	bf 73 00 00 00 00 00 00	r3 = r7
    1931:	b7 04 00 00 04 00 00 00	r4 = 4
    1932:	85 00 00 00 1a 00 00 00	call 26
    1933:	67 00 00 00 20 00 00 00	r0 <<= 32
    1934:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 		if (err < 0)
    1935:	c5 00 1d fa 00 00 00 00	if r0 s< 0 goto -1507 <LBB13_75>

0000000000003c80 <LBB13_69>:
; 			if (ctx_load_bytes(ctx, off + 12, &tcp_flags, 2) < 0)
    1936:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    1937:	07 02 00 00 0c 00 00 00	r2 += 12
    1938:	bf a3 00 00 00 00 00 00	r3 = r10
    1939:	07 03 00 00 98 ff ff ff	r3 += -104
    1940:	79 a6 40 ff 00 00 00 00	r6 = *(u64 *)(r10 - 192)
    1941:	bf 61 00 00 00 00 00 00	r1 = r6
    1942:	b7 04 00 00 02 00 00 00	r4 = 2
    1943:	85 00 00 00 1a 00 00 00	call 26
    1944:	67 00 00 00 20 00 00 00	r0 <<= 32
    1945:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    1946:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    1947:	c5 00 3d fa 00 00 00 00	if r0 s< 0 goto -1475 <LBB13_83>
; 			if (unlikely(tcp_flags.value & (TCP_FLAG_RST|TCP_FLAG_FIN)))
    1948:	61 a1 98 ff 00 00 00 00	r1 = *(u32 *)(r10 - 104)
    1949:	57 01 00 00 00 05 00 00	r1 &= 1280
    1950:	b7 06 00 00 01 00 00 00	r6 = 1
    1951:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_180>
    1952:	b7 06 00 00 02 00 00 00	r6 = 2

0000000000003d08 <LBB13_180>:
    1953:	71 a1 99 ff 00 00 00 00	r1 = *(u8 *)(r10 - 103)
;        volatile int __maybe_unused id = get_smp_processor_id();
    1954:	7b 1a e8 fe 00 00 00 00	*(u64 *)(r10 - 280) = r1
    1955:	85 00 00 00 08 00 00 00	call 8
    1956:	63 0a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r0
    1957:	bf a2 00 00 00 00 00 00	r2 = r10
    1958:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    1959:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    1960:	85 00 00 00 01 00 00 00	call 1
    1961:	bf 09 00 00 00 00 00 00	r9 = r0
; 	if (entry) {
    1962:	15 09 70 00 00 00 00 00	if r9 == 0 goto +112 <LBB13_197>
; 	return !entry->rx_closing || !entry->tx_closing;
    1963:	69 91 24 00 00 00 00 00	r1 = *(u16 *)(r9 + 36)
    1964:	bf 12 00 00 00 00 00 00	r2 = r1
    1965:	57 02 00 00 03 00 00 00	r2 &= 3
; 		if (ct_entry_alive(entry))
    1966:	15 02 25 00 03 00 00 00	if r2 == 3 goto +37 <LBB13_188>
    1967:	b7 07 00 00 3c 00 00 00	r7 = 60
    1968:	79 a4 f8 fe 00 00 00 00	r4 = *(u64 *)(r10 - 264)
; 	if (tcp) {
    1969:	55 04 0d 00 06 00 00 00	if r4 != 6 goto +13 <LBB13_185>
    1970:	79 a2 e8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 280)
    1971:	67 02 00 00 03 00 00 00	r2 <<= 3
    1972:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    1973:	bf 13 00 00 00 00 00 00	r3 = r1
    1974:	4f 23 00 00 00 00 00 00	r3 |= r2
    1975:	57 03 00 00 10 00 00 00	r3 &= 16
    1976:	57 01 00 00 ef ff 00 00	r1 &= 65519
    1977:	bf 32 00 00 00 00 00 00	r2 = r3
    1978:	4f 12 00 00 00 00 00 00	r2 |= r1
    1979:	6b 29 24 00 00 00 00 00	*(u16 *)(r9 + 36) = r2
    1980:	b7 07 00 00 3c 00 00 00	r7 = 60
    1981:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_185>
    1982:	b7 07 00 00 60 54 00 00	r7 = 21600

0000000000003df8 <LBB13_185>:
    1983:	7b 4a f8 fe 00 00 00 00	*(u64 *)(r10 - 264) = r4
; 	__u32 now = bpf_mono_now();
    1984:	85 00 00 00 05 00 00 00	call 5
    1985:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    1986:	0f 07 00 00 00 00 00 00	r7 += r0
    1987:	63 79 20 00 00 00 00 00	*(u32 *)(r9 + 32) = r7
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    1988:	71 93 2a 00 00 00 00 00	r3 = *(u8 *)(r9 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    1989:	61 92 30 00 00 00 00 00	r2 = *(u32 *)(r9 + 48)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    1990:	79 a4 e8 fe 00 00 00 00	r4 = *(u64 *)(r10 - 280)
    1991:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    1992:	bf 31 00 00 00 00 00 00	r1 = r3
    1993:	4f 41 00 00 00 00 00 00	r1 |= r4
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    1994:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_187>
    1995:	07 02 00 00 05 00 00 00	r2 += 5
    1996:	bf 03 00 00 00 00 00 00	r3 = r0
    1997:	67 03 00 00 20 00 00 00	r3 <<= 32
    1998:	77 03 00 00 20 00 00 00	r3 >>= 32
    1999:	67 02 00 00 20 00 00 00	r2 <<= 32
    2000:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2001:	3d 32 02 00 00 00 00 00	if r2 >= r3 goto +2 <LBB13_188>

0000000000003e90 <LBB13_187>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    2002:	73 19 2a 00 00 00 00 00	*(u8 *)(r9 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    2003:	63 09 30 00 00 00 00 00	*(u32 *)(r9 + 48) = r0

0000000000003ea0 <LBB13_188>:
; 			ct_state->loopback = entry->lb_loopback;
    2004:	69 91 24 00 00 00 00 00	r1 = *(u16 *)(r9 + 36)
    2005:	bf 12 00 00 00 00 00 00	r2 = r1
    2006:	77 02 00 00 03 00 00 00	r2 >>= 3
    2007:	57 02 00 00 01 00 00 00	r2 &= 1
; 			ct_state->node_port = entry->node_port;
    2008:	bf 13 00 00 00 00 00 00	r3 = r1
    2009:	77 03 00 00 04 00 00 00	r3 >>= 4
    2010:	bf 37 00 00 00 00 00 00	r7 = r3
    2011:	57 07 00 00 02 00 00 00	r7 &= 2
    2012:	4f 27 00 00 00 00 00 00	r7 |= r2
; 			ct_state->dsr = entry->dsr;
    2013:	57 03 00 00 08 00 00 00	r3 &= 8
    2014:	7b 3a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r3
; 				ct_state->backend_id = entry->backend_id;
    2015:	79 92 08 00 00 00 00 00	r2 = *(u64 *)(r9 + 8)
; 			ct_state->ifindex = entry->ifindex;
    2016:	7b 2a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r2
    2017:	69 92 28 00 00 00 00 00	r2 = *(u16 *)(r9 + 40)
; 			ct_state->rev_nat_index = entry->rev_nat_index;
    2018:	7b 2a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r2
    2019:	69 95 26 00 00 00 00 00	r5 = *(u16 *)(r9 + 38)
; 		switch (action) {
    2020:	67 06 00 00 20 00 00 00	r6 <<= 32
    2021:	77 06 00 00 20 00 00 00	r6 >>= 32
    2022:	79 a4 f8 fe 00 00 00 00	r4 = *(u64 *)(r10 - 264)
    2023:	15 06 37 00 02 00 00 00	if r6 == 2 goto +55 <LBB13_198>
    2024:	55 06 51 00 01 00 00 00	if r6 != 1 goto +81 <LBB13_202>
; 			reopen = entry->rx_closing | entry->tx_closing;
    2025:	bf 12 00 00 00 00 00 00	r2 = r1
    2026:	77 02 00 00 01 00 00 00	r2 >>= 1
    2027:	4f 12 00 00 00 00 00 00	r2 |= r1
    2028:	57 02 00 00 01 00 00 00	r2 &= 1
; 			reopen |= seen_flags.value & TCP_FLAG_SYN;
    2029:	79 a3 e8 fe 00 00 00 00	r3 = *(u64 *)(r10 - 280)
    2030:	67 03 00 00 08 00 00 00	r3 <<= 8
    2031:	57 03 00 00 00 02 00 00	r3 &= 512
    2032:	4f 23 00 00 00 00 00 00	r3 |= r2
; 			if (unlikely(reopen == (TCP_FLAG_SYN|0x1))) {
    2033:	55 03 48 00 01 02 00 00	if r3 != 513 goto +72 <LBB13_202>
    2034:	7b 5a d0 fe 00 00 00 00	*(u64 *)(r10 - 304) = r5
; 	entry->tx_closing = 0;
    2035:	bf 12 00 00 00 00 00 00	r2 = r1
    2036:	57 02 00 00 fc ff 00 00	r2 &= 65532
    2037:	6b 29 24 00 00 00 00 00	*(u16 *)(r9 + 36) = r2
    2038:	b7 06 00 00 3c 00 00 00	r6 = 60
; 	if (tcp) {
    2039:	55 04 0d 00 06 00 00 00	if r4 != 6 goto +13 <LBB13_194>
    2040:	79 a2 e8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 280)
    2041:	67 02 00 00 03 00 00 00	r2 <<= 3
    2042:	a7 02 00 00 ff ff ff ff	r2 ^= -1
; 		entry->seen_non_syn |= !syn;
    2043:	bf 13 00 00 00 00 00 00	r3 = r1
    2044:	4f 23 00 00 00 00 00 00	r3 |= r2
    2045:	57 03 00 00 10 00 00 00	r3 &= 16
    2046:	57 01 00 00 ec ff 00 00	r1 &= 65516
    2047:	bf 32 00 00 00 00 00 00	r2 = r3
    2048:	4f 12 00 00 00 00 00 00	r2 |= r1
    2049:	6b 29 24 00 00 00 00 00	*(u16 *)(r9 + 36) = r2
    2050:	b7 06 00 00 3c 00 00 00	r6 = 60
    2051:	15 03 01 00 00 00 00 00	if r3 == 0 goto +1 <LBB13_194>
    2052:	b7 06 00 00 60 54 00 00	r6 = 21600

0000000000004028 <LBB13_194>:
; 	__u32 now = bpf_mono_now();
    2053:	85 00 00 00 05 00 00 00	call 5
    2054:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    2055:	0f 06 00 00 00 00 00 00	r6 += r0
    2056:	63 69 20 00 00 00 00 00	*(u32 *)(r9 + 32) = r6
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    2057:	71 93 2a 00 00 00 00 00	r3 = *(u8 *)(r9 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    2058:	61 92 30 00 00 00 00 00	r2 = *(u32 *)(r9 + 48)
    2059:	79 a4 e8 fe 00 00 00 00	r4 = *(u64 *)(r10 - 280)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    2060:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    2061:	bf 31 00 00 00 00 00 00	r1 = r3
    2062:	4f 41 00 00 00 00 00 00	r1 |= r4
    2063:	79 a5 d0 fe 00 00 00 00	r5 = *(u64 *)(r10 - 304)
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2064:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_196>
    2065:	07 02 00 00 05 00 00 00	r2 += 5
    2066:	bf 03 00 00 00 00 00 00	r3 = r0
    2067:	67 03 00 00 20 00 00 00	r3 <<= 32
    2068:	77 03 00 00 20 00 00 00	r3 >>= 32
    2069:	67 02 00 00 20 00 00 00	r2 <<= 32
    2070:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2071:	3d 32 22 00 00 00 00 00	if r2 >= r3 goto +34 <LBB13_202>

00000000000040c0 <LBB13_196>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    2072:	73 19 2a 00 00 00 00 00	*(u8 *)(r9 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    2073:	63 09 30 00 00 00 00 00	*(u32 *)(r9 + 48) = r0
; 	barrier();
    2074:	05 00 1f 00 00 00 00 00	goto +31 <LBB13_202>

00000000000040d8 <LBB13_197>:
;        volatile int __maybe_unused id = get_smp_processor_id();
    2075:	85 00 00 00 08 00 00 00	call 8
    2076:	63 0a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r0
    2077:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    2078:	05 00 9b f9 00 00 00 00	goto -1637 <LBB13_77>

00000000000040f8 <LBB13_198>:
; 				entry->tx_closing = 1;
    2079:	47 01 00 00 02 00 00 00	r1 |= 2
    2080:	6b 19 24 00 00 00 00 00	*(u16 *)(r9 + 36) = r1
; 	return !entry->rx_closing || !entry->tx_closing;
    2081:	57 01 00 00 03 00 00 00	r1 &= 3
; 			if (ct_entry_alive(entry))
    2082:	55 01 17 00 03 00 00 00	if r1 != 3 goto +23 <LBB13_202>
    2083:	bf 56 00 00 00 00 00 00	r6 = r5
; 	__u32 now = bpf_mono_now();
    2084:	85 00 00 00 05 00 00 00	call 5
    2085:	bf 65 00 00 00 00 00 00	r5 = r6
; 	__u32 now = bpf_mono_now();
    2086:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    2087:	bf 01 00 00 00 00 00 00	r1 = r0
    2088:	07 01 00 00 0a 00 00 00	r1 += 10
    2089:	63 19 20 00 00 00 00 00	*(u32 *)(r9 + 32) = r1
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    2090:	71 93 2a 00 00 00 00 00	r3 = *(u8 *)(r9 + 42)
; 		last_report = READ_ONCE(entry->last_tx_report);
    2091:	61 92 30 00 00 00 00 00	r2 = *(u32 *)(r9 + 48)
    2092:	79 a4 e8 fe 00 00 00 00	r4 = *(u64 *)(r10 - 280)
; 	__u8 seen_flags = flags.lower_bits & report_mask;
    2093:	57 04 00 00 02 00 00 00	r4 &= 2
; 	seen_flags |= accumulated_flags;
    2094:	bf 31 00 00 00 00 00 00	r1 = r3
    2095:	4f 41 00 00 00 00 00 00	r1 |= r4
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2096:	5d 13 07 00 00 00 00 00	if r3 != r1 goto +7 <LBB13_201>
    2097:	07 02 00 00 05 00 00 00	r2 += 5
    2098:	bf 03 00 00 00 00 00 00	r3 = r0
    2099:	67 03 00 00 20 00 00 00	r3 <<= 32
    2100:	77 03 00 00 20 00 00 00	r3 >>= 32
    2101:	67 02 00 00 20 00 00 00	r2 <<= 32
    2102:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2103:	3d 32 02 00 00 00 00 00	if r2 >= r3 goto +2 <LBB13_202>

00000000000041c0 <LBB13_201>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    2104:	73 19 2a 00 00 00 00 00	*(u8 *)(r9 + 42) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    2105:	63 09 30 00 00 00 00 00	*(u32 *)(r9 + 48) = r0

00000000000041d0 <LBB13_202>:
    2106:	79 a1 d8 fe 00 00 00 00	r1 = *(u64 *)(r10 - 296)
    2107:	4f 17 00 00 00 00 00 00	r7 |= r1
    2108:	7b 7a d8 fe 00 00 00 00	*(u64 *)(r10 - 296) = r7
; 		if (unlikely(state->rev_nat_index == 0)) {
    2109:	bf 51 00 00 00 00 00 00	r1 = r5
    2110:	55 01 09 00 00 00 00 00	if r1 != 0 goto +9 <LBB13_205>

00000000000041f8 <LBB13_203>:
; 			state->rev_nat_index = svc->rev_nat_index;
    2111:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
    2112:	69 16 06 00 00 00 00 00	r6 = *(u16 *)(r1 + 6)
    2113:	bf a2 00 00 00 00 00 00	r2 = r10
; 			state->rev_nat_index = svc->rev_nat_index;
    2114:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    2115:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2116:	85 00 00 00 01 00 00 00	call 1
    2117:	bf 65 00 00 00 00 00 00	r5 = r6
; 	if (!entry)
    2118:	15 00 01 00 00 00 00 00	if r0 == 0 goto +1 <LBB13_205>
; 	entry->rev_nat_index = state->rev_nat_index;
    2119:	6b 50 26 00 00 00 00 00	*(u16 *)(r0 + 38) = r5

0000000000004240 <LBB13_205>:
    2120:	79 a3 10 ff 00 00 00 00	r3 = *(u64 *)(r10 - 240)
; 	if (state->rev_nat_index != svc->rev_nat_index) {
    2121:	69 31 06 00 00 00 00 00	r1 = *(u16 *)(r3 + 6)
    2122:	bf 52 00 00 00 00 00 00	r2 = r5
    2123:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    2124:	1d 12 8c 00 00 00 00 00	if r2 == r1 goto +140 <LBB13_219>
; 	return svc->flags & SVC_FLAG_AFFINITY;
    2125:	71 32 08 00 00 00 00 00	r2 = *(u8 *)(r3 + 8)
    2126:	57 02 00 00 10 00 00 00	r2 &= 16
; 		if (lb4_svc_is_affinity(svc))
    2127:	15 02 64 00 00 00 00 00	if r2 == 0 goto +100 <LBB13_213>
    2128:	7b 9a 30 ff 00 00 00 00	*(u64 *)(r10 - 208) = r9
    2129:	b7 06 00 00 00 00 00 00	r6 = 0
; 	struct lb4_affinity_key key = {
    2130:	63 6a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r6
    2131:	6b 6a aa ff 00 00 00 00	*(u16 *)(r10 - 86) = r6
    2132:	6b 1a a8 ff 00 00 00 00	*(u16 *)(r10 - 88) = r1
; 		.client_id	= *id,
    2133:	79 a1 e0 fe 00 00 00 00	r1 = *(u64 *)(r10 - 288)
    2134:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    2135:	bf a2 00 00 00 00 00 00	r2 = r10
    2136:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	val = map_lookup_elem(&LB4_AFFINITY_MAP, &key);
    2137:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2139:	85 00 00 00 01 00 00 00	call 1
    2140:	bf 09 00 00 00 00 00 00	r9 = r0
; 	if (val != NULL) {
    2141:	55 09 02 00 00 00 00 00	if r9 != 0 goto +2 <LBB13_209>
    2142:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    2143:	05 00 54 00 00 00 00 00	goto +84 <LBB13_213>

0000000000004300 <LBB13_209>:
; 		__u32 now = bpf_mono_now();
    2144:	85 00 00 00 05 00 00 00	call 5
    2145:	bf 07 00 00 00 00 00 00	r7 = r0
; 			.backend_id	= val->backend_id,
    2146:	71 91 09 00 00 00 00 00	r1 = *(u8 *)(r9 + 9)
    2147:	67 01 00 00 08 00 00 00	r1 <<= 8
    2148:	71 92 08 00 00 00 00 00	r2 = *(u8 *)(r9 + 8)
    2149:	4f 21 00 00 00 00 00 00	r1 |= r2
    2150:	71 92 0b 00 00 00 00 00	r2 = *(u8 *)(r9 + 11)
    2151:	67 02 00 00 08 00 00 00	r2 <<= 8
    2152:	71 93 0a 00 00 00 00 00	r3 = *(u8 *)(r9 + 10)
    2153:	4f 32 00 00 00 00 00 00	r2 |= r3
    2154:	67 02 00 00 10 00 00 00	r2 <<= 16
    2155:	4f 12 00 00 00 00 00 00	r2 |= r1
; 		struct lb_affinity_match match = {
    2156:	63 2a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r2
    2157:	79 a5 10 ff 00 00 00 00	r5 = *(u64 *)(r10 - 240)
; 			.rev_nat_id	= svc->rev_nat_index,
    2158:	69 51 06 00 00 00 00 00	r1 = *(u16 *)(r5 + 6)
; 		struct lb_affinity_match match = {
    2159:	6b 6a de ff 00 00 00 00	*(u16 *)(r10 - 34) = r6
    2160:	6b 1a dc ff 00 00 00 00	*(u16 *)(r10 - 36) = r1
; 		if (READ_ONCE(val->last_used) +
    2161:	71 92 01 00 00 00 00 00	r2 = *(u8 *)(r9 + 1)
    2162:	67 02 00 00 08 00 00 00	r2 <<= 8
    2163:	71 91 00 00 00 00 00 00	r1 = *(u8 *)(r9 + 0)
    2164:	4f 12 00 00 00 00 00 00	r2 |= r1
    2165:	71 91 03 00 00 00 00 00	r1 = *(u8 *)(r9 + 3)
    2166:	67 01 00 00 08 00 00 00	r1 <<= 8
    2167:	71 93 02 00 00 00 00 00	r3 = *(u8 *)(r9 + 2)
    2168:	4f 31 00 00 00 00 00 00	r1 |= r3
    2169:	67 01 00 00 10 00 00 00	r1 <<= 16
    2170:	4f 21 00 00 00 00 00 00	r1 |= r2
    2171:	71 92 05 00 00 00 00 00	r2 = *(u8 *)(r9 + 5)
    2172:	67 02 00 00 08 00 00 00	r2 <<= 8
    2173:	71 93 04 00 00 00 00 00	r3 = *(u8 *)(r9 + 4)
    2174:	4f 32 00 00 00 00 00 00	r2 |= r3
    2175:	71 93 06 00 00 00 00 00	r3 = *(u8 *)(r9 + 6)
    2176:	71 94 07 00 00 00 00 00	r4 = *(u8 *)(r9 + 7)
    2177:	67 04 00 00 08 00 00 00	r4 <<= 8
    2178:	4f 34 00 00 00 00 00 00	r4 |= r3
    2179:	67 04 00 00 10 00 00 00	r4 <<= 16
    2180:	4f 24 00 00 00 00 00 00	r4 |= r2
    2181:	67 04 00 00 20 00 00 00	r4 <<= 32
    2182:	4f 14 00 00 00 00 00 00	r4 |= r1
; 		    bpf_sec_to_mono(svc->affinity_timeout) <= now) {
    2183:	61 51 00 00 00 00 00 00	r1 = *(u32 *)(r5 + 0)
; 		if (READ_ONCE(val->last_used) +
    2184:	0f 14 00 00 00 00 00 00	r4 += r1
; 		__u32 now = bpf_mono_now();
    2185:	37 07 00 00 00 ca 9a 3b	r7 /= 1000000000
; 		    bpf_sec_to_mono(svc->affinity_timeout) <= now) {
    2186:	67 07 00 00 20 00 00 00	r7 <<= 32
    2187:	77 07 00 00 20 00 00 00	r7 >>= 32
; 		if (READ_ONCE(val->last_used) +
    2188:	bd 74 06 00 00 00 00 00	if r4 <= r7 goto +6 <LBB13_211>
    2189:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (!map_lookup_elem(&LB_AFFINITY_MATCH_MAP, &match)) {
    2190:	07 02 00 00 d8 ff ff ff	r2 += -40
    2191:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2193:	85 00 00 00 01 00 00 00	call 1
    2194:	55 00 07 00 00 00 00 00	if r0 != 0 goto +7 <LBB13_212>

0000000000004498 <LBB13_211>:
    2195:	bf a2 00 00 00 00 00 00	r2 = r10
    2196:	07 02 00 00 a0 ff ff ff	r2 += -96
    2197:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2199:	85 00 00 00 03 00 00 00	call 3
    2200:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    2201:	05 00 1a 00 00 00 00 00	goto +26 <LBB13_213>

00000000000044d0 <LBB13_212>:
    2202:	b7 01 00 00 00 00 00 00	r1 = 0
; 		WRITE_ONCE(val->last_used, now);
    2203:	73 19 07 00 00 00 00 00	*(u8 *)(r9 + 7) = r1
    2204:	73 19 06 00 00 00 00 00	*(u8 *)(r9 + 6) = r1
    2205:	73 19 05 00 00 00 00 00	*(u8 *)(r9 + 5) = r1
    2206:	73 19 04 00 00 00 00 00	*(u8 *)(r9 + 4) = r1
    2207:	bf 71 00 00 00 00 00 00	r1 = r7
    2208:	77 01 00 00 18 00 00 00	r1 >>= 24
    2209:	73 19 03 00 00 00 00 00	*(u8 *)(r9 + 3) = r1
    2210:	bf 71 00 00 00 00 00 00	r1 = r7
    2211:	77 01 00 00 10 00 00 00	r1 >>= 16
    2212:	73 19 02 00 00 00 00 00	*(u8 *)(r9 + 2) = r1
    2213:	73 79 00 00 00 00 00 00	*(u8 *)(r9 + 0) = r7
    2214:	77 07 00 00 08 00 00 00	r7 >>= 8
    2215:	73 79 01 00 00 00 00 00	*(u8 *)(r9 + 1) = r7
; 		return val->backend_id;
    2216:	71 91 09 00 00 00 00 00	r1 = *(u8 *)(r9 + 9)
    2217:	67 01 00 00 08 00 00 00	r1 <<= 8
    2218:	71 92 08 00 00 00 00 00	r2 = *(u8 *)(r9 + 8)
    2219:	4f 21 00 00 00 00 00 00	r1 |= r2
    2220:	71 92 0a 00 00 00 00 00	r2 = *(u8 *)(r9 + 10)
    2221:	71 96 0b 00 00 00 00 00	r6 = *(u8 *)(r9 + 11)
    2222:	67 06 00 00 08 00 00 00	r6 <<= 8
    2223:	4f 26 00 00 00 00 00 00	r6 |= r2
    2224:	67 06 00 00 10 00 00 00	r6 <<= 16
    2225:	4f 16 00 00 00 00 00 00	r6 |= r1
    2226:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
; 		if (!backend_id) {
    2227:	55 06 14 00 00 00 00 00	if r6 != 0 goto +20 <LBB13_215>

00000000000045a0 <LBB13_213>:
; 	__u32 slot = (get_prandom_u32() % svc->count) + 1;
    2228:	85 00 00 00 07 00 00 00	call 7
    2229:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
    2230:	69 11 04 00 00 00 00 00	r1 = *(u16 *)(r1 + 4)
    2231:	bf 02 00 00 00 00 00 00	r2 = r0
    2232:	67 02 00 00 20 00 00 00	r2 <<= 32
    2233:	77 02 00 00 20 00 00 00	r2 >>= 32
    2234:	3f 12 00 00 00 00 00 00	r2 /= r1
    2235:	2f 12 00 00 00 00 00 00	r2 *= r1
    2236:	1f 20 00 00 00 00 00 00	r0 -= r2
; 	struct lb4_service *be = lb4_lookup_backend_slot(ctx, key, slot);
    2237:	07 00 00 00 01 00 00 00	r0 += 1
; 	key->backend_slot = slot;
    2238:	6b 0a 4e ff 00 00 00 00	*(u16 *)(r10 - 178) = r0
    2239:	bf a2 00 00 00 00 00 00	r2 = r10
    2240:	07 02 00 00 48 ff ff ff	r2 += -184
; 	return map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
    2241:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2243:	85 00 00 00 01 00 00 00	call 1
; 	return be ? be->backend_id : 0;
    2244:	15 00 14 f9 00 00 00 00	if r0 == 0 goto -1772 <LBB13_83>
    2245:	61 06 00 00 00 00 00 00	r6 = *(u32 *)(r0 + 0)
    2246:	57 06 00 00 ff ff 00 00	r6 &= 65535
; 			if (!backend_id)
    2247:	15 06 11 f9 00 00 00 00	if r6 == 0 goto -1775 <LBB13_83>

0000000000004640 <LBB13_215>:
    2248:	bf a2 00 00 00 00 00 00	r2 = r10
    2249:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    2250:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2251:	85 00 00 00 01 00 00 00	call 1
; 	if (!entry)
    2252:	15 00 03 00 00 00 00 00	if r0 == 0 goto +3 <LBB13_217>
; 	entry->backend_id = state->backend_id;
    2253:	bf 61 00 00 00 00 00 00	r1 = r6
    2254:	57 01 00 00 ff ff 00 00	r1 &= 65535
    2255:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1

0000000000004680 <LBB13_217>:
    2256:	7b 6a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r6
; 		state->rev_nat_index = svc->rev_nat_index;
    2257:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
    2258:	69 16 06 00 00 00 00 00	r6 = *(u16 *)(r1 + 6)
    2259:	bf a2 00 00 00 00 00 00	r2 = r10
; 		state->rev_nat_index = svc->rev_nat_index;
    2260:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    2261:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2262:	85 00 00 00 01 00 00 00	call 1
; 	if (!entry)
    2263:	15 00 01 00 00 00 00 00	if r0 == 0 goto +1 <LBB13_219>
; 	entry->rev_nat_index = state->rev_nat_index;
    2264:	6b 60 26 00 00 00 00 00	*(u16 *)(r0 + 38) = r6

00000000000046c8 <LBB13_219>:
    2265:	79 a6 f0 fe 00 00 00 00	r6 = *(u64 *)(r10 - 272)
    2266:	6b 6a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r6
    2267:	bf a2 00 00 00 00 00 00	r2 = r10
    2268:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(&LB4_BACKEND_MAP, &backend_id);
    2269:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2271:	85 00 00 00 01 00 00 00	call 1
    2272:	bf 05 00 00 00 00 00 00	r5 = r0
; 	if (!backend) {
    2273:	55 05 f1 f9 00 00 00 00	if r5 != 0 goto -1551 <LBB13_243>
    2274:	b7 01 00 00 00 00 00 00	r1 = 0
; 	key->backend_slot = 0;
    2275:	6b 1a 4e ff 00 00 00 00	*(u16 *)(r10 - 178) = r1
; 	key->scope = LB_LOOKUP_SCOPE_EXT;
    2276:	73 1a 51 ff 00 00 00 00	*(u8 *)(r10 - 175) = r1
    2277:	bf a2 00 00 00 00 00 00	r2 = r10
    2278:	07 02 00 00 48 ff ff ff	r2 += -184
; 	svc = map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
    2279:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2281:	85 00 00 00 01 00 00 00	call 1
    2282:	7b 0a 10 ff 00 00 00 00	*(u64 *)(r10 - 240) = r0
; 	if (svc) {
    2283:	15 00 ed f8 00 00 00 00	if r0 == 0 goto -1811 <LBB13_83>
; 			return svc->count ? svc : NULL;
    2284:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
    2285:	69 11 04 00 00 00 00 00	r1 = *(u16 *)(r1 + 4)
    2286:	15 01 ea f8 00 00 00 00	if r1 == 0 goto -1814 <LBB13_83>
; 	__u32 slot = (get_prandom_u32() % svc->count) + 1;
    2287:	85 00 00 00 07 00 00 00	call 7
    2288:	79 a1 10 ff 00 00 00 00	r1 = *(u64 *)(r10 - 240)
    2289:	69 11 04 00 00 00 00 00	r1 = *(u16 *)(r1 + 4)
    2290:	bf 02 00 00 00 00 00 00	r2 = r0
    2291:	67 02 00 00 20 00 00 00	r2 <<= 32
    2292:	77 02 00 00 20 00 00 00	r2 >>= 32
    2293:	3f 12 00 00 00 00 00 00	r2 /= r1
    2294:	2f 12 00 00 00 00 00 00	r2 *= r1
    2295:	1f 20 00 00 00 00 00 00	r0 -= r2
; 	struct lb4_service *be = lb4_lookup_backend_slot(ctx, key, slot);
    2296:	07 00 00 00 01 00 00 00	r0 += 1
; 	key->backend_slot = slot;
    2297:	6b 0a 4e ff 00 00 00 00	*(u16 *)(r10 - 178) = r0
    2298:	bf a2 00 00 00 00 00 00	r2 = r10
    2299:	07 02 00 00 48 ff ff ff	r2 += -184
; 	return map_lookup_elem(&LB4_SERVICES_MAP_V2, key);
    2300:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2302:	85 00 00 00 01 00 00 00	call 1
    2303:	b7 06 00 00 00 00 00 00	r6 = 0
; 	return be ? be->backend_id : 0;
    2304:	15 00 01 00 00 00 00 00	if r0 == 0 goto +1 <LBB13_224>
    2305:	61 06 00 00 00 00 00 00	r6 = *(u32 *)(r0 + 0)

0000000000004810 <LBB13_224>:
    2306:	6b 6a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r6
    2307:	bf a2 00 00 00 00 00 00	r2 = r10
    2308:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(&LB4_BACKEND_MAP, &backend_id);
    2309:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2311:	85 00 00 00 01 00 00 00	call 1
; 		if (!backend)
    2312:	15 00 d0 f8 00 00 00 00	if r0 == 0 goto -1840 <LBB13_83>
    2313:	bf a2 00 00 00 00 00 00	r2 = r10
    2314:	07 02 00 00 80 ff ff ff	r2 += -128
; 	entry = map_lookup_elem(map, tuple);
    2315:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2316:	bf 07 00 00 00 00 00 00	r7 = r0
    2317:	85 00 00 00 01 00 00 00	call 1
    2318:	bf 75 00 00 00 00 00 00	r5 = r7
; 	if (!entry)
    2319:	15 00 c3 f9 00 00 00 00	if r0 == 0 goto -1597 <LBB13_243>
; 	entry->backend_id = state->backend_id;
    2320:	bf 61 00 00 00 00 00 00	r1 = r6
    2321:	57 01 00 00 ff ff 00 00	r1 &= 65535
    2322:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    2323:	05 00 bf f9 00 00 00 00	goto -1601 <LBB13_243>

00000000000048a0 <LBB13_295>:
; 	return ctx->len;
    2324:	61 48 00 00 00 00 00 00	r8 = *(u32 *)(r4 + 0)
; 	struct metrics_value *entry, newEntry = {};
    2325:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    2326:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    2327:	b7 01 00 00 09 03 00 00	r1 = 777
; 	struct metrics_key key = {};
    2328:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
    2329:	bf a2 00 00 00 00 00 00	r2 = r10
    2330:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    2331:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2333:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    2334:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_299>
; 		entry->count += 1;
    2335:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    2336:	07 01 00 00 01 00 00 00	r1 += 1
    2337:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    2338:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    2339:	0f 81 00 00 00 00 00 00	r1 += r8
    2340:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    2341:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_300>

0000000000004930 <LBB13_299>:
; 		newEntry.bytes = bytes;
    2342:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    2343:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    2344:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    2345:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    2346:	07 02 00 00 f8 ff ff ff	r2 += -8
    2347:	bf a3 00 00 00 00 00 00	r3 = r10
    2348:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    2349:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2351:	b7 04 00 00 00 00 00 00	r4 = 0
    2352:	85 00 00 00 02 00 00 00	call 2

0000000000004988 <LBB13_300>:
; 	return ip4->frag_off & bpf_htons(0x1FFF);
    2353:	69 61 14 00 00 00 00 00	r1 = *(u16 *)(r6 + 20)
    2354:	57 01 00 00 1f ff 00 00	r1 &= 65311
; 		if (likely(not_first_fragment))
    2355:	15 01 0d 00 00 00 00 00	if r1 == 0 goto +13 <LBB13_327>
    2356:	bf a2 00 00 00 00 00 00	r2 = r10
    2357:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	tmp = map_lookup_elem(&IPV4_FRAG_DATAGRAMS_MAP, frag_id);
    2358:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2360:	85 00 00 00 01 00 00 00	call 1
; 	if (!tmp)
    2361:	55 00 03 00 00 00 00 00	if r0 != 0 goto +3 <LBB13_307>

00000000000049d0 <LBB13_302>:
    2362:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    2363:	79 a9 30 ff 00 00 00 00	r9 = *(u64 *)(r10 - 208)
    2364:	05 00 9c f8 00 00 00 00	goto -1892 <LBB13_83>

00000000000049e8 <LBB13_307>:
    2365:	61 01 00 00 00 00 00 00	r1 = *(u32 *)(r0 + 0)
    2366:	63 1a 88 ff 00 00 00 00	*(u32 *)(r10 - 120) = r1

00000000000049f8 <LBB13_308>:
    2367:	b7 06 00 00 01 00 00 00	r6 = 1
    2368:	05 00 60 fe 00 00 00 00	goto -416 <LBB13_180>

0000000000004a08 <LBB13_327>:
; 	ret = ctx_load_bytes(ctx, l4_off, ports, 4);
    2369:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2370:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    2371:	bf 73 00 00 00 00 00 00	r3 = r7
    2372:	b7 04 00 00 04 00 00 00	r4 = 4
    2373:	85 00 00 00 1a 00 00 00	call 26
    2374:	67 00 00 00 20 00 00 00	r0 <<= 32
    2375:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (ret < 0)
    2376:	c5 00 64 f8 00 00 00 00	if r0 s< 0 goto -1948 <LBB13_75>
    2377:	bf a2 00 00 00 00 00 00	r2 = r10
; 		if (map_update_elem(&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))
    2378:	07 02 00 00 d8 ff ff ff	r2 += -40
    2379:	b7 09 00 00 00 00 00 00	r9 = 0
    2380:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2382:	bf 73 00 00 00 00 00 00	r3 = r7
    2383:	b7 04 00 00 00 00 00 00	r4 = 0
    2384:	85 00 00 00 02 00 00 00	call 2
    2385:	67 00 00 00 20 00 00 00	r0 <<= 32
    2386:	77 00 00 00 20 00 00 00	r0 >>= 32
    2387:	15 00 3c fe 00 00 00 00	if r0 == 0 goto -452 <LBB13_69>
; 	return ctx->len;
    2388:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2389:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    2390:	7b 9a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r9
    2391:	7b 9a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r9
    2392:	b7 01 00 00 0a 03 00 00	r1 = 778
; 	struct metrics_key key = {};
    2393:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
    2394:	bf a2 00 00 00 00 00 00	r2 = r10
    2395:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    2396:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2398:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    2399:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_338>
; 		entry->count += 1;
    2400:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    2401:	07 01 00 00 01 00 00 00	r1 += 1
    2402:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    2403:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    2404:	0f 61 00 00 00 00 00 00	r1 += r6
    2405:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    2406:	05 00 29 fe 00 00 00 00	goto -471 <LBB13_69>

0000000000004b38 <LBB13_338>:
; 		newEntry.bytes = bytes;
    2407:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    2408:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    2409:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    2410:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    2411:	07 02 00 00 f8 ff ff ff	r2 += -8
    2412:	bf a3 00 00 00 00 00 00	r3 = r10
    2413:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    2414:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2416:	b7 04 00 00 00 00 00 00	r4 = 0
    2417:	85 00 00 00 02 00 00 00	call 2
    2418:	05 00 1d fe 00 00 00 00	goto -483 <LBB13_69>

0000000000004b98 <LBB13_324>:
; 	key.protocol = 0;
    2419:	73 6a a6 ff 00 00 00 00	*(u8 *)(r10 - 90) = r6
; 	key.dport = 0;
    2420:	6b 6a a4 ff 00 00 00 00	*(u16 *)(r10 - 92) = r6
; 		key.sec_label = remoteID;
    2421:	79 a1 30 ff 00 00 00 00	r1 = *(u64 *)(r10 - 208)
    2422:	63 1a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r1
    2423:	bf a2 00 00 00 00 00 00	r2 = r10
; 	key.protocol = 0;
    2424:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	policy = map_lookup_elem(map, &key);
    2425:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2427:	85 00 00 00 01 00 00 00	call 1
; 	if (likely(policy)) {
    2428:	15 00 10 00 00 00 00 00	if r0 == 0 goto +16 <LBB13_340>
    2429:	b7 06 00 00 01 00 00 00	r6 = 1
; 	__sync_fetch_and_add(&policy->packets, 1);
    2430:	b7 01 00 00 01 00 00 00	r1 = 1
    2431:	db 10 08 00 00 00 00 00	lock *(u64 *)(r0 + 8) += r1
    2432:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    2433:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
; 	__sync_fetch_and_add(&policy->bytes, ctx_full_len(ctx));
    2434:	db 10 10 00 00 00 00 00	lock *(u64 *)(r0 + 16) += r1
    2435:	18 01 00 00 4b ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967115 ll
; 		if (unlikely(policy->deny))
    2437:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    2438:	b7 00 00 00 00 00 00 00	r0 = 0
    2439:	57 02 00 00 01 00 00 00	r2 &= 1
    2440:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    2441:	15 02 21 00 00 00 00 00	if r2 == 0 goto +33 <LBB13_343>

0000000000004c50 <LBB13_326>:
    2442:	bf 10 00 00 00 00 00 00	r0 = r1
    2443:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2444:	05 00 09 fd 00 00 00 00	goto -759 <LBB13_161>

0000000000004c68 <LBB13_340>:
    2445:	b7 01 00 00 00 00 00 00	r1 = 0
; 	key.sec_label = 0;
    2446:	63 1a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r1
    2447:	bf a2 00 00 00 00 00 00	r2 = r10
    2448:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	policy = map_lookup_elem(map, &key);
    2449:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2451:	85 00 00 00 01 00 00 00	call 1
; 	if (policy) {
    2452:	15 00 0e 00 00 00 00 00	if r0 == 0 goto +14 <LBB13_342>
    2453:	b7 01 00 00 01 00 00 00	r1 = 1
; 	__sync_fetch_and_add(&policy->packets, 1);
    2454:	db 10 08 00 00 00 00 00	lock *(u64 *)(r0 + 8) += r1
    2455:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    2456:	61 11 00 00 00 00 00 00	r1 = *(u32 *)(r1 + 0)
; 	__sync_fetch_and_add(&policy->bytes, ctx_full_len(ctx));
    2457:	db 10 10 00 00 00 00 00	lock *(u64 *)(r0 + 16) += r1
    2458:	18 01 00 00 4b ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967115 ll
    2460:	b7 06 00 00 04 00 00 00	r6 = 4
; 		if (unlikely(policy->deny))
    2461:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    2462:	57 02 00 00 01 00 00 00	r2 &= 1
    2463:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    2464:	b7 00 00 00 00 00 00 00	r0 = 0
    2465:	15 02 09 00 00 00 00 00	if r2 == 0 goto +9 <LBB13_343>
    2466:	05 00 e7 ff 00 00 00 00	goto -25 <LBB13_326>

0000000000004d18 <LBB13_342>:
    2467:	18 01 00 00 7b ff ff ff 00 00 00 00 00 00 00 00	r1 = 4294967163 ll
    2469:	b7 06 00 00 00 00 00 00	r6 = 0
    2470:	79 a2 40 ff 00 00 00 00	r2 = *(u64 *)(r10 - 192)
; 	return ctx->cb[off];
    2471:	61 22 38 00 00 00 00 00	r2 = *(u32 *)(r2 + 56)
    2472:	b7 00 00 00 00 00 00 00	r0 = 0
    2473:	79 a4 10 ff 00 00 00 00	r4 = *(u64 *)(r10 - 240)
    2474:	15 02 df ff 00 00 00 00	if r2 == 0 goto -33 <LBB13_326>

0000000000004d58 <LBB13_343>:
    2475:	57 00 00 00 ff ff 00 00	r0 &= 65535
    2476:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)

0000000000004d68 <LBB13_344>:
    2477:	18 08 00 00 5d ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967133 ll
    2479:	79 a7 f8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 264)
; 	switch (ret) {
    2480:	bf 71 00 00 00 00 00 00	r1 = r7
    2481:	67 01 00 00 20 00 00 00	r1 <<= 32
    2482:	77 01 00 00 20 00 00 00	r1 >>= 32
    2483:	65 01 03 00 01 00 00 00	if r1 s> 1 goto +3 <LBB13_347>
    2484:	15 01 8f 00 00 00 00 00	if r1 == 0 goto +143 <LBB13_369>
    2485:	15 01 3c 00 01 00 00 00	if r1 == 1 goto +60 <LBB13_355>
    2486:	05 00 29 f8 00 00 00 00	goto -2007 <LBB13_87>

0000000000004db8 <LBB13_347>:
    2487:	bf 12 00 00 00 00 00 00	r2 = r1
    2488:	07 02 00 00 fe ff ff ff	r2 += -2
    2489:	a5 02 3d 00 02 00 00 00	if r2 < 2 goto +61 <LBB13_356>
    2490:	15 01 01 00 04 00 00 00	if r1 == 4 goto +1 <LBB13_349>
    2491:	05 00 24 f8 00 00 00 00	goto -2012 <LBB13_87>

0000000000004de0 <LBB13_349>:
; 		if (!hairpin_flow)
    2492:	57 04 00 00 01 00 00 00	r4 &= 1
    2493:	55 04 34 00 00 00 00 00	if r4 != 0 goto +52 <LBB13_355>
; 	return ctx->len;
    2494:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2495:	61 17 00 00 00 00 00 00	r7 = *(u32 *)(r1 + 0)
; 						   tuple.nexthdr, POLICY_EGRESS, 0,
    2496:	71 a4 8c ff 00 00 00 00	r4 = *(u8 *)(r10 - 116)
; 			send_policy_verdict_notify(ctx, *dstID, tuple.dport,
    2497:	69 a2 88 ff 00 00 00 00	r2 = *(u16 *)(r10 - 120)
    2498:	b7 03 00 00 02 00 00 00	r3 = 2
; 	volatile __u8 d = dir;
    2499:	73 3a a0 ff 00 00 00 00	*(u8 *)(r10 - 96) = r3
; 	return ((filter & d) > 0);
    2500:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
    2502:	71 a5 a0 ff 00 00 00 00	r5 = *(u8 *)(r10 - 96)
    2503:	5f 35 00 00 00 00 00 00	r5 &= r3
; 	__u64 cap_len = min_t(__u64, TRACE_PAYLOAD_LEN, ctx_len);
    2504:	bf 73 00 00 00 00 00 00	r3 = r7
    2505:	a5 07 01 00 80 00 00 00	if r7 < 128 goto +1 <LBB13_352>
    2506:	b7 03 00 00 80 00 00 00	r3 = 128

0000000000004e58 <LBB13_352>:
; 	if (!policy_verdict_filter_allow(POLICY_VERDICT_LOG_FILTER, dir))
    2507:	15 05 23 00 00 00 00 00	if r5 == 0 goto +35 <LBB13_354>
    2508:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    2509:	61 15 44 00 00 00 00 00	r5 = *(u32 *)(r1 + 68)
    2510:	bf 08 00 00 00 00 00 00	r8 = r0
    2511:	b7 00 00 00 00 00 00 00	r0 = 0
; 	msg = (typeof(msg)) {
    2512:	63 0a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r0
    2513:	73 4a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r4
    2514:	dc 02 00 00 10 00 00 00	r2 = be16 r2
    2515:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
    2516:	63 8a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r8
    2517:	79 a2 30 ff 00 00 00 00	r2 = *(u64 *)(r10 - 208)
    2518:	63 2a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r2
    2519:	b7 02 00 00 01 00 00 00	r2 = 1
    2520:	6b 2a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r2
    2521:	63 7a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r7
    2522:	63 5a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r5
    2523:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2525:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    2526:	b7 02 00 00 05 00 00 00	r2 = 5
    2527:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    2528:	67 06 00 00 03 00 00 00	r6 <<= 3
    2529:	47 06 00 00 02 00 00 00	r6 |= 2
    2530:	73 6a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r6
    2531:	6b 3a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r3
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    2532:	67 03 00 00 20 00 00 00	r3 <<= 32
    2533:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    2535:	4f 23 00 00 00 00 00 00	r3 |= r2
    2536:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    2537:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    2538:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2540:	b7 05 00 00 20 00 00 00	r5 = 32
    2541:	85 00 00 00 19 00 00 00	call 25
    2542:	bf 80 00 00 00 00 00 00	r0 = r8

0000000000004f78 <LBB13_354>:
    2543:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2544:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2545:	79 a7 f8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 264)

0000000000004f90 <LBB13_355>:
; 		if (unlikely(ct_state.rev_nat_index != ct_state_new.rev_nat_index))
    2546:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2547:	57 01 00 00 ff ff 00 00	r1 &= 65535
    2548:	69 a2 60 ff 00 00 00 00	r2 = *(u16 *)(r10 - 160)
    2549:	1d 12 b2 02 00 00 00 00	if r2 == r1 goto +690 <LBB13_473>
    2550:	05 00 80 00 00 00 00 00	goto +128 <LBB13_374>

0000000000004fb8 <LBB13_356>:
    2551:	b7 01 00 00 01 00 00 00	r1 = 1
    2552:	79 a3 40 ff 00 00 00 00	r3 = *(u64 *)(r10 - 192)
; 	ctx->cb[off] = data;
    2553:	63 13 38 00 00 00 00 00	*(u32 *)(r3 + 56) = r1
; 		if (ct_state.node_port) {
    2554:	69 a1 62 ff 00 00 00 00	r1 = *(u16 *)(r10 - 158)
    2555:	bf 12 00 00 00 00 00 00	r2 = r1
    2556:	57 02 00 00 02 00 00 00	r2 &= 2
    2557:	15 02 0f 00 00 00 00 00	if r2 == 0 goto +15 <LBB13_358>
; 			ctx->tc_index |= TC_INDEX_F_SKIP_RECIRCULATION;
    2558:	61 31 2c 00 00 00 00 00	r1 = *(u32 *)(r3 + 44)
    2559:	47 01 00 00 08 00 00 00	r1 |= 8
    2560:	63 13 2c 00 00 00 00 00	*(u32 *)(r3 + 44) = r1
; 	asm volatile("r1 = %[ctx]\n\t"
    2561:	18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r6 = 0 ll
    2563:	79 a7 40 ff 00 00 00 00	r7 = *(u64 *)(r10 - 192)
    2564:	bf 71 00 00 00 00 00 00	r1 = r7
    2565:	bf 62 00 00 00 00 00 00	r2 = r6
    2566:	b7 03 00 00 11 00 00 00	r3 = 17
    2567:	85 00 00 00 0c 00 00 00	call 12
    2568:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2569:	18 08 00 00 74 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967156 ll
    2571:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2572:	05 00 d3 f7 00 00 00 00	goto -2093 <LBB13_87>

0000000000005068 <LBB13_358>:
; 		if (ct_state.dsr) {
    2573:	57 01 00 00 08 00 00 00	r1 &= 8
    2574:	7b 0a d0 fe 00 00 00 00	*(u64 *)(r10 - 304) = r0
    2575:	15 01 98 01 00 00 00 00	if r1 == 0 goto +408 <LBB13_422>
; 	struct ipv4_ct_tuple nat_tup = *tuple;
    2576:	61 a1 88 ff 00 00 00 00	r1 = *(u32 *)(r10 - 120)
    2577:	63 1a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r1
    2578:	71 a1 8c ff 00 00 00 00	r1 = *(u8 *)(r10 - 116)
    2579:	73 1a ac ff 00 00 00 00	*(u8 *)(r10 - 84) = r1
    2580:	79 a1 80 ff 00 00 00 00	r1 = *(u64 *)(r10 - 128)
    2581:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    2582:	b7 01 00 00 00 00 00 00	r1 = 0
; 	nat_tup.flags = NAT_DIR_EGRESS;
    2583:	73 1a ad ff 00 00 00 00	*(u8 *)(r10 - 83) = r1
; 	nat_tup.sport = tuple->dport;
    2584:	69 a1 88 ff 00 00 00 00	r1 = *(u16 *)(r10 - 120)
    2585:	6b 1a aa ff 00 00 00 00	*(u16 *)(r10 - 86) = r1
; 	nat_tup.dport = tuple->sport;
    2586:	69 a1 8a ff 00 00 00 00	r1 = *(u16 *)(r10 - 118)
    2587:	6b 1a a8 ff 00 00 00 00	*(u16 *)(r10 - 88) = r1
    2588:	bf a2 00 00 00 00 00 00	r2 = r10
    2589:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(map, tuple);
    2590:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2592:	85 00 00 00 01 00 00 00	call 1
    2593:	bf 06 00 00 00 00 00 00	r6 = r0
; 	if (entry)
    2594:	15 06 82 01 00 00 00 00	if r6 == 0 goto +386 <LBB13_421>
; 	if (state->to_saddr == tuple->saddr &&
    2595:	61 64 20 00 00 00 00 00	r4 = *(u32 *)(r6 + 32)
    2596:	61 a1 a4 ff 00 00 00 00	r1 = *(u32 *)(r10 - 92)
    2597:	5d 14 03 00 00 00 00 00	if r4 != r1 goto +3 <LBB13_362>
; 	    state->to_sport == tuple->sport)
    2598:	69 62 24 00 00 00 00 00	r2 = *(u16 *)(r6 + 36)
    2599:	69 a3 aa ff 00 00 00 00	r3 = *(u16 *)(r10 - 86)
; 	if (state->to_saddr == tuple->saddr &&
    2600:	1d 32 7c 01 00 00 00 00	if r2 == r3 goto +380 <LBB13_421>

0000000000005148 <LBB13_362>:
    2601:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
    2603:	af 21 00 00 00 00 00 00	r1 ^= r2
    2604:	0f 14 00 00 00 00 00 00	r4 += r1
    2605:	bf 41 00 00 00 00 00 00	r1 = r4
    2606:	67 01 00 00 20 00 00 00	r1 <<= 32
    2607:	77 01 00 00 20 00 00 00	r1 >>= 32
    2608:	b7 07 00 00 00 00 00 00	r7 = 0
    2609:	b7 02 00 00 01 00 00 00	r2 = 1
    2610:	7b 4a 10 ff 00 00 00 00	*(u64 *)(r10 - 240) = r4
    2611:	5d 41 01 00 00 00 00 00	if r1 != r4 goto +1 <LBB13_364>
    2612:	b7 02 00 00 00 00 00 00	r2 = 0

00000000000051a8 <LBB13_364>:
    2613:	7b 2a 08 ff 00 00 00 00	*(u64 *)(r10 - 248) = r2
; 	return ip4->frag_off & bpf_htons(0x1FFF);
    2614:	79 a2 18 ff 00 00 00 00	r2 = *(u64 *)(r10 - 232)
    2615:	57 02 00 00 ff ff 00 00	r2 &= 65535
; 	struct csum_offset csum = {};
    2616:	b7 05 00 00 00 00 00 00	r5 = 0
; 	__be32 sum_l4 = 0, sum;
    2617:	b7 08 00 00 00 00 00 00	r8 = 0
    2618:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	if (has_l4_header) {
    2619:	55 02 39 01 00 00 00 00	if r2 != 0 goto +313 <LBB13_414>
    2620:	b7 05 00 00 00 00 00 00	r5 = 0
; 		csum_l4_offset_and_flags(tuple->nexthdr, &csum);
    2621:	71 a2 ac ff 00 00 00 00	r2 = *(u8 *)(r10 - 84)
; 	switch (nexthdr) {
    2622:	15 02 f0 00 3a 00 00 00	if r2 == 58 goto +240 <LBB13_401>
    2623:	15 02 ec 00 11 00 00 00	if r2 == 17 goto +236 <LBB13_400>
    2624:	b7 07 00 00 00 00 00 00	r7 = 0
; 	switch (nexthdr) {
    2625:	55 02 ee 00 06 00 00 00	if r2 != 6 goto +238 <LBB13_402>
    2626:	b7 07 00 00 10 00 00 00	r7 = 16
    2627:	05 00 ec 00 00 00 00 00	goto +236 <LBB13_402>

0000000000005220 <LBB13_369>:
; 		if (!hairpin_flow)
    2628:	57 04 00 00 01 00 00 00	r4 &= 1
    2629:	55 04 31 00 00 00 00 00	if r4 != 0 goto +49 <LBB13_374>
; 	return ctx->len;
    2630:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2631:	61 17 00 00 00 00 00 00	r7 = *(u32 *)(r1 + 0)
; 						   tuple.nexthdr, POLICY_EGRESS, 0,
    2632:	71 a4 8c ff 00 00 00 00	r4 = *(u8 *)(r10 - 116)
; 			send_policy_verdict_notify(ctx, *dstID, tuple.dport,
    2633:	69 a2 88 ff 00 00 00 00	r2 = *(u16 *)(r10 - 120)
    2634:	b7 03 00 00 02 00 00 00	r3 = 2
; 	volatile __u8 d = dir;
    2635:	73 3a a0 ff 00 00 00 00	*(u8 *)(r10 - 96) = r3
; 	return ((filter & d) > 0);
    2636:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
    2638:	71 a5 a0 ff 00 00 00 00	r5 = *(u8 *)(r10 - 96)
    2639:	5f 35 00 00 00 00 00 00	r5 &= r3
; 	__u64 cap_len = min_t(__u64, TRACE_PAYLOAD_LEN, ctx_len);
    2640:	bf 73 00 00 00 00 00 00	r3 = r7
    2641:	a5 07 01 00 80 00 00 00	if r7 < 128 goto +1 <LBB13_372>
    2642:	b7 03 00 00 80 00 00 00	r3 = 128

0000000000005298 <LBB13_372>:
; 	if (!policy_verdict_filter_allow(POLICY_VERDICT_LOG_FILTER, dir))
    2643:	15 05 23 00 00 00 00 00	if r5 == 0 goto +35 <LBB13_374>
    2644:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    2645:	61 15 44 00 00 00 00 00	r5 = *(u32 *)(r1 + 68)
    2646:	bf 08 00 00 00 00 00 00	r8 = r0
    2647:	b7 00 00 00 00 00 00 00	r0 = 0
; 	msg = (typeof(msg)) {
    2648:	63 0a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r0
    2649:	73 4a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r4
    2650:	dc 02 00 00 10 00 00 00	r2 = be16 r2
    2651:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
    2652:	63 8a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r8
    2653:	79 a2 30 ff 00 00 00 00	r2 = *(u64 *)(r10 - 208)
    2654:	63 2a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r2
    2655:	b7 02 00 00 01 00 00 00	r2 = 1
    2656:	6b 2a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r2
    2657:	63 7a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r7
    2658:	63 5a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r5
    2659:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2661:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    2662:	b7 02 00 00 05 00 00 00	r2 = 5
    2663:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    2664:	67 06 00 00 03 00 00 00	r6 <<= 3
    2665:	47 06 00 00 02 00 00 00	r6 |= 2
    2666:	73 6a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r6
    2667:	6b 3a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r3
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    2668:	67 03 00 00 20 00 00 00	r3 <<= 32
    2669:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    2671:	4f 23 00 00 00 00 00 00	r3 |= r2
    2672:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_POLICY_VERDICT, 0),
    2673:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    2674:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2676:	b7 05 00 00 20 00 00 00	r5 = 32
    2677:	85 00 00 00 19 00 00 00	call 25
    2678:	bf 80 00 00 00 00 00 00	r0 = r8

00000000000053b8 <LBB13_374>:
    2679:	7b 0a d0 fe 00 00 00 00	*(u64 *)(r10 - 304) = r0
    2680:	79 a8 d8 fe 00 00 00 00	r8 = *(u64 *)(r10 - 296)
; 	entry.lb_loopback = ct_state->loopback;
    2681:	bf 81 00 00 00 00 00 00	r1 = r8
    2682:	67 01 00 00 03 00 00 00	r1 <<= 3
    2683:	57 01 00 00 08 00 00 00	r1 &= 8
; 	entry.node_port = ct_state->node_port;
    2684:	67 08 00 00 04 00 00 00	r8 <<= 4
    2685:	bf 86 00 00 00 00 00 00	r6 = r8
    2686:	57 06 00 00 20 00 00 00	r6 &= 32
; 	entry.lb_loopback = ct_state->loopback;
    2687:	4f 16 00 00 00 00 00 00	r6 |= r1
; 	if (tuple->nexthdr == IPPROTO_TCP)
    2688:	71 a7 8c ff 00 00 00 00	r7 = *(u8 *)(r10 - 116)
    2689:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct ct_entry entry = { };
    2690:	7b 1a d0 ff 00 00 00 00	*(u64 *)(r10 - 48) = r1
    2691:	7b 1a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r1
    2692:	7b 1a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r1
    2693:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
    2694:	7b 1a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r1
    2695:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    2696:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
;        volatile int __maybe_unused id = get_smp_processor_id();
    2697:	85 00 00 00 08 00 00 00	call 8
    2698:	bf 73 00 00 00 00 00 00	r3 = r7
;        volatile int __maybe_unused id = get_smp_processor_id();
    2699:	63 0a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r0
; 		ret = ct_create4(get_ct_map4(&tuple), &CT_MAP_ANY4, &tuple, ctx,
    2700:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2702:	7b 1a 38 ff 00 00 00 00	*(u64 *)(r10 - 200) = r1
    2703:	15 03 03 00 06 00 00 00	if r3 == 6 goto +3 <LBB13_376>
    2704:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2706:	7b 1a 38 ff 00 00 00 00	*(u64 *)(r10 - 200) = r1

0000000000005498 <LBB13_376>:
; 	entry.dsr = ct_state->dsr;
    2707:	57 08 00 00 80 00 00 00	r8 &= 128
; 	entry.node_port = ct_state->node_port;
    2708:	4f 86 00 00 00 00 00 00	r6 |= r8
; 	entry.ifindex = ct_state->ifindex;
    2709:	79 a1 00 ff 00 00 00 00	r1 = *(u64 *)(r10 - 256)
    2710:	6b 1a c8 ff 00 00 00 00	*(u16 *)(r10 - 56) = r1
; 	entry.rev_nat_index = ct_state->rev_nat_index;
    2711:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2712:	6b 1a c6 ff 00 00 00 00	*(u16 *)(r10 - 58) = r1
; 				 CT_EGRESS, &ct_state_new, verdict > 0);
    2713:	79 a2 d0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 304)
    2714:	67 02 00 00 20 00 00 00	r2 <<= 32
    2715:	c7 02 00 00 20 00 00 00	r2 s>>= 32
    2716:	b7 08 00 00 01 00 00 00	r8 = 1
    2717:	b7 01 00 00 01 00 00 00	r1 = 1
    2718:	65 02 01 00 00 00 00 00	if r2 s> 0 goto +1 <LBB13_378>
    2719:	b7 01 00 00 00 00 00 00	r1 = 0

0000000000005500 <LBB13_378>:
; 	entry.proxy_redirect = proxy_redirect;
    2720:	67 01 00 00 06 00 00 00	r1 <<= 6
; 	entry.dsr = ct_state->dsr;
    2721:	4f 16 00 00 00 00 00 00	r6 |= r1
; 	if (tuple->nexthdr == IPPROTO_TCP)
    2722:	15 03 01 00 06 00 00 00	if r3 == 6 goto +1 <LBB13_380>
    2723:	b7 08 00 00 00 00 00 00	r8 = 0

0000000000005520 <LBB13_380>:
    2724:	b7 07 00 00 3c 00 00 00	r7 = 60
    2725:	67 08 00 00 01 00 00 00	r8 <<= 1
; 	entry.dsr = ct_state->dsr;
    2726:	6b 6a c4 ff 00 00 00 00	*(u16 *)(r10 - 60) = r6
; 	if (tcp) {
    2727:	55 03 09 00 06 00 00 00	if r3 != 6 goto +9 <LBB13_384>
    2728:	bf 81 00 00 00 00 00 00	r1 = r8
    2729:	67 01 00 00 03 00 00 00	r1 <<= 3
; 		entry->seen_non_syn |= !syn;
    2730:	a7 01 00 00 10 00 00 00	r1 ^= 16
    2731:	57 01 00 00 f8 00 00 00	r1 &= 248
    2732:	b7 07 00 00 3c 00 00 00	r7 = 60
    2733:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_383>
    2734:	b7 07 00 00 60 54 00 00	r7 = 21600

0000000000005578 <LBB13_383>:
; 		entry->seen_non_syn |= !syn;
    2735:	4f 16 00 00 00 00 00 00	r6 |= r1
    2736:	6b 6a c4 ff 00 00 00 00	*(u16 *)(r10 - 60) = r6

0000000000005588 <LBB13_384>:
; 	__u32 now = bpf_mono_now();
    2737:	85 00 00 00 05 00 00 00	call 5
    2738:	37 00 00 00 00 ca 9a 3b	r0 /= 1000000000
; 	WRITE_ONCE(entry->lifetime, now + lifetime);
    2739:	0f 07 00 00 00 00 00 00	r7 += r0
    2740:	63 7a c0 ff 00 00 00 00	*(u32 *)(r10 - 64) = r7
; 		accumulated_flags = READ_ONCE(entry->tx_flags_seen);
    2741:	71 a3 ca ff 00 00 00 00	r3 = *(u8 *)(r10 - 54)
; 		last_report = READ_ONCE(entry->last_tx_report);
    2742:	61 a2 d0 ff 00 00 00 00	r2 = *(u32 *)(r10 - 48)
; 	seen_flags |= accumulated_flags;
    2743:	bf 31 00 00 00 00 00 00	r1 = r3
    2744:	4f 81 00 00 00 00 00 00	r1 |= r8
    2745:	bf 14 00 00 00 00 00 00	r4 = r1
    2746:	57 04 00 00 ff 00 00 00	r4 &= 255
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2747:	5d 43 07 00 00 00 00 00	if r3 != r4 goto +7 <LBB13_386>
    2748:	07 02 00 00 05 00 00 00	r2 += 5
    2749:	bf 03 00 00 00 00 00 00	r3 = r0
    2750:	67 03 00 00 20 00 00 00	r3 <<= 32
    2751:	77 03 00 00 20 00 00 00	r3 >>= 32
    2752:	67 02 00 00 20 00 00 00	r2 <<= 32
    2753:	77 02 00 00 20 00 00 00	r2 >>= 32
; 	if (last_report + bpf_sec_to_mono(CT_REPORT_INTERVAL) < now ||
    2754:	3d 32 02 00 00 00 00 00	if r2 >= r3 goto +2 <LBB13_387>

0000000000005618 <LBB13_386>:
; 			WRITE_ONCE(entry->tx_flags_seen, seen_flags);
    2755:	73 1a ca ff 00 00 00 00	*(u8 *)(r10 - 54) = r1
; 			WRITE_ONCE(entry->last_tx_report, now);
    2756:	63 0a d0 ff 00 00 00 00	*(u32 *)(r10 - 48) = r0

0000000000005628 <LBB13_387>:
    2757:	b7 06 00 00 01 00 00 00	r6 = 1
; 		entry.tx_packets = 1;
    2758:	7b 6a b0 ff 00 00 00 00	*(u64 *)(r10 - 80) = r6
    2759:	79 a7 40 ff 00 00 00 00	r7 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    2760:	61 71 00 00 00 00 00 00	r1 = *(u32 *)(r7 + 0)
; 	entry.src_sec_id = ct_state->src_sec_id;
    2761:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2763:	63 2a cc ff 00 00 00 00	*(u32 *)(r10 - 52) = r2
; 		entry.tx_bytes = ctx_full_len(ctx);
    2764:	7b 1a b8 ff 00 00 00 00	*(u64 *)(r10 - 72) = r1
    2765:	bf a2 00 00 00 00 00 00	r2 = r10
; 		entry.tx_packets = 1;
    2766:	07 02 00 00 80 ff ff ff	r2 += -128
    2767:	bf a3 00 00 00 00 00 00	r3 = r10
    2768:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	if (map_update_elem(map_main, tuple, &entry, 0) < 0) {
    2769:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
    2770:	b7 04 00 00 00 00 00 00	r4 = 0
    2771:	85 00 00 00 02 00 00 00	call 2
    2772:	67 00 00 00 20 00 00 00	r0 <<= 32
    2773:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2774:	65 00 05 00 ff ff ff ff	if r0 s> -1 goto +5 <LBB13_389>
; 	struct signal_msg msg = {
    2775:	7b 6a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r6
    2776:	bf a4 00 00 00 00 00 00	r4 = r10
    2777:	07 04 00 00 d8 ff ff ff	r4 += -40
; 	ctx_event_output(ctx, &SIGNAL_MAP, BPF_F_CURRENT_CPU,
    2778:	bf 71 00 00 00 00 00 00	r1 = r7
    2779:	05 00 41 00 00 00 00 00	goto +65 <LBB13_398>

00000000000056e0 <LBB13_389>:
    2780:	79 a2 f0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 272)
; 	if (ct_state->addr && ct_state->loopback) {
    2781:	bf 21 00 00 00 00 00 00	r1 = r2
    2782:	67 01 00 00 20 00 00 00	r1 <<= 32
    2783:	77 01 00 00 20 00 00 00	r1 >>= 32
    2784:	15 01 03 00 00 00 00 00	if r1 == 0 goto +3 <LBB13_391>
    2785:	79 a1 d8 fe 00 00 00 00	r1 = *(u64 *)(r10 - 296)
    2786:	57 01 00 00 01 00 00 00	r1 &= 1
; 	if (ct_state->addr && ct_state->loopback) {
    2787:	55 01 04 00 00 00 00 00	if r1 != 0 goto +4 <LBB13_392>

0000000000005720 <LBB13_391>:
; 			.flags = tuple->flags | TUPLE_F_RELATED,
    2788:	71 a6 8d ff 00 00 00 00	r6 = *(u8 *)(r10 - 115)
; 			.saddr = tuple->saddr,
    2789:	61 a7 84 ff 00 00 00 00	r7 = *(u32 *)(r10 - 124)
; 			.daddr = tuple->daddr,
    2790:	61 a8 80 ff 00 00 00 00	r8 = *(u32 *)(r10 - 128)
    2791:	05 00 1a 00 00 00 00 00	goto +26 <LBB13_395>

0000000000005740 <LBB13_392>:
; 		__u8 flags = tuple->flags;
    2792:	71 a6 8d ff 00 00 00 00	r6 = *(u8 *)(r10 - 115)
    2793:	b7 01 00 00 01 00 00 00	r1 = 1
; 		tuple->flags = TUPLE_F_IN;
    2794:	73 1a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r1
; 		saddr = tuple->saddr;
    2795:	61 a7 84 ff 00 00 00 00	r7 = *(u32 *)(r10 - 124)
; 			tuple->saddr = ct_state->svc_addr;
    2796:	79 a1 e8 fe 00 00 00 00	r1 = *(u64 *)(r10 - 280)
    2797:	63 1a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r1
; 		daddr = tuple->daddr;
    2798:	61 a8 80 ff 00 00 00 00	r8 = *(u32 *)(r10 - 128)
    2799:	63 2a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r2
    2800:	bf a2 00 00 00 00 00 00	r2 = r10
; 		__u8 flags = tuple->flags;
    2801:	07 02 00 00 80 ff ff ff	r2 += -128
    2802:	bf a3 00 00 00 00 00 00	r3 = r10
    2803:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		if (map_update_elem(map_main, tuple, &entry, 0) < 0) {
    2804:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
    2805:	b7 04 00 00 00 00 00 00	r4 = 0
    2806:	85 00 00 00 02 00 00 00	call 2
    2807:	67 00 00 00 20 00 00 00	r0 <<= 32
    2808:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2809:	65 00 05 00 ff ff ff ff	if r0 s> -1 goto +5 <LBB13_394>
; 	struct signal_msg msg = {
    2810:	b7 01 00 00 01 00 00 00	r1 = 1
    2811:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
    2812:	bf a4 00 00 00 00 00 00	r4 = r10
    2813:	07 04 00 00 d8 ff ff ff	r4 += -40
    2814:	05 00 1d 00 00 00 00 00	goto +29 <LBB13_397>

00000000000057f8 <LBB13_394>:
; 		tuple->flags = flags;
    2815:	73 6a 8d ff 00 00 00 00	*(u8 *)(r10 - 115) = r6
; 		tuple->daddr = daddr;
    2816:	63 8a 80 ff 00 00 00 00	*(u32 *)(r10 - 128) = r8
; 		tuple->saddr = saddr;
    2817:	63 7a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r7

0000000000005810 <LBB13_395>:
    2818:	b7 01 00 00 01 00 00 00	r1 = 1
; 		struct ipv4_ct_tuple icmp_tuple = {
    2819:	73 1a e4 ff 00 00 00 00	*(u8 *)(r10 - 28) = r1
    2820:	63 7a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r7
    2821:	63 8a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r8
; 			.flags = tuple->flags | TUPLE_F_RELATED,
    2822:	47 06 00 00 02 00 00 00	r6 |= 2
; 		struct ipv4_ct_tuple icmp_tuple = {
    2823:	73 6a e5 ff 00 00 00 00	*(u8 *)(r10 - 27) = r6
; 		entry.seen_non_syn = true; /* For ICMP, there is no SYN. */
    2824:	69 a1 c4 ff 00 00 00 00	r1 = *(u16 *)(r10 - 60)
    2825:	47 01 00 00 10 00 00 00	r1 |= 16
    2826:	6b 1a c4 ff 00 00 00 00	*(u16 *)(r10 - 60) = r1
    2827:	b7 01 00 00 00 00 00 00	r1 = 0
; 		struct ipv4_ct_tuple icmp_tuple = {
    2828:	63 1a e0 ff 00 00 00 00	*(u32 *)(r10 - 32) = r1
    2829:	bf a2 00 00 00 00 00 00	r2 = r10
    2830:	07 02 00 00 d8 ff ff ff	r2 += -40
    2831:	bf a3 00 00 00 00 00 00	r3 = r10
    2832:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		if (map_update_elem(map_related, &icmp_tuple, &entry, 0) < 0) {
    2833:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2835:	b7 04 00 00 00 00 00 00	r4 = 0
    2836:	85 00 00 00 02 00 00 00	call 2
    2837:	67 00 00 00 20 00 00 00	r0 <<= 32
    2838:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2839:	65 00 0f 00 ff ff ff ff	if r0 s> -1 goto +15 <LBB13_399>
; 	struct signal_msg msg = {
    2840:	b7 01 00 00 01 00 00 00	r1 = 1
    2841:	7b 1a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r1
    2842:	bf a4 00 00 00 00 00 00	r4 = r10
    2843:	07 04 00 00 48 ff ff ff	r4 += -184

00000000000058e0 <LBB13_397>:
    2844:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)

00000000000058e8 <LBB13_398>:
    2845:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    2847:	18 03 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r3 = 4294967295 ll
    2849:	b7 05 00 00 08 00 00 00	r5 = 8
    2850:	85 00 00 00 19 00 00 00	call 25
    2851:	18 08 00 00 65 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967141 ll
    2853:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2854:	05 00 b9 f6 00 00 00 00	goto -2375 <LBB13_87>

0000000000005938 <LBB13_399>:
    2855:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2856:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2857:	79 a7 f8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 264)
    2858:	79 a0 d0 fe 00 00 00 00	r0 = *(u64 *)(r10 - 304)
    2859:	05 00 7c 01 00 00 00 00	goto +380 <LBB13_473>

0000000000005960 <LBB13_400>:
    2860:	b7 05 00 00 20 00 00 00	r5 = 32
    2861:	b7 07 00 00 06 00 00 00	r7 = 6
    2862:	05 00 01 00 00 00 00 00	goto +1 <LBB13_402>

0000000000005978 <LBB13_401>:
    2863:	b7 07 00 00 02 00 00 00	r7 = 2

0000000000005980 <LBB13_402>:
    2864:	b7 08 00 00 00 00 00 00	r8 = 0
; 		if (state->to_sport != tuple->sport) {
    2865:	69 64 24 00 00 00 00 00	r4 = *(u16 *)(r6 + 36)
    2866:	69 a3 aa ff 00 00 00 00	r3 = *(u16 *)(r10 - 86)
    2867:	1d 34 41 00 00 00 00 00	if r4 == r3 goto +65 <LBB13_414>
; 			switch (tuple->nexthdr) {
    2868:	15 02 1d 00 01 00 00 00	if r2 == 1 goto +29 <LBB13_409>
    2869:	15 02 01 00 11 00 00 00	if r2 == 17 goto +1 <LBB13_406>
    2870:	55 02 3e 00 06 00 00 00	if r2 != 6 goto +62 <LBB13_414>

00000000000059b8 <LBB13_406>:
    2871:	6b 4a d8 ff 00 00 00 00	*(u16 *)(r10 - 40) = r4
    2872:	7b 7a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r7
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2873:	bf 72 00 00 00 00 00 00	r2 = r7
    2874:	79 a0 38 ff 00 00 00 00	r0 = *(u64 *)(r10 - 200)
    2875:	bf 07 00 00 00 00 00 00	r7 = r0
    2876:	0f 02 00 00 00 00 00 00	r2 += r0
    2877:	7b 5a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r5
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2878:	47 05 00 00 02 00 00 00	r5 |= 2
    2879:	85 00 00 00 0b 00 00 00	call 11
    2880:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2882:	67 00 00 00 20 00 00 00	r0 <<= 32
    2883:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (csum_l4_replace(ctx, l4_off, csum_off, old_port, port, sizeof(port)) < 0)
    2884:	c5 00 0c 00 00 00 00 00	if r0 s< 0 goto +12 <LBB13_408>
    2885:	bf a3 00 00 00 00 00 00	r3 = r10
    2886:	07 03 00 00 d8 ff ff ff	r3 += -40
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
    2887:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2888:	bf 72 00 00 00 00 00 00	r2 = r7
    2889:	b7 04 00 00 02 00 00 00	r4 = 2
    2890:	b7 05 00 00 00 00 00 00	r5 = 0
    2891:	85 00 00 00 09 00 00 00	call 9
    2892:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
    2894:	67 00 00 00 20 00 00 00	r0 <<= 32
    2895:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2896:	65 00 20 00 ff ff ff ff	if r0 s> -1 goto +32 <LBB13_413>

0000000000005a88 <LBB13_408>:
    2897:	05 00 50 00 00 00 00 00	goto +80 <LBB13_420>

0000000000005a90 <LBB13_409>:
    2898:	7b 5a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r5
    2899:	bf 63 00 00 00 00 00 00	r3 = r6
    2900:	07 03 00 00 24 00 00 00	r3 += 36
; 				if (ctx_store_bytes(ctx, off +
    2901:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    2902:	07 02 00 00 04 00 00 00	r2 += 4
    2903:	bf 37 00 00 00 00 00 00	r7 = r3
    2904:	b7 04 00 00 02 00 00 00	r4 = 2
    2905:	b7 05 00 00 00 00 00 00	r5 = 0
    2906:	85 00 00 00 09 00 00 00	call 9
    2907:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 				if (ctx_store_bytes(ctx, off +
    2909:	67 00 00 00 20 00 00 00	r0 <<= 32
    2910:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2911:	c5 00 42 00 00 00 00 00	if r0 s< 0 goto +66 <LBB13_420>
; 				to = state->to_sport;
    2912:	69 78 00 00 00 00 00 00	r8 = *(u16 *)(r7 + 0)
; 				from = tuple->sport;
    2913:	69 a1 aa ff 00 00 00 00	r1 = *(u16 *)(r10 - 86)
    2914:	a7 01 00 00 ff ff ff ff	r1 ^= -1
    2915:	67 01 00 00 20 00 00 00	r1 <<= 32
    2916:	77 01 00 00 20 00 00 00	r1 >>= 32
    2917:	0f 18 00 00 00 00 00 00	r8 += r1
    2918:	bf 82 00 00 00 00 00 00	r2 = r8
    2919:	67 02 00 00 20 00 00 00	r2 <<= 32
    2920:	77 02 00 00 20 00 00 00	r2 >>= 32
    2921:	b7 01 00 00 01 00 00 00	r1 = 1
    2922:	5d 82 01 00 00 00 00 00	if r2 != r8 goto +1 <LBB13_412>
    2923:	b7 01 00 00 00 00 00 00	r1 = 0

0000000000005b60 <LBB13_412>:
    2924:	0f 18 00 00 00 00 00 00	r8 += r1
    2925:	b7 07 00 00 02 00 00 00	r7 = 2
    2926:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2927:	79 a5 00 ff 00 00 00 00	r5 = *(u64 *)(r10 - 256)
    2928:	05 00 04 00 00 00 00 00	goto +4 <LBB13_414>

0000000000005b88 <LBB13_413>:
    2929:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2930:	79 a5 00 ff 00 00 00 00	r5 = *(u64 *)(r10 - 256)
    2931:	79 a7 f0 fe 00 00 00 00	r7 = *(u64 *)(r10 - 272)
    2932:	b7 08 00 00 00 00 00 00	r8 = 0

0000000000005ba8 <LBB13_414>:
    2933:	7b 8a f0 fe 00 00 00 00	*(u64 *)(r10 - 272) = r8
    2934:	7b 5a 00 ff 00 00 00 00	*(u64 *)(r10 - 256) = r5
    2935:	07 06 00 00 20 00 00 00	r6 += 32
; 	if (ctx_store_bytes(ctx, ETH_HLEN + offsetof(struct iphdr, saddr),
    2936:	b7 02 00 00 1a 00 00 00	r2 = 26
    2937:	bf 63 00 00 00 00 00 00	r3 = r6
    2938:	b7 04 00 00 04 00 00 00	r4 = 4
    2939:	b7 05 00 00 00 00 00 00	r5 = 0
    2940:	85 00 00 00 09 00 00 00	call 9
    2941:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	if (ctx_store_bytes(ctx, ETH_HLEN + offsetof(struct iphdr, saddr),
    2943:	67 00 00 00 20 00 00 00	r0 <<= 32
    2944:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2945:	79 a6 10 ff 00 00 00 00	r6 = *(u64 *)(r10 - 240)
    2946:	c5 00 1f 00 00 00 00 00	if r0 s< 0 goto +31 <LBB13_420>
    2947:	79 a1 08 ff 00 00 00 00	r1 = *(u64 *)(r10 - 248)
    2948:	0f 16 00 00 00 00 00 00	r6 += r1
; 	if (l3_csum_replace(ctx, ETH_HLEN + offsetof(struct iphdr, check),
    2949:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2950:	b7 02 00 00 18 00 00 00	r2 = 24
    2951:	b7 03 00 00 00 00 00 00	r3 = 0
    2952:	bf 64 00 00 00 00 00 00	r4 = r6
    2953:	b7 05 00 00 00 00 00 00	r5 = 0
    2954:	85 00 00 00 0a 00 00 00	call 10
    2955:	18 08 00 00 67 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967143 ll
; 	if (l3_csum_replace(ctx, ETH_HLEN + offsetof(struct iphdr, check),
    2957:	67 00 00 00 20 00 00 00	r0 <<= 32
    2958:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    2959:	c5 00 12 00 00 00 00 00	if r0 s< 0 goto +18 <LBB13_420>
; 	if (csum.offset &&
    2960:	15 07 14 00 00 00 00 00	if r7 == 0 goto +20 <LBB13_421>
; 	if (tuple->nexthdr == IPPROTO_ICMP)
    2961:	71 a1 ac ff 00 00 00 00	r1 = *(u8 *)(r10 - 84)
    2962:	79 a4 f0 fe 00 00 00 00	r4 = *(u64 *)(r10 - 272)
    2963:	15 01 01 00 01 00 00 00	if r1 == 1 goto +1 <LBB13_419>
    2964:	bf 64 00 00 00 00 00 00	r4 = r6

0000000000005ca8 <LBB13_419>:
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2965:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
    2966:	0f 17 00 00 00 00 00 00	r7 += r1
    2967:	79 a5 00 ff 00 00 00 00	r5 = *(u64 *)(r10 - 256)
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2968:	47 05 00 00 10 00 00 00	r5 |= 16
    2969:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2970:	bf 72 00 00 00 00 00 00	r2 = r7
    2971:	b7 03 00 00 00 00 00 00	r3 = 0
    2972:	85 00 00 00 0b 00 00 00	call 11
    2973:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    2975:	67 00 00 00 20 00 00 00	r0 <<= 32
    2976:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (csum.offset &&
    2977:	65 00 03 00 ff ff ff ff	if r0 s> -1 goto +3 <LBB13_421>

0000000000005d10 <LBB13_420>:
    2978:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    2979:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2980:	05 00 3b f6 00 00 00 00	goto -2501 <LBB13_87>

0000000000005d28 <LBB13_421>:
    2981:	79 a3 40 ff 00 00 00 00	r3 = *(u64 *)(r10 - 192)
    2982:	79 a7 f8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 264)
    2983:	79 a0 d0 fe 00 00 00 00	r0 = *(u64 *)(r10 - 304)

0000000000005d40 <LBB13_422>:
; 		if (ct_state.rev_nat_index) {
    2984:	69 a1 60 ff 00 00 00 00	r1 = *(u16 *)(r10 - 160)
    2985:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    2986:	15 01 fd 00 00 00 00 00	if r1 == 0 goto +253 <LBB13_473>
    2987:	bf a2 00 00 00 00 00 00	r2 = r10
    2988:	07 02 00 00 60 ff ff ff	r2 += -160
; 	nat = map_lookup_elem(&LB4_REVERSE_NAT_MAP, &ct_state->rev_nat_index);
    2989:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    2991:	85 00 00 00 01 00 00 00	call 1
    2992:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    2993:	b7 08 00 00 00 00 00 00	r8 = 0
; 	if (nat == NULL)
    2994:	15 00 ea 00 00 00 00 00	if r0 == 0 goto +234 <LBB13_470>
; 	if (nat->port && has_l4_header) {
    2995:	71 01 04 00 00 00 00 00	r1 = *(u8 *)(r0 + 4)
    2996:	bf 07 00 00 00 00 00 00	r7 = r0
    2997:	71 06 05 00 00 00 00 00	r6 = *(u8 *)(r0 + 5)
    2998:	67 06 00 00 08 00 00 00	r6 <<= 8
    2999:	4f 16 00 00 00 00 00 00	r6 |= r1
    3000:	15 06 47 00 00 00 00 00	if r6 == 0 goto +71 <LBB13_444>
    3001:	79 a1 18 ff 00 00 00 00	r1 = *(u64 *)(r10 - 232)
    3002:	57 01 00 00 ff ff 00 00	r1 &= 65535
; 	if (nat->port && has_l4_header) {
    3003:	55 01 44 00 00 00 00 00	if r1 != 0 goto +68 <LBB13_444>
    3004:	b7 08 00 00 00 00 00 00	r8 = 0
; 		ret = reverse_map_l4_port(ctx, tuple->nexthdr, nat->port, l4_off, csum_off);
    3005:	71 a1 8c ff 00 00 00 00	r1 = *(u8 *)(r10 - 116)
; 	switch (nexthdr) {
    3006:	65 01 05 00 10 00 00 00	if r1 s> 16 goto +5 <LBB13_430>
    3007:	15 01 37 00 01 00 00 00	if r1 == 1 goto +55 <LBB13_441>
    3008:	15 01 05 00 06 00 00 00	if r1 == 6 goto +5 <LBB13_432>

0000000000005e08 <LBB13_429>:
    3009:	18 08 00 00 72 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967154 ll
    3011:	05 00 33 00 00 00 00 00	goto +51 <LBB13_441>

0000000000005e20 <LBB13_430>:
; 	switch (nexthdr) {
    3012:	15 01 32 00 3a 00 00 00	if r1 == 58 goto +50 <LBB13_441>
    3013:	55 01 fb ff 11 00 00 00	if r1 != 17 goto -5 <LBB13_429>

0000000000005e30 <LBB13_432>:
    3014:	bf a3 00 00 00 00 00 00	r3 = r10
    3015:	07 03 00 00 d8 ff ff ff	r3 += -40
; 	return ctx_load_bytes(ctx, off, port, sizeof(__be16));
    3016:	bf 41 00 00 00 00 00 00	r1 = r4
    3017:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    3018:	b7 04 00 00 02 00 00 00	r4 = 2
    3019:	85 00 00 00 1a 00 00 00	call 26
    3020:	bf 08 00 00 00 00 00 00	r8 = r0
    3021:	bf 81 00 00 00 00 00 00	r1 = r8
    3022:	67 01 00 00 20 00 00 00	r1 <<= 32
    3023:	77 01 00 00 20 00 00 00	r1 >>= 32
    3024:	b7 02 00 00 01 00 00 00	r2 = 1
; 			if (IS_ERR(ret))
    3025:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_434>
    3026:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000005e98 <LBB13_434>:
; 			if (IS_ERR(ret))
    3027:	77 01 00 00 1f 00 00 00	r1 >>= 31
    3028:	4f 21 00 00 00 00 00 00	r1 |= r2
    3029:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3030:	55 01 20 00 00 00 00 00	if r1 != 0 goto +32 <LBB13_441>
; 			if (port != old_port) {
    3031:	69 a3 d8 ff 00 00 00 00	r3 = *(u16 *)(r10 - 40)
    3032:	1d 63 1d 00 00 00 00 00	if r3 == r6 goto +29 <LBB13_440>
    3033:	6b 6a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r6
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    3034:	79 a2 28 ff 00 00 00 00	r2 = *(u64 *)(r10 - 216)
    3035:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
    3036:	0f 12 00 00 00 00 00 00	r2 += r1
    3037:	79 a5 20 ff 00 00 00 00	r5 = *(u64 *)(r10 - 224)
    3038:	47 05 00 00 02 00 00 00	r5 |= 2
    3039:	bf 41 00 00 00 00 00 00	r1 = r4
    3040:	bf 64 00 00 00 00 00 00	r4 = r6
    3041:	85 00 00 00 0b 00 00 00	call 11
    3042:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    3044:	67 00 00 00 20 00 00 00	r0 <<= 32
    3045:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (csum_l4_replace(ctx, l4_off, csum_off, old_port, port, sizeof(port)) < 0)
    3046:	c5 00 0c 00 00 00 00 00	if r0 s< 0 goto +12 <LBB13_438>
    3047:	bf a3 00 00 00 00 00 00	r3 = r10
    3048:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
    3049:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3050:	79 a2 38 ff 00 00 00 00	r2 = *(u64 *)(r10 - 200)
    3051:	b7 04 00 00 02 00 00 00	r4 = 2
    3052:	b7 05 00 00 00 00 00 00	r5 = 0
    3053:	85 00 00 00 09 00 00 00	call 9
    3054:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	if (ctx_store_bytes(ctx, l4_off + off, &port, sizeof(port), 0) < 0)
    3056:	67 00 00 00 20 00 00 00	r0 <<= 32
    3057:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    3058:	65 00 02 00 ff ff ff ff	if r0 s> -1 goto +2 <LBB13_439>

0000000000005f98 <LBB13_438>:
    3059:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3060:	05 00 02 00 00 00 00 00	goto +2 <LBB13_441>

0000000000005fa8 <LBB13_439>:
    3061:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)

0000000000005fb0 <LBB13_440>:
    3062:	b7 08 00 00 00 00 00 00	r8 = 0

0000000000005fb8 <LBB13_441>:
; 		if (IS_ERR(ret))
    3063:	bf 81 00 00 00 00 00 00	r1 = r8
    3064:	67 01 00 00 20 00 00 00	r1 <<= 32
    3065:	77 01 00 00 20 00 00 00	r1 >>= 32
    3066:	b7 02 00 00 01 00 00 00	r2 = 1
    3067:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_443>
    3068:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000005fe8 <LBB13_443>:
; 		if (IS_ERR(ret))
    3069:	77 01 00 00 1f 00 00 00	r1 >>= 31
    3070:	4f 21 00 00 00 00 00 00	r1 |= r2
    3071:	55 01 9c 00 00 00 00 00	if r1 != 0 goto +156 <LBB13_469>

0000000000006000 <LBB13_444>:
    3072:	bf a3 00 00 00 00 00 00	r3 = r10
    3073:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		ret = ctx_load_bytes(ctx, l3_off + offsetof(struct iphdr, saddr), &old_sip, 4);
    3074:	bf 41 00 00 00 00 00 00	r1 = r4
    3075:	b7 02 00 00 1a 00 00 00	r2 = 26
    3076:	b7 04 00 00 04 00 00 00	r4 = 4
    3077:	85 00 00 00 1a 00 00 00	call 26
    3078:	bf 08 00 00 00 00 00 00	r8 = r0
    3079:	bf 81 00 00 00 00 00 00	r1 = r8
    3080:	67 01 00 00 20 00 00 00	r1 <<= 32
    3081:	77 01 00 00 20 00 00 00	r1 >>= 32
    3082:	b7 02 00 00 01 00 00 00	r2 = 1
; 		if (IS_ERR(ret))
    3083:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_446>
    3084:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000006068 <LBB13_446>:
; 		if (IS_ERR(ret))
    3085:	77 01 00 00 1f 00 00 00	r1 >>= 31
    3086:	4f 21 00 00 00 00 00 00	r1 |= r2
    3087:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3088:	55 01 8b 00 00 00 00 00	if r1 != 0 goto +139 <LBB13_469>
; 		new_sip = nat->address;
    3089:	71 71 01 00 00 00 00 00	r1 = *(u8 *)(r7 + 1)
    3090:	67 01 00 00 08 00 00 00	r1 <<= 8
    3091:	71 72 00 00 00 00 00 00	r2 = *(u8 *)(r7 + 0)
    3092:	4f 21 00 00 00 00 00 00	r1 |= r2
    3093:	71 72 02 00 00 00 00 00	r2 = *(u8 *)(r7 + 2)
    3094:	71 73 03 00 00 00 00 00	r3 = *(u8 *)(r7 + 3)
    3095:	67 03 00 00 08 00 00 00	r3 <<= 8
    3096:	4f 23 00 00 00 00 00 00	r3 |= r2
    3097:	67 03 00 00 10 00 00 00	r3 <<= 16
    3098:	4f 13 00 00 00 00 00 00	r3 |= r1
    3099:	63 3a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r3
; 	if (ct_state->loopback) {
    3100:	69 a1 62 ff 00 00 00 00	r1 = *(u16 *)(r10 - 158)
    3101:	57 01 00 00 01 00 00 00	r1 &= 1
; 	__be32 old_sip, new_sip, sum = 0;
    3102:	b7 07 00 00 00 00 00 00	r7 = 0
; 	if (ct_state->loopback) {
    3103:	15 01 33 00 00 00 00 00	if r1 == 0 goto +51 <LBB13_458>
    3104:	bf a3 00 00 00 00 00 00	r3 = r10
    3105:	07 03 00 00 48 ff ff ff	r3 += -184
; 		ret = ctx_load_bytes(ctx, l3_off + offsetof(struct iphdr, daddr), &old_dip, 4);
    3106:	bf 41 00 00 00 00 00 00	r1 = r4
    3107:	b7 02 00 00 1e 00 00 00	r2 = 30
    3108:	b7 04 00 00 04 00 00 00	r4 = 4
    3109:	85 00 00 00 1a 00 00 00	call 26
    3110:	bf 08 00 00 00 00 00 00	r8 = r0
    3111:	bf 81 00 00 00 00 00 00	r1 = r8
    3112:	67 01 00 00 20 00 00 00	r1 <<= 32
    3113:	77 01 00 00 20 00 00 00	r1 >>= 32
    3114:	b7 02 00 00 01 00 00 00	r2 = 1
; 		if (IS_ERR(ret))
    3115:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_450>
    3116:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000006168 <LBB13_450>:
; 		if (IS_ERR(ret))
    3117:	77 01 00 00 1f 00 00 00	r1 >>= 31
    3118:	4f 21 00 00 00 00 00 00	r1 |= r2
    3119:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3120:	55 01 12 00 00 00 00 00	if r1 != 0 goto +18 <LBB13_454>
    3121:	bf a3 00 00 00 00 00 00	r3 = r10
    3122:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, daddr), &old_sip, 4, 0);
    3123:	bf 41 00 00 00 00 00 00	r1 = r4
    3124:	b7 02 00 00 1e 00 00 00	r2 = 30
    3125:	b7 04 00 00 04 00 00 00	r4 = 4
    3126:	b7 05 00 00 00 00 00 00	r5 = 0
    3127:	85 00 00 00 09 00 00 00	call 9
    3128:	67 00 00 00 20 00 00 00	r0 <<= 32
    3129:	77 00 00 00 20 00 00 00	r0 >>= 32
    3130:	b7 01 00 00 01 00 00 00	r1 = 1
; 		if (IS_ERR(ret))
    3131:	15 00 01 00 02 00 00 00	if r0 == 2 goto +1 <LBB13_453>
    3132:	b7 01 00 00 00 00 00 00	r1 = 0

00000000000061e8 <LBB13_453>:
    3133:	77 00 00 00 1f 00 00 00	r0 >>= 31
    3134:	4f 10 00 00 00 00 00 00	r0 |= r1
    3135:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
    3137:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3138:	15 00 01 00 00 00 00 00	if r0 == 0 goto +1 <LBB13_455>

0000000000006218 <LBB13_454>:
    3139:	05 00 58 00 00 00 00 00	goto +88 <LBB13_469>

0000000000006220 <LBB13_455>:
    3140:	61 a2 48 ff 00 00 00 00	r2 = *(u32 *)(r10 - 184)
    3141:	a7 02 00 00 ff ff ff ff	r2 ^= -1
    3142:	67 02 00 00 20 00 00 00	r2 <<= 32
    3143:	77 02 00 00 20 00 00 00	r2 >>= 32
    3144:	61 a1 a0 ff 00 00 00 00	r1 = *(u32 *)(r10 - 96)
    3145:	bf 17 00 00 00 00 00 00	r7 = r1
    3146:	0f 27 00 00 00 00 00 00	r7 += r2
    3147:	bf 73 00 00 00 00 00 00	r3 = r7
    3148:	67 03 00 00 20 00 00 00	r3 <<= 32
    3149:	77 03 00 00 20 00 00 00	r3 >>= 32
    3150:	b7 02 00 00 01 00 00 00	r2 = 1
    3151:	5d 73 01 00 00 00 00 00	if r3 != r7 goto +1 <LBB13_457>
    3152:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000006288 <LBB13_457>:
; 		tuple->saddr = old_sip;
    3153:	63 1a 84 ff 00 00 00 00	*(u32 *)(r10 - 124) = r1
    3154:	0f 27 00 00 00 00 00 00	r7 += r2

0000000000006298 <LBB13_458>:
    3155:	bf a3 00 00 00 00 00 00	r3 = r10
    3156:	07 03 00 00 d8 ff ff ff	r3 += -40
; 	ret = ctx_store_bytes(ctx, l3_off + offsetof(struct iphdr, saddr),
    3157:	bf 41 00 00 00 00 00 00	r1 = r4
    3158:	b7 02 00 00 1a 00 00 00	r2 = 26
    3159:	b7 04 00 00 04 00 00 00	r4 = 4
    3160:	b7 05 00 00 00 00 00 00	r5 = 0
    3161:	85 00 00 00 09 00 00 00	call 9
    3162:	67 00 00 00 20 00 00 00	r0 <<= 32
    3163:	77 00 00 00 20 00 00 00	r0 >>= 32
    3164:	b7 01 00 00 01 00 00 00	r1 = 1
; 	if (IS_ERR(ret))
    3165:	15 00 01 00 02 00 00 00	if r0 == 2 goto +1 <LBB13_460>
    3166:	b7 01 00 00 00 00 00 00	r1 = 0

00000000000062f8 <LBB13_460>:
    3167:	77 00 00 00 1f 00 00 00	r0 >>= 31
    3168:	4f 10 00 00 00 00 00 00	r0 |= r1
    3169:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
    3171:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3172:	55 00 37 00 00 00 00 00	if r0 != 0 goto +55 <LBB13_469>
    3173:	61 a1 a0 ff 00 00 00 00	r1 = *(u32 *)(r10 - 96)
    3174:	a7 01 00 00 ff ff ff ff	r1 ^= -1
    3175:	67 01 00 00 20 00 00 00	r1 <<= 32
    3176:	77 01 00 00 20 00 00 00	r1 >>= 32
    3177:	61 a6 d8 ff 00 00 00 00	r6 = *(u32 *)(r10 - 40)
    3178:	0f 16 00 00 00 00 00 00	r6 += r1
    3179:	bf 63 00 00 00 00 00 00	r3 = r6
    3180:	67 03 00 00 20 00 00 00	r3 <<= 32
    3181:	77 03 00 00 20 00 00 00	r3 >>= 32
    3182:	b7 01 00 00 01 00 00 00	r1 = 1
    3183:	b7 02 00 00 01 00 00 00	r2 = 1
    3184:	5d 63 01 00 00 00 00 00	if r3 != r6 goto +1 <LBB13_463>
    3185:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000006390 <LBB13_463>:
    3186:	0f 26 00 00 00 00 00 00	r6 += r2
; 		    __builtin_constant_p(seed) && seed == 0)
    3187:	67 07 00 00 20 00 00 00	r7 <<= 32
    3188:	77 07 00 00 20 00 00 00	r7 >>= 32
    3189:	67 06 00 00 20 00 00 00	r6 <<= 32
    3190:	77 06 00 00 20 00 00 00	r6 >>= 32
; 		    __builtin_constant_p(seed) && seed == 0)
    3191:	0f 76 00 00 00 00 00 00	r6 += r7
    3192:	bf 62 00 00 00 00 00 00	r2 = r6
    3193:	67 02 00 00 20 00 00 00	r2 <<= 32
    3194:	77 02 00 00 20 00 00 00	r2 >>= 32
    3195:	5d 62 01 00 00 00 00 00	if r2 != r6 goto +1 <LBB13_465>
    3196:	b7 01 00 00 00 00 00 00	r1 = 0

00000000000063e8 <LBB13_465>:
    3197:	0f 16 00 00 00 00 00 00	r6 += r1
; 	if (l3_csum_replace(ctx, l3_off + offsetof(struct iphdr, check), 0, sum, 0) < 0)
    3198:	bf 41 00 00 00 00 00 00	r1 = r4
    3199:	b7 02 00 00 18 00 00 00	r2 = 24
    3200:	b7 03 00 00 00 00 00 00	r3 = 0
    3201:	bf 64 00 00 00 00 00 00	r4 = r6
    3202:	b7 05 00 00 00 00 00 00	r5 = 0
    3203:	85 00 00 00 0a 00 00 00	call 10
    3204:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3205:	18 08 00 00 67 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967143 ll
; 	if (l3_csum_replace(ctx, l3_off + offsetof(struct iphdr, check), 0, sum, 0) < 0)
    3207:	67 00 00 00 20 00 00 00	r0 <<= 32
    3208:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    3209:	c5 00 12 00 00 00 00 00	if r0 s< 0 goto +18 <LBB13_469>
; 	if (csum_off->offset &&
    3210:	79 a1 28 ff 00 00 00 00	r1 = *(u64 *)(r10 - 216)
    3211:	15 01 0f 00 00 00 00 00	if r1 == 0 goto +15 <LBB13_468>
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    3212:	79 a1 38 ff 00 00 00 00	r1 = *(u64 *)(r10 - 200)
    3213:	79 a2 28 ff 00 00 00 00	r2 = *(u64 *)(r10 - 216)
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    3214:	0f 12 00 00 00 00 00 00	r2 += r1
    3215:	79 a5 20 ff 00 00 00 00	r5 = *(u64 *)(r10 - 224)
    3216:	47 05 00 00 10 00 00 00	r5 |= 16
    3217:	bf 41 00 00 00 00 00 00	r1 = r4
    3218:	b7 03 00 00 00 00 00 00	r3 = 0
    3219:	bf 64 00 00 00 00 00 00	r4 = r6
    3220:	85 00 00 00 0b 00 00 00	call 11
    3221:	79 a4 40 ff 00 00 00 00	r4 = *(u64 *)(r10 - 192)
    3222:	18 08 00 00 66 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967142 ll
; 	return l4_csum_replace(ctx, l4_off + csum->offset, from, to, flags | csum->flags);
    3224:	67 00 00 00 20 00 00 00	r0 <<= 32
    3225:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (csum_off->offset &&
    3226:	c5 00 01 00 00 00 00 00	if r0 s< 0 goto +1 <LBB13_469>

00000000000064d8 <LBB13_468>:
    3227:	b7 08 00 00 00 00 00 00	r8 = 0

00000000000064e0 <LBB13_469>:
    3228:	79 a7 f8 fe 00 00 00 00	r7 = *(u64 *)(r10 - 264)

00000000000064e8 <LBB13_470>:
; 			if (IS_ERR(ret))
    3229:	bf 81 00 00 00 00 00 00	r1 = r8
    3230:	67 01 00 00 20 00 00 00	r1 <<= 32
    3231:	77 01 00 00 20 00 00 00	r1 >>= 32
    3232:	b7 02 00 00 01 00 00 00	r2 = 1
    3233:	15 01 01 00 02 00 00 00	if r1 == 2 goto +1 <LBB13_472>
    3234:	b7 02 00 00 00 00 00 00	r2 = 0

0000000000006518 <LBB13_472>:
    3235:	77 01 00 00 1f 00 00 00	r1 >>= 31
    3236:	4f 21 00 00 00 00 00 00	r1 |= r2
    3237:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    3238:	79 a0 d0 fe 00 00 00 00	r0 = *(u64 *)(r10 - 304)
    3239:	55 01 38 f5 00 00 00 00	if r1 != 0 goto -2760 <LBB13_87>

0000000000006540 <LBB13_473>:
; 	return is_defined(ENABLE_HOST_REDIRECT) && verdict > 0 &&
    3240:	bf 01 00 00 00 00 00 00	r1 = r0
    3241:	67 01 00 00 20 00 00 00	r1 <<= 32
    3242:	c7 01 00 00 20 00 00 00	r1 s>>= 32
    3243:	c5 01 40 00 01 00 00 00	if r1 s< 1 goto +64 <LBB13_483>
; 	       (dir == CT_NEW || dir == CT_ESTABLISHED ||  dir == CT_REOPENED);
    3244:	bf 71 00 00 00 00 00 00	r1 = r7
    3245:	57 01 00 00 07 00 00 00	r1 &= 7
    3246:	25 01 3d 00 04 00 00 00	if r1 > 4 goto +61 <LBB13_483>
    3247:	b7 02 00 00 01 00 00 00	r2 = 1
    3248:	6f 12 00 00 00 00 00 00	r2 <<= r1
    3249:	57 02 00 00 13 00 00 00	r2 &= 19
    3250:	55 02 01 00 00 00 00 00	if r2 != 0 goto +1 <LBB13_476>
    3251:	05 00 38 00 00 00 00 00	goto +56 <LBB13_483>

00000000000065a0 <LBB13_476>:
    3252:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3253:	bf 24 00 00 00 00 00 00	r4 = r2
    3254:	67 04 00 00 20 00 00 00	r4 <<= 32
    3255:	77 04 00 00 20 00 00 00	r4 >>= 32
    3256:	b7 03 00 00 80 00 00 00	r3 = 128
    3257:	15 04 01 00 00 00 00 00	if r4 == 0 goto +1 <LBB13_478>
    3258:	bf 23 00 00 00 00 00 00	r3 = r2

00000000000065d8 <LBB13_478>:
    3259:	67 03 00 00 20 00 00 00	r3 <<= 32
    3260:	77 03 00 00 20 00 00 00	r3 >>= 32
    3261:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx->len;
    3262:	61 12 00 00 00 00 00 00	r2 = *(u32 *)(r1 + 0)
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3263:	2d 32 01 00 00 00 00 00	if r2 > r3 goto +1 <LBB13_480>
    3264:	bf 23 00 00 00 00 00 00	r3 = r2

0000000000006608 <LBB13_480>:
; 	if (!emit_trace_notify(obs_point, monitor))
    3265:	15 04 23 00 00 00 00 00	if r4 == 0 goto +35 <LBB13_482>
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    3266:	61 15 44 00 00 00 00 00	r5 = *(u32 *)(r1 + 68)
; 	msg = (typeof(msg)) {
    3267:	73 7a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r7
    3268:	18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r4 = 0 ll
    3270:	63 4a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r4
    3271:	b7 04 00 00 01 00 00 00	r4 = 1
    3272:	6b 4a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r4
    3273:	63 2a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r2
    3274:	63 5a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r5
    3275:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3277:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    3278:	b7 02 00 00 04 01 00 00	r2 = 260
    3279:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    3280:	b7 02 00 00 00 00 00 00	r2 = 0
; 	case  8: jmp_8:  __it_set(d, 64);
    3281:	7b 2a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r2
; 	msg = (typeof(msg)) {
    3282:	63 2a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r2
    3283:	73 2a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r2
    3284:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
    3285:	63 2a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r2
; 	case  8: jmp_8:  __it_set(d, 64);
    3286:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
; 	msg = (typeof(msg)) {
    3287:	6b 3a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r3
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    3288:	67 03 00 00 20 00 00 00	r3 <<= 32
    3289:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    3291:	4f 23 00 00 00 00 00 00	r3 |= r2
    3292:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    3293:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    3294:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3296:	b7 05 00 00 30 00 00 00	r5 = 48
    3297:	bf 06 00 00 00 00 00 00	r6 = r0
    3298:	85 00 00 00 19 00 00 00	call 25
    3299:	bf 60 00 00 00 00 00 00	r0 = r6
    3300:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)

0000000000006728 <LBB13_482>:
; 		ctx->mark = MARK_MAGIC_TO_PROXY | proxy_port << 16;
    3301:	67 00 00 00 10 00 00 00	r0 <<= 16
    3302:	47 00 00 00 00 02 00 00	r0 |= 512
    3303:	63 01 08 00 00 00 00 00	*(u32 *)(r1 + 8) = r0
    3304:	b7 08 00 00 00 00 00 00	r8 = 0
; 	ctx_change_type(ctx, PACKET_HOST); /* Required for ingress packets from overlay */
    3305:	b7 02 00 00 00 00 00 00	r2 = 0
    3306:	85 00 00 00 20 00 00 00	call 32
    3307:	05 00 b6 fe 00 00 00 00	goto -330 <LBB13_420>

0000000000006760 <LBB13_483>:
    3308:	79 a2 40 ff 00 00 00 00	r2 = *(u64 *)(r10 - 192)
; 	return (void *)(unsigned long)ctx->data_end;
    3309:	61 21 50 00 00 00 00 00	r1 = *(u32 *)(r2 + 80)
; 	return (void *)(unsigned long)ctx->data;
    3310:	61 23 4c 00 00 00 00 00	r3 = *(u32 *)(r2 + 76)
; 	if (data + tot_len > data_end)
    3311:	bf 32 00 00 00 00 00 00	r2 = r3
    3312:	07 02 00 00 22 00 00 00	r2 += 34
    3313:	18 08 00 00 7a ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967162 ll
    3315:	2d 12 ec f4 00 00 00 00	if r2 > r1 goto -2836 <LBB13_87>
    3316:	7b 9a 38 ff 00 00 00 00	*(u64 *)(r10 - 200) = r9
; 	orig_dip = ip4->daddr;
    3317:	61 38 1e 00 00 00 00 00	r8 = *(u32 *)(r3 + 30)
    3318:	bf 39 00 00 00 00 00 00	r9 = r3
    3319:	b7 06 00 00 00 00 00 00	r6 = 0
; 	struct endpoint_key key = {};
    3320:	63 6a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r6
    3321:	63 6a ac ff 00 00 00 00	*(u32 *)(r10 - 84) = r6
    3322:	63 6a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r6
    3323:	63 6a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r6
    3324:	b7 01 00 00 01 00 00 00	r1 = 1
; 	key.family = ENDPOINT_KEY_IPV4;
    3325:	73 1a b0 ff 00 00 00 00	*(u8 *)(r10 - 80) = r1
; 	key.ip4 = ip;
    3326:	63 8a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r8
    3327:	bf a2 00 00 00 00 00 00	r2 = r10
    3328:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(&ENDPOINTS_MAP, &key);
    3329:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3331:	85 00 00 00 01 00 00 00	call 1
    3332:	bf 07 00 00 00 00 00 00	r7 = r0
; 		if (ep) {
    3333:	15 07 10 00 00 00 00 00	if r7 == 0 goto +16 <LBB13_488>
; 			if (ep->flags & ENDPOINT_F_HOST) {
    3334:	61 71 08 00 00 00 00 00	r1 = *(u32 *)(r7 + 8)
    3335:	57 01 00 00 01 00 00 00	r1 &= 1
    3336:	55 01 57 00 00 00 00 00	if r1 != 0 goto +87 <LBB13_499>
    3337:	b7 02 00 00 00 00 00 00	r2 = 0
    3338:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	ctx->cb[off] = data;
    3339:	63 21 38 00 00 00 00 00	*(u32 *)(r1 + 56) = r2
; 	mac_t router_mac = ep->node_mac;
    3340:	79 72 18 00 00 00 00 00	r2 = *(u64 *)(r7 + 24)
    3341:	7b 2a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r2
; 	mac_t lxc_mac = ep->mac;
    3342:	79 72 10 00 00 00 00 00	r2 = *(u64 *)(r7 + 16)
    3343:	7b 2a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r2
; 	__u8 new_ttl, ttl = ip4->ttl;
    3344:	71 93 16 00 00 00 00 00	r3 = *(u8 *)(r9 + 22)
; 	if (ttl <= 1)
    3345:	25 03 70 00 01 00 00 00	if r3 > 1 goto +112 <LBB13_506>
    3346:	18 08 00 00 7a ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967162 ll
    3348:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    3349:	05 00 ca f4 00 00 00 00	goto -2870 <LBB13_87>

00000000000068b0 <LBB13_488>:
; 		struct endpoint_key key = {};
    3350:	63 6a 58 ff 00 00 00 00	*(u32 *)(r10 - 168) = r6
    3351:	7b 6a 50 ff 00 00 00 00	*(u64 *)(r10 - 176) = r6
    3352:	7b 6a 48 ff 00 00 00 00	*(u64 *)(r10 - 184) = r6
; 		info = lookup_ip4_egress_endpoint(ip4->saddr, ip4->daddr);
    3353:	61 91 1a 00 00 00 00 00	r1 = *(u32 *)(r9 + 26)
    3354:	61 92 1e 00 00 00 00 00	r2 = *(u32 *)(r9 + 30)
; 	struct egress_key key = {
    3355:	63 2a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r2
    3356:	63 1a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r1
    3357:	b7 01 00 00 40 00 00 00	r1 = 64
; 		.lpm_key = { EGRESS_IPV4_PREFIX, {} },
    3358:	63 1a a0 ff 00 00 00 00	*(u32 *)(r10 - 96) = r1
    3359:	bf a2 00 00 00 00 00 00	r2 = r10
; 		struct endpoint_key key = {};
    3360:	07 02 00 00 a0 ff ff ff	r2 += -96
; 	return map_lookup_elem(map, &key);
    3361:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3363:	85 00 00 00 01 00 00 00	call 1
; 		if (!info)
    3364:	15 00 95 00 00 00 00 00	if r0 == 0 goto +149 <LBB13_510>
; 		ret = encap_and_redirect_lxc(ctx, info->tunnel_endpoint, encrypt_key,
    3365:	61 04 04 00 00 00 00 00	r4 = *(u32 *)(r0 + 4)
    3366:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3367:	79 a8 e0 fe 00 00 00 00	r8 = *(u64 *)(r10 - 288)
; 	if (tunnel_endpoint) {
    3368:	15 04 d8 00 00 00 00 00	if r4 == 0 goto +216 <LBB13_520>
; 	key.tunnel_id = seclabel;
    3369:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll
    3371:	67 03 00 00 20 00 00 00	r3 <<= 32
    3372:	77 03 00 00 20 00 00 00	r3 >>= 32
    3373:	b7 02 00 00 06 00 00 00	r2 = 6
    3374:	15 03 02 00 01 00 00 00	if r3 == 1 goto +2 <LBB13_492>
    3375:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll

0000000000006988 <LBB13_492>:
    3377:	b7 03 00 00 00 00 00 00	r3 = 0
; 	struct bpf_tunnel_key key = {};
    3378:	7b 3a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r3
    3379:	63 3a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r3
    3380:	7b 3a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r3
    3381:	b7 03 00 00 40 00 00 00	r3 = 64
; 	key.tunnel_ttl = 64;
    3382:	73 3a ed ff 00 00 00 00	*(u8 *)(r10 - 19) = r3
; 	node_id = bpf_htonl(tunnel_endpoint);
    3383:	dc 04 00 00 20 00 00 00	r4 = be32 r4
; 	key.remote_ipv4 = node_id;
    3384:	63 4a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r4
; 	key.tunnel_id = seclabel;
    3385:	63 2a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r2
    3386:	bf a2 00 00 00 00 00 00	r2 = r10
    3387:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	ret = ctx_set_tunnel_key(ctx, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);
    3388:	b7 03 00 00 1c 00 00 00	r3 = 28
    3389:	b7 04 00 00 02 00 00 00	r4 = 2
    3390:	85 00 00 00 15 00 00 00	call 21
    3391:	67 00 00 00 20 00 00 00	r0 <<= 32
    3392:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (unlikely(ret < 0))
    3393:	c5 00 dc 02 00 00 00 00	if r0 s< 0 goto +732 <LBB13_586>
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3394:	bf 81 00 00 00 00 00 00	r1 = r8
    3395:	67 01 00 00 20 00 00 00	r1 <<= 32
    3396:	77 01 00 00 20 00 00 00	r1 >>= 32
    3397:	b7 07 00 00 80 00 00 00	r7 = 128
    3398:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_495>
    3399:	bf 87 00 00 00 00 00 00	r7 = r8

0000000000006a40 <LBB13_495>:
; 	return ctx->len;
    3400:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3401:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
    3402:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    3403:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    3404:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3405:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3406:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3407:	67 07 00 00 20 00 00 00	r7 <<= 32
    3408:	77 07 00 00 20 00 00 00	r7 >>= 32
    3409:	2d 76 01 00 00 00 00 00	if r6 > r7 goto +1 <LBB13_497>
    3410:	bf 67 00 00 00 00 00 00	r7 = r6

0000000000006a98 <LBB13_497>:
    3411:	bf a2 00 00 00 00 00 00	r2 = r10
    3412:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3413:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3415:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3416:	15 00 2b 01 00 00 00 00	if r0 == 0 goto +299 <LBB13_534>
; 		entry->count += 1;
    3417:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3418:	07 01 00 00 01 00 00 00	r1 += 1
    3419:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3420:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3421:	0f 61 00 00 00 00 00 00	r1 += r6
    3422:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3423:	05 00 2f 01 00 00 00 00	goto +303 <LBB13_535>

0000000000006b00 <LBB13_499>:
    3424:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3425:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
; 	if (is_defined(ENABLE_HOST_FIREWALL) && *dstID == HOST_ID) {
    3426:	55 05 37 02 01 00 00 00	if r5 != 1 goto +567 <LBB13_571>
    3427:	79 a8 e0 fe 00 00 00 00	r8 = *(u64 *)(r10 - 288)
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3428:	bf 81 00 00 00 00 00 00	r1 = r8
    3429:	67 01 00 00 20 00 00 00	r1 <<= 32
    3430:	77 01 00 00 20 00 00 00	r1 >>= 32
    3431:	b7 07 00 00 80 00 00 00	r7 = 128
    3432:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_502>
    3433:	bf 87 00 00 00 00 00 00	r7 = r8

0000000000006b50 <LBB13_502>:
; 	return ctx->len;
    3434:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3435:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
    3436:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    3437:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    3438:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3439:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3440:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3441:	67 07 00 00 20 00 00 00	r7 <<= 32
    3442:	77 07 00 00 20 00 00 00	r7 >>= 32
    3443:	2d 76 01 00 00 00 00 00	if r6 > r7 goto +1 <LBB13_504>
    3444:	bf 67 00 00 00 00 00 00	r7 = r6

0000000000006ba8 <LBB13_504>:
    3445:	bf a2 00 00 00 00 00 00	r2 = r10
    3446:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3447:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3449:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3450:	15 00 d1 00 00 00 00 00	if r0 == 0 goto +209 <LBB13_530>
; 		entry->count += 1;
    3451:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3452:	07 01 00 00 01 00 00 00	r1 += 1
    3453:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3454:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3455:	0f 61 00 00 00 00 00 00	r1 += r6
    3456:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3457:	05 00 d5 00 00 00 00 00	goto +213 <LBB13_531>

0000000000006c10 <LBB13_506>:
; 	new_ttl = ttl - 1;
    3458:	bf 34 00 00 00 00 00 00	r4 = r3
    3459:	07 04 00 00 ff ff ff ff	r4 += -1
    3460:	73 4a a0 ff 00 00 00 00	*(u8 *)(r10 - 96) = r4
; 	l3_csum_replace(ctx, off + offsetof(struct iphdr, check), ttl, new_ttl, 2);
    3461:	57 04 00 00 ff 00 00 00	r4 &= 255
    3462:	b7 02 00 00 18 00 00 00	r2 = 24
    3463:	b7 05 00 00 02 00 00 00	r5 = 2
    3464:	85 00 00 00 0a 00 00 00	call 10
    3465:	bf a3 00 00 00 00 00 00	r3 = r10
; 	new_ttl = ttl - 1;
    3466:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	ctx_store_bytes(ctx, off + offsetof(struct iphdr, ttl), &new_ttl, sizeof(new_ttl), 0);
    3467:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3468:	b7 02 00 00 16 00 00 00	r2 = 22
    3469:	b7 04 00 00 01 00 00 00	r4 = 1
    3470:	b7 05 00 00 00 00 00 00	r5 = 0
    3471:	85 00 00 00 09 00 00 00	call 9
    3472:	bf a3 00 00 00 00 00 00	r3 = r10
; 	new_ttl = ttl - 1;
    3473:	07 03 00 00 48 ff ff ff	r3 += -184
; 	return ctx_store_bytes(ctx, off + ETH_ALEN, mac, ETH_ALEN, 0);
    3474:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3475:	b7 02 00 00 06 00 00 00	r2 = 6
    3476:	b7 04 00 00 06 00 00 00	r4 = 6
    3477:	b7 05 00 00 00 00 00 00	r5 = 0
    3478:	85 00 00 00 09 00 00 00	call 9
    3479:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3480:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	return ctx_store_bytes(ctx, off + ETH_ALEN, mac, ETH_ALEN, 0);
    3482:	67 00 00 00 20 00 00 00	r0 <<= 32
    3483:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (smac && eth_store_saddr(ctx, smac, 0) < 0)
    3484:	c5 00 7a 01 00 00 00 00	if r0 s< 0 goto +378 <LBB13_554>
    3485:	bf a3 00 00 00 00 00 00	r3 = r10
    3486:	07 03 00 00 f8 ff ff ff	r3 += -8
    3487:	b7 06 00 00 00 00 00 00	r6 = 0
; 	return ctx_store_bytes(ctx, off, mac, ETH_ALEN, 0);
    3488:	b7 02 00 00 00 00 00 00	r2 = 0
    3489:	b7 04 00 00 06 00 00 00	r4 = 6
    3490:	b7 05 00 00 00 00 00 00	r5 = 0
    3491:	85 00 00 00 09 00 00 00	call 9
    3492:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	return ctx_store_bytes(ctx, off, mac, ETH_ALEN, 0);
    3493:	67 00 00 00 20 00 00 00	r0 <<= 32
    3494:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (dmac && eth_store_daddr(ctx, dmac, 0) < 0)
    3495:	c5 00 6f 01 00 00 00 00	if r0 s< 0 goto +367 <LBB13_554>
; 	return ctx->len;
    3496:	61 18 00 00 00 00 00 00	r8 = *(u32 *)(r1 + 0)
; 	struct metrics_value *entry, newEntry = {};
    3497:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    3498:	7b 6a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r6
    3499:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3500:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
    3501:	bf a2 00 00 00 00 00 00	r2 = r10
    3502:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3503:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3505:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3506:	15 00 4a 01 00 00 00 00	if r0 == 0 goto +330 <LBB13_552>
; 		entry->count += 1;
    3507:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3508:	07 01 00 00 01 00 00 00	r1 += 1
    3509:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3510:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3511:	0f 81 00 00 00 00 00 00	r1 += r8
    3512:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3513:	05 00 4e 01 00 00 00 00	goto +334 <LBB13_553>

0000000000006dd0 <LBB13_510>:
    3514:	b7 01 00 00 00 00 00 00	r1 = 0
; 		struct endpoint_key key = {};
    3515:	63 1a 58 ff 00 00 00 00	*(u32 *)(r10 - 168) = r1
    3516:	63 1a 54 ff 00 00 00 00	*(u32 *)(r10 - 172) = r1
    3517:	63 1a 50 ff 00 00 00 00	*(u32 *)(r10 - 176) = r1
    3518:	63 1a 4c ff 00 00 00 00	*(u32 *)(r10 - 180) = r1
; 		key.ip4 = orig_dip & IPV4_MASK;
    3519:	57 08 00 00 ff ff 00 00	r8 &= 65535
    3520:	63 8a 48 ff 00 00 00 00	*(u32 *)(r10 - 184) = r8
    3521:	b7 01 00 00 01 00 00 00	r1 = 1
; 		key.family = ENDPOINT_KEY_IPV4;
    3522:	73 1a 58 ff 00 00 00 00	*(u8 *)(r10 - 168) = r1
    3523:	79 a4 38 ff 00 00 00 00	r4 = *(u64 *)(r10 - 200)
; 	if (tunnel_endpoint) {
    3524:	bf 42 00 00 00 00 00 00	r2 = r4
    3525:	67 02 00 00 20 00 00 00	r2 <<= 32
    3526:	77 02 00 00 20 00 00 00	r2 >>= 32
    3527:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 	if (tunnel_endpoint) {
    3528:	15 02 d2 00 00 00 00 00	if r2 == 0 goto +210 <LBB13_538>
; 	key.tunnel_id = seclabel;
    3529:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3531:	67 02 00 00 20 00 00 00	r2 <<= 32
    3532:	77 02 00 00 20 00 00 00	r2 >>= 32
    3533:	b7 03 00 00 06 00 00 00	r3 = 6
    3534:	15 02 02 00 01 00 00 00	if r2 == 1 goto +2 <LBB13_513>
    3535:	18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r3 = 0 ll

0000000000006e88 <LBB13_513>:
    3537:	b7 02 00 00 00 00 00 00	r2 = 0
; 	struct bpf_tunnel_key key = {};
    3538:	7b 2a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r2
    3539:	63 2a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r2
    3540:	7b 2a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r2
    3541:	b7 02 00 00 40 00 00 00	r2 = 64
; 	key.tunnel_ttl = 64;
    3542:	73 2a ed ff 00 00 00 00	*(u8 *)(r10 - 19) = r2
; 	node_id = bpf_htonl(tunnel_endpoint);
    3543:	dc 04 00 00 20 00 00 00	r4 = be32 r4
; 	key.remote_ipv4 = node_id;
    3544:	63 4a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r4
; 	key.tunnel_id = seclabel;
    3545:	63 3a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r3
    3546:	bf a2 00 00 00 00 00 00	r2 = r10
    3547:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	ret = ctx_set_tunnel_key(ctx, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);
    3548:	b7 03 00 00 1c 00 00 00	r3 = 28
    3549:	b7 04 00 00 02 00 00 00	r4 = 2
    3550:	85 00 00 00 15 00 00 00	call 21
    3551:	67 00 00 00 20 00 00 00	r0 <<= 32
    3552:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    3553:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
; 	if (unlikely(ret < 0))
    3554:	c5 00 3b 02 00 00 00 00	if r0 s< 0 goto +571 <LBB13_586>
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3555:	bf 21 00 00 00 00 00 00	r1 = r2
    3556:	67 01 00 00 20 00 00 00	r1 <<= 32
    3557:	77 01 00 00 20 00 00 00	r1 >>= 32
    3558:	b7 07 00 00 80 00 00 00	r7 = 128
    3559:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_516>
    3560:	bf 27 00 00 00 00 00 00	r7 = r2

0000000000006f48 <LBB13_516>:
; 	return ctx->len;
    3561:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3562:	61 18 00 00 00 00 00 00	r8 = *(u32 *)(r1 + 0)
    3563:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    3564:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    3565:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3566:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3567:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3568:	67 07 00 00 20 00 00 00	r7 <<= 32
    3569:	77 07 00 00 20 00 00 00	r7 >>= 32
    3570:	2d 78 01 00 00 00 00 00	if r8 > r7 goto +1 <LBB13_518>
    3571:	bf 87 00 00 00 00 00 00	r7 = r8

0000000000006fa0 <LBB13_518>:
    3572:	bf a2 00 00 00 00 00 00	r2 = r10
    3573:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3574:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3576:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3577:	15 00 ec 00 00 00 00 00	if r0 == 0 goto +236 <LBB13_548>
; 		entry->count += 1;
    3578:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3579:	07 01 00 00 01 00 00 00	r1 += 1
    3580:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3581:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3582:	0f 81 00 00 00 00 00 00	r1 += r8
    3583:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3584:	05 00 f0 00 00 00 00 00	goto +240 <LBB13_549>

0000000000007008 <LBB13_520>:
    3585:	bf a2 00 00 00 00 00 00	r2 = r10
; 	tunnel = map_lookup_elem(&TUNNEL_MAP, key);
    3586:	07 02 00 00 48 ff ff ff	r2 += -184
    3587:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3589:	85 00 00 00 01 00 00 00	call 1
    3590:	18 08 00 00 60 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967136 ll
; 	if (!tunnel)
    3592:	15 00 4d 01 00 00 00 00	if r0 == 0 goto +333 <LBB13_561>
; 	key.tunnel_id = seclabel;
    3593:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3595:	67 02 00 00 20 00 00 00	r2 <<= 32
    3596:	77 02 00 00 20 00 00 00	r2 >>= 32
    3597:	b7 01 00 00 06 00 00 00	r1 = 6
    3598:	15 02 02 00 01 00 00 00	if r2 == 1 goto +2 <LBB13_523>
    3599:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll

0000000000007088 <LBB13_523>:
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3601:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    3602:	71 03 03 00 00 00 00 00	r3 = *(u8 *)(r0 + 3)
    3603:	71 04 00 00 00 00 00 00	r4 = *(u8 *)(r0 + 0)
    3604:	71 05 01 00 00 00 00 00	r5 = *(u8 *)(r0 + 1)
    3605:	b7 00 00 00 00 00 00 00	r0 = 0
; 	struct bpf_tunnel_key key = {};
    3606:	7b 0a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r0
    3607:	63 0a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r0
    3608:	7b 0a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r0
    3609:	b7 00 00 00 40 00 00 00	r0 = 64
; 	key.tunnel_ttl = 64;
    3610:	73 0a ed ff 00 00 00 00	*(u8 *)(r10 - 19) = r0
; 	key.tunnel_id = seclabel;
    3611:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3612:	67 05 00 00 08 00 00 00	r5 <<= 8
    3613:	4f 45 00 00 00 00 00 00	r5 |= r4
    3614:	67 03 00 00 08 00 00 00	r3 <<= 8
    3615:	4f 23 00 00 00 00 00 00	r3 |= r2
    3616:	67 03 00 00 10 00 00 00	r3 <<= 16
    3617:	4f 53 00 00 00 00 00 00	r3 |= r5
; 	node_id = bpf_htonl(tunnel_endpoint);
    3618:	dc 03 00 00 20 00 00 00	r3 = be32 r3
; 	key.remote_ipv4 = node_id;
    3619:	63 3a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r3
    3620:	bf a2 00 00 00 00 00 00	r2 = r10
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3621:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	ret = ctx_set_tunnel_key(ctx, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);
    3622:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3623:	b7 03 00 00 1c 00 00 00	r3 = 28
    3624:	b7 04 00 00 02 00 00 00	r4 = 2
    3625:	85 00 00 00 15 00 00 00	call 21
    3626:	67 00 00 00 20 00 00 00	r0 <<= 32
    3627:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    3628:	79 a8 e0 fe 00 00 00 00	r8 = *(u64 *)(r10 - 288)
; 	if (unlikely(ret < 0))
    3629:	c5 00 f0 01 00 00 00 00	if r0 s< 0 goto +496 <LBB13_586>
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3630:	bf 81 00 00 00 00 00 00	r1 = r8
    3631:	67 01 00 00 20 00 00 00	r1 <<= 32
    3632:	77 01 00 00 20 00 00 00	r1 >>= 32
    3633:	b7 07 00 00 80 00 00 00	r7 = 128
    3634:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_526>
    3635:	bf 87 00 00 00 00 00 00	r7 = r8

00000000000071a0 <LBB13_526>:
; 	return ctx->len;
    3636:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3637:	61 16 00 00 00 00 00 00	r6 = *(u32 *)(r1 + 0)
    3638:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    3639:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    3640:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3641:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3642:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3643:	67 07 00 00 20 00 00 00	r7 <<= 32
    3644:	77 07 00 00 20 00 00 00	r7 >>= 32
    3645:	2d 76 01 00 00 00 00 00	if r6 > r7 goto +1 <LBB13_528>
    3646:	bf 67 00 00 00 00 00 00	r7 = r6

00000000000071f8 <LBB13_528>:
    3647:	bf a2 00 00 00 00 00 00	r2 = r10
    3648:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3649:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3651:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3652:	15 00 d4 00 00 00 00 00	if r0 == 0 goto +212 <LBB13_555>
; 		entry->count += 1;
    3653:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3654:	07 01 00 00 01 00 00 00	r1 += 1
    3655:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3656:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3657:	0f 61 00 00 00 00 00 00	r1 += r6
    3658:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3659:	05 00 d8 00 00 00 00 00	goto +216 <LBB13_556>

0000000000007260 <LBB13_530>:
; 		newEntry.bytes = bytes;
    3660:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    3661:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3662:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3663:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3664:	07 02 00 00 d8 ff ff ff	r2 += -40
    3665:	bf a3 00 00 00 00 00 00	r3 = r10
    3666:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3667:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3669:	b7 04 00 00 00 00 00 00	r4 = 0
    3670:	85 00 00 00 02 00 00 00	call 2

00000000000072b8 <LBB13_531>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3671:	67 08 00 00 20 00 00 00	r8 <<= 32
    3672:	77 08 00 00 20 00 00 00	r8 >>= 32
; 	if (!emit_trace_notify(obs_point, monitor))
    3673:	15 08 23 00 00 00 00 00	if r8 == 0 goto +35 <LBB13_533>
    3674:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    3675:	61 13 44 00 00 00 00 00	r3 = *(u32 *)(r1 + 68)
; 	msg = (typeof(msg)) {
    3676:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    3677:	73 2a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r2
    3678:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3680:	63 2a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r2
    3681:	b7 02 00 00 01 00 00 00	r2 = 1
    3682:	63 2a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r2
    3683:	63 2a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r2
    3684:	6b 2a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r2
    3685:	63 6a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r6
    3686:	63 3a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r3
    3687:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3689:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    3690:	b7 02 00 00 04 02 00 00	r2 = 516
    3691:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    3692:	b7 02 00 00 00 00 00 00	r2 = 0
; 	case  8: jmp_8:  __it_set(d, 64);
    3693:	7b 2a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r2
; 	msg = (typeof(msg)) {
    3694:	73 2a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r2
    3695:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
; 	case  8: jmp_8:  __it_set(d, 64);
    3696:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
; 	msg = (typeof(msg)) {
    3697:	6b 7a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r7
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    3698:	67 07 00 00 20 00 00 00	r7 <<= 32
    3699:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    3701:	4f 27 00 00 00 00 00 00	r7 |= r2
    3702:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    3703:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    3704:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3706:	bf 73 00 00 00 00 00 00	r3 = r7
    3707:	b7 05 00 00 30 00 00 00	r5 = 48
    3708:	85 00 00 00 19 00 00 00	call 25

00000000000073e8 <LBB13_533>:
; 		return redirect(HOST_IFINDEX, BPF_F_INGRESS);
    3709:	b7 01 00 00 01 00 00 00	r1 = 1
    3710:	b7 02 00 00 01 00 00 00	r2 = 1
    3711:	85 00 00 00 17 00 00 00	call 23
    3712:	b7 05 00 00 01 00 00 00	r5 = 1
; 		return redirect(HOST_IFINDEX, BPF_F_INGRESS);
    3713:	bf 08 00 00 00 00 00 00	r8 = r0
    3714:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3715:	05 00 5c f3 00 00 00 00	goto -3236 <LBB13_87>

0000000000007420 <LBB13_534>:
; 		newEntry.bytes = bytes;
    3716:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    3717:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3718:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3719:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3720:	07 02 00 00 f8 ff ff ff	r2 += -8
    3721:	bf a3 00 00 00 00 00 00	r3 = r10
    3722:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3723:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3725:	b7 04 00 00 00 00 00 00	r4 = 0
    3726:	85 00 00 00 02 00 00 00	call 2

0000000000007478 <LBB13_535>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3727:	bf 81 00 00 00 00 00 00	r1 = r8
    3728:	67 01 00 00 20 00 00 00	r1 <<= 32
    3729:	77 01 00 00 20 00 00 00	r1 >>= 32
; 	if (!emit_trace_notify(obs_point, monitor))
    3730:	15 01 bb 00 00 00 00 00	if r1 == 0 goto +187 <LBB13_560>
; 	msg = (typeof(msg)) {
    3731:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3733:	67 02 00 00 20 00 00 00	r2 <<= 32
    3734:	77 02 00 00 20 00 00 00	r2 >>= 32
    3735:	b7 04 00 00 06 00 00 00	r4 = 6
    3736:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3737:	15 02 97 00 01 00 00 00	if r2 == 1 goto +151 <LBB13_559>
    3738:	05 00 94 00 00 00 00 00	goto +148 <LBB13_558>

00000000000074d8 <LBB13_538>:
    3739:	bf a2 00 00 00 00 00 00	r2 = r10
; 	tunnel = map_lookup_elem(&TUNNEL_MAP, key);
    3740:	07 02 00 00 48 ff ff ff	r2 += -184
    3741:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3743:	85 00 00 00 01 00 00 00	call 1
    3744:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3745:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
; 	if (!tunnel)
    3746:	15 00 f7 00 00 00 00 00	if r0 == 0 goto +247 <LBB13_571>
; 	key.tunnel_id = seclabel;
    3747:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3749:	67 02 00 00 20 00 00 00	r2 <<= 32
    3750:	77 02 00 00 20 00 00 00	r2 >>= 32
    3751:	b7 01 00 00 06 00 00 00	r1 = 6
    3752:	15 02 02 00 01 00 00 00	if r2 == 1 goto +2 <LBB13_541>
    3753:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll

0000000000007558 <LBB13_541>:
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3755:	71 02 02 00 00 00 00 00	r2 = *(u8 *)(r0 + 2)
    3756:	71 03 03 00 00 00 00 00	r3 = *(u8 *)(r0 + 3)
    3757:	71 04 00 00 00 00 00 00	r4 = *(u8 *)(r0 + 0)
    3758:	71 05 01 00 00 00 00 00	r5 = *(u8 *)(r0 + 1)
    3759:	b7 00 00 00 00 00 00 00	r0 = 0
; 	struct bpf_tunnel_key key = {};
    3760:	7b 0a e8 ff 00 00 00 00	*(u64 *)(r10 - 24) = r0
    3761:	63 0a f0 ff 00 00 00 00	*(u32 *)(r10 - 16) = r0
    3762:	7b 0a e0 ff 00 00 00 00	*(u64 *)(r10 - 32) = r0
    3763:	b7 00 00 00 40 00 00 00	r0 = 64
; 	key.tunnel_ttl = 64;
    3764:	73 0a ed ff 00 00 00 00	*(u8 *)(r10 - 19) = r0
; 	key.tunnel_id = seclabel;
    3765:	63 1a d8 ff 00 00 00 00	*(u32 *)(r10 - 40) = r1
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3766:	67 05 00 00 08 00 00 00	r5 <<= 8
    3767:	4f 45 00 00 00 00 00 00	r5 |= r4
    3768:	67 03 00 00 08 00 00 00	r3 <<= 8
    3769:	4f 23 00 00 00 00 00 00	r3 |= r2
    3770:	67 03 00 00 10 00 00 00	r3 <<= 16
    3771:	4f 53 00 00 00 00 00 00	r3 |= r5
; 	node_id = bpf_htonl(tunnel_endpoint);
    3772:	dc 03 00 00 20 00 00 00	r3 = be32 r3
; 	key.remote_ipv4 = node_id;
    3773:	63 3a dc ff 00 00 00 00	*(u32 *)(r10 - 36) = r3
    3774:	bf a2 00 00 00 00 00 00	r2 = r10
; 	return __encap_and_redirect_with_nodeid(ctx, tunnel->ip4, seclabel, monitor);
    3775:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	ret = ctx_set_tunnel_key(ctx, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);
    3776:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3777:	b7 03 00 00 1c 00 00 00	r3 = 28
    3778:	b7 04 00 00 02 00 00 00	r4 = 2
    3779:	85 00 00 00 15 00 00 00	call 21
    3780:	67 00 00 00 20 00 00 00	r0 <<= 32
    3781:	c7 00 00 00 20 00 00 00	r0 s>>= 32
    3782:	79 a2 e0 fe 00 00 00 00	r2 = *(u64 *)(r10 - 288)
; 	if (unlikely(ret < 0))
    3783:	c5 00 56 01 00 00 00 00	if r0 s< 0 goto +342 <LBB13_586>
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3784:	bf 21 00 00 00 00 00 00	r1 = r2
    3785:	67 01 00 00 20 00 00 00	r1 <<= 32
    3786:	77 01 00 00 20 00 00 00	r1 >>= 32
    3787:	b7 07 00 00 80 00 00 00	r7 = 128
    3788:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_544>
    3789:	bf 27 00 00 00 00 00 00	r7 = r2

0000000000007670 <LBB13_544>:
; 	return ctx->len;
    3790:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3791:	61 18 00 00 00 00 00 00	r8 = *(u32 *)(r1 + 0)
    3792:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    3793:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    3794:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3795:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    3796:	7b 1a f8 ff 00 00 00 00	*(u64 *)(r10 - 8) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3797:	67 07 00 00 20 00 00 00	r7 <<= 32
    3798:	77 07 00 00 20 00 00 00	r7 >>= 32
    3799:	2d 78 01 00 00 00 00 00	if r8 > r7 goto +1 <LBB13_546>
    3800:	bf 87 00 00 00 00 00 00	r7 = r8

00000000000076c8 <LBB13_546>:
    3801:	bf a2 00 00 00 00 00 00	r2 = r10
    3802:	07 02 00 00 f8 ff ff ff	r2 += -8
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    3803:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3805:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    3806:	15 00 78 00 00 00 00 00	if r0 == 0 goto +120 <LBB13_563>
; 		entry->count += 1;
    3807:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    3808:	07 01 00 00 01 00 00 00	r1 += 1
    3809:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    3810:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    3811:	0f 81 00 00 00 00 00 00	r1 += r8
    3812:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    3813:	05 00 7c 00 00 00 00 00	goto +124 <LBB13_564>

0000000000007730 <LBB13_548>:
; 		newEntry.bytes = bytes;
    3814:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    3815:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3816:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3817:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3818:	07 02 00 00 f8 ff ff ff	r2 += -8
    3819:	bf a3 00 00 00 00 00 00	r3 = r10
    3820:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3821:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3823:	b7 04 00 00 00 00 00 00	r4 = 0
    3824:	85 00 00 00 02 00 00 00	call 2

0000000000007788 <LBB13_549>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3825:	79 a1 e0 fe 00 00 00 00	r1 = *(u64 *)(r10 - 288)
    3826:	67 01 00 00 20 00 00 00	r1 <<= 32
    3827:	77 01 00 00 20 00 00 00	r1 >>= 32
; 	if (!emit_trace_notify(obs_point, monitor))
    3828:	15 01 97 00 00 00 00 00	if r1 == 0 goto +151 <LBB13_568>
; 	msg = (typeof(msg)) {
    3829:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3831:	67 02 00 00 20 00 00 00	r2 <<= 32
    3832:	77 02 00 00 20 00 00 00	r2 >>= 32
    3833:	b7 04 00 00 06 00 00 00	r4 = 6
    3834:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3835:	15 02 73 00 01 00 00 00	if r2 == 1 goto +115 <LBB13_567>
    3836:	05 00 70 00 00 00 00 00	goto +112 <LBB13_566>

00000000000077e8 <LBB13_552>:
; 		newEntry.bytes = bytes;
    3837:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    3838:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3839:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3840:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3841:	07 02 00 00 d8 ff ff ff	r2 += -40
    3842:	bf a3 00 00 00 00 00 00	r3 = r10
    3843:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3844:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3846:	b7 04 00 00 00 00 00 00	r4 = 0
    3847:	85 00 00 00 02 00 00 00	call 2

0000000000007840 <LBB13_553>:
; 	ctx->cb[off] = data;
    3848:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3850:	79 a6 40 ff 00 00 00 00	r6 = *(u64 *)(r10 - 192)
    3851:	63 16 30 00 00 00 00 00	*(u32 *)(r6 + 48) = r1
; 	ctx_store_meta(ctx, CB_IFINDEX, ep->ifindex);
    3852:	61 71 00 00 00 00 00 00	r1 = *(u32 *)(r7 + 0)
    3853:	b7 02 00 00 00 00 00 00	r2 = 0
; 	ctx->cb[off] = data;
    3854:	63 26 3c 00 00 00 00 00	*(u32 *)(r6 + 60) = r2
    3855:	63 16 34 00 00 00 00 00	*(u32 *)(r6 + 52) = r1
; 	tail_call_dynamic(ctx, &POLICY_CALL_MAP, ep->lxc_id);
    3856:	69 73 06 00 00 00 00 00	r3 = *(u16 *)(r7 + 6)
; 	tail_call(ctx, map, slot);
    3857:	bf 61 00 00 00 00 00 00	r1 = r6
    3858:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3860:	85 00 00 00 0c 00 00 00	call 12
    3861:	18 08 00 00 74 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967156 ll

00000000000078b8 <LBB13_554>:
    3863:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    3864:	05 00 c7 f2 00 00 00 00	goto -3385 <LBB13_87>

00000000000078c8 <LBB13_555>:
; 		newEntry.bytes = bytes;
    3865:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    3866:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3867:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3868:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3869:	07 02 00 00 f8 ff ff ff	r2 += -8
    3870:	bf a3 00 00 00 00 00 00	r3 = r10
    3871:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3872:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3874:	b7 04 00 00 00 00 00 00	r4 = 0
    3875:	85 00 00 00 02 00 00 00	call 2

0000000000007920 <LBB13_556>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3876:	bf 81 00 00 00 00 00 00	r1 = r8
    3877:	67 01 00 00 20 00 00 00	r1 <<= 32
    3878:	77 01 00 00 20 00 00 00	r1 >>= 32
; 	if (!emit_trace_notify(obs_point, monitor))
    3879:	15 01 26 00 00 00 00 00	if r1 == 0 goto +38 <LBB13_560>
; 	msg = (typeof(msg)) {
    3880:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3882:	67 02 00 00 20 00 00 00	r2 <<= 32
    3883:	77 02 00 00 20 00 00 00	r2 >>= 32
    3884:	b7 04 00 00 06 00 00 00	r4 = 6
    3885:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3886:	15 02 02 00 01 00 00 00	if r2 == 1 goto +2 <LBB13_559>

0000000000007978 <LBB13_558>:
    3887:	18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r4 = 0 ll

0000000000007988 <LBB13_559>:
    3889:	61 12 44 00 00 00 00 00	r2 = *(u32 *)(r1 + 68)
    3890:	b7 03 00 00 01 00 00 00	r3 = 1
    3891:	63 3a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r3
    3892:	6b 3a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r3
    3893:	63 6a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r6
    3894:	63 2a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r2
    3895:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3897:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    3898:	b7 02 00 00 04 04 00 00	r2 = 1028
    3899:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    3900:	b7 02 00 00 00 00 00 00	r2 = 0
    3901:	63 2a b8 ff 00 00 00 00	*(u32 *)(r10 - 72) = r2
    3902:	63 2a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r2
    3903:	7b 2a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r2
    3904:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
    3905:	63 4a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r4
    3906:	6b 7a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r7
    3907:	67 07 00 00 20 00 00 00	r7 <<= 32
    3908:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
    3910:	4f 27 00 00 00 00 00 00	r7 |= r2
    3911:	bf a4 00 00 00 00 00 00	r4 = r10
    3912:	07 04 00 00 a0 ff ff ff	r4 += -96
    3913:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3915:	bf 73 00 00 00 00 00 00	r3 = r7
    3916:	b7 05 00 00 30 00 00 00	r5 = 48
    3917:	85 00 00 00 19 00 00 00	call 25

0000000000007a70 <LBB13_560>:
    3918:	b7 01 00 00 01 00 00 00	r1 = 1
    3919:	b7 02 00 00 00 00 00 00	r2 = 0
    3920:	85 00 00 00 17 00 00 00	call 23
    3921:	bf 08 00 00 00 00 00 00	r8 = r0
    3922:	bf 81 00 00 00 00 00 00	r1 = r8
    3923:	67 01 00 00 20 00 00 00	r1 <<= 32
    3924:	77 01 00 00 20 00 00 00	r1 >>= 32
    3925:	15 01 49 00 00 00 00 00	if r1 == 0 goto +73 <LBB13_575>

0000000000007ab0 <LBB13_561>:
    3926:	05 00 4b fc 00 00 00 00	goto -949 <LBB13_420>

0000000000007ab8 <LBB13_563>:
; 		newEntry.bytes = bytes;
    3927:	7b 8a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r8
    3928:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    3929:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    3930:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    3931:	07 02 00 00 f8 ff ff ff	r2 += -8
    3932:	bf a3 00 00 00 00 00 00	r3 = r10
    3933:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    3934:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    3936:	b7 04 00 00 00 00 00 00	r4 = 0
    3937:	85 00 00 00 02 00 00 00	call 2

0000000000007b10 <LBB13_564>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    3938:	79 a1 e0 fe 00 00 00 00	r1 = *(u64 *)(r10 - 288)
    3939:	67 01 00 00 20 00 00 00	r1 <<= 32
    3940:	77 01 00 00 20 00 00 00	r1 >>= 32
; 	if (!emit_trace_notify(obs_point, monitor))
    3941:	15 01 26 00 00 00 00 00	if r1 == 0 goto +38 <LBB13_568>
; 	msg = (typeof(msg)) {
    3942:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3944:	67 02 00 00 20 00 00 00	r2 <<= 32
    3945:	77 02 00 00 20 00 00 00	r2 >>= 32
    3946:	b7 04 00 00 06 00 00 00	r4 = 6
    3947:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    3948:	15 02 02 00 01 00 00 00	if r2 == 1 goto +2 <LBB13_567>

0000000000007b68 <LBB13_566>:
    3949:	18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r4 = 0 ll

0000000000007b78 <LBB13_567>:
    3951:	61 12 44 00 00 00 00 00	r2 = *(u32 *)(r1 + 68)
    3952:	b7 03 00 00 01 00 00 00	r3 = 1
    3953:	63 3a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r3
    3954:	6b 3a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r3
    3955:	63 8a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r8
    3956:	63 2a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r2
    3957:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3959:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    3960:	b7 02 00 00 04 04 00 00	r2 = 1028
    3961:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    3962:	b7 02 00 00 00 00 00 00	r2 = 0
    3963:	63 2a b8 ff 00 00 00 00	*(u32 *)(r10 - 72) = r2
    3964:	63 2a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r2
    3965:	7b 2a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r2
    3966:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
    3967:	63 4a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r4
    3968:	6b 7a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r7
    3969:	67 07 00 00 20 00 00 00	r7 <<= 32
    3970:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
    3972:	4f 27 00 00 00 00 00 00	r7 |= r2
    3973:	bf a4 00 00 00 00 00 00	r4 = r10
    3974:	07 04 00 00 a0 ff ff ff	r4 += -96
    3975:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    3977:	bf 73 00 00 00 00 00 00	r3 = r7
    3978:	b7 05 00 00 30 00 00 00	r5 = 48
    3979:	85 00 00 00 19 00 00 00	call 25

0000000000007c60 <LBB13_568>:
    3980:	b7 01 00 00 01 00 00 00	r1 = 1
    3981:	b7 02 00 00 00 00 00 00	r2 = 0
    3982:	85 00 00 00 17 00 00 00	call 23
    3983:	bf 08 00 00 00 00 00 00	r8 = r0
    3984:	bf 81 00 00 00 00 00 00	r1 = r8
    3985:	67 01 00 00 20 00 00 00	r1 <<= 32
    3986:	77 01 00 00 20 00 00 00	r1 >>= 32
; 		if (ret == DROP_NO_TUNNEL_ENDPOINT)
    3987:	15 01 0b 00 00 00 00 00	if r1 == 0 goto +11 <LBB13_575>
    3988:	18 02 00 00 60 ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967136 ll
    3990:	79 a3 40 ff 00 00 00 00	r3 = *(u64 *)(r10 - 192)
    3991:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
; 		if (ret == DROP_NO_TUNNEL_ENDPOINT)
    3992:	1d 21 01 00 00 00 00 00	if r1 == r2 goto +1 <LBB13_571>
    3993:	05 00 46 f2 00 00 00 00	goto -3514 <LBB13_87>

0000000000007cd0 <LBB13_571>:
; 	__u8 new_ttl, ttl = ip4->ttl;
    3994:	71 93 16 00 00 00 00 00	r3 = *(u8 *)(r9 + 22)
; 	if (ttl <= 1)
    3995:	25 03 05 00 01 00 00 00	if r3 > 1 goto +5 <LBB13_573>
    3996:	18 08 00 00 7a ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967162 ll
    3998:	05 00 41 f2 00 00 00 00	goto -3519 <LBB13_87>

0000000000007cf8 <LBB13_575>:
    3999:	79 a3 40 ff 00 00 00 00	r3 = *(u64 *)(r10 - 192)
    4000:	05 00 2b 00 00 00 00 00	goto +43 <LBB13_576>

0000000000007d08 <LBB13_573>:
; 	new_ttl = ttl - 1;
    4001:	bf 34 00 00 00 00 00 00	r4 = r3
    4002:	07 04 00 00 ff ff ff ff	r4 += -1
    4003:	73 4a a0 ff 00 00 00 00	*(u8 *)(r10 - 96) = r4
; 	l3_csum_replace(ctx, off + offsetof(struct iphdr, check), ttl, new_ttl, 2);
    4004:	57 04 00 00 ff 00 00 00	r4 &= 255
    4005:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    4006:	b7 02 00 00 18 00 00 00	r2 = 24
    4007:	b7 05 00 00 02 00 00 00	r5 = 2
    4008:	85 00 00 00 0a 00 00 00	call 10
    4009:	bf a3 00 00 00 00 00 00	r3 = r10
; 	new_ttl = ttl - 1;
    4010:	07 03 00 00 a0 ff ff ff	r3 += -96
; 	ctx_store_bytes(ctx, off + offsetof(struct iphdr, ttl), &new_ttl, sizeof(new_ttl), 0);
    4011:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    4012:	b7 02 00 00 16 00 00 00	r2 = 22
    4013:	b7 04 00 00 01 00 00 00	r4 = 1
    4014:	b7 05 00 00 00 00 00 00	r5 = 0
    4015:	85 00 00 00 09 00 00 00	call 9
    4016:	bf a3 00 00 00 00 00 00	r3 = r10
; 	new_ttl = ttl - 1;
    4017:	07 03 00 00 78 ff ff ff	r3 += -136
; 	return ctx_store_bytes(ctx, off, mac, ETH_ALEN, 0);
    4018:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    4019:	b7 02 00 00 00 00 00 00	r2 = 0
    4020:	b7 04 00 00 06 00 00 00	r4 = 6
    4021:	b7 05 00 00 00 00 00 00	r5 = 0
    4022:	85 00 00 00 09 00 00 00	call 9
    4023:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    4024:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    4025:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
; 	return ctx_store_bytes(ctx, off, mac, ETH_ALEN, 0);
    4027:	67 00 00 00 20 00 00 00	r0 <<= 32
    4028:	c7 00 00 00 20 00 00 00	r0 s>>= 32
; 	if (dmac && eth_store_daddr(ctx, dmac, 0) < 0)
    4029:	c5 00 22 f2 00 00 00 00	if r0 s< 0 goto -3550 <LBB13_87>
; 	ctx->mark |= ((identity & 0xFFFF) << 16) | ((identity & 0xFF0000) >> 16);
    4030:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    4032:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    4034:	67 02 00 00 10 00 00 00	r2 <<= 16
    4035:	57 01 00 00 00 00 ff 00	r1 &= 16711680
    4036:	77 01 00 00 10 00 00 00	r1 >>= 16
    4037:	4f 12 00 00 00 00 00 00	r2 |= r1
    4038:	79 a3 40 ff 00 00 00 00	r3 = *(u64 *)(r10 - 192)
; 		ctx->mark |= MARK_MAGIC_IDENTITY;
    4039:	61 31 08 00 00 00 00 00	r1 = *(u32 *)(r3 + 8)
; 	ctx->mark = ctx->mark & MARK_MAGIC_KEY_MASK;
    4040:	57 01 00 00 00 f0 00 00	r1 &= 61440
; 	ctx->mark |= ((identity & 0xFFFF) << 16) | ((identity & 0xFF0000) >> 16);
    4041:	4f 12 00 00 00 00 00 00	r2 |= r1
    4042:	47 02 00 00 00 0f 00 00	r2 |= 3840
    4043:	63 23 08 00 00 00 00 00	*(u32 *)(r3 + 8) = r2

0000000000007e60 <LBB13_576>:
    4044:	79 a8 e0 fe 00 00 00 00	r8 = *(u64 *)(r10 - 288)
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    4045:	bf 81 00 00 00 00 00 00	r1 = r8
    4046:	67 01 00 00 20 00 00 00	r1 <<= 32
    4047:	77 01 00 00 20 00 00 00	r1 >>= 32
    4048:	b7 07 00 00 80 00 00 00	r7 = 128
    4049:	15 01 01 00 00 00 00 00	if r1 == 0 goto +1 <LBB13_578>
    4050:	bf 87 00 00 00 00 00 00	r7 = r8

0000000000007e98 <LBB13_578>:
; 	return ctx->len;
    4051:	61 36 00 00 00 00 00 00	r6 = *(u32 *)(r3 + 0)
    4052:	b7 01 00 00 00 00 00 00	r1 = 0
; 	struct metrics_value *entry, newEntry = {};
    4053:	7b 1a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r1
    4054:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    4055:	b7 01 00 00 00 02 00 00	r1 = 512
; 	struct metrics_key key = {};
    4056:	7b 1a d8 ff 00 00 00 00	*(u64 *)(r10 - 40) = r1
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    4057:	67 07 00 00 20 00 00 00	r7 <<= 32
    4058:	77 07 00 00 20 00 00 00	r7 >>= 32
    4059:	2d 76 01 00 00 00 00 00	if r6 > r7 goto +1 <LBB13_580>
    4060:	bf 67 00 00 00 00 00 00	r7 = r6

0000000000007ee8 <LBB13_580>:
    4061:	bf a2 00 00 00 00 00 00	r2 = r10
    4062:	07 02 00 00 d8 ff ff ff	r2 += -40
; 	entry = map_lookup_elem(&METRICS_MAP, &key);
    4063:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    4065:	85 00 00 00 01 00 00 00	call 1
; 	if (entry) {
    4066:	15 00 07 00 00 00 00 00	if r0 == 0 goto +7 <LBB13_582>
; 		entry->count += 1;
    4067:	79 01 00 00 00 00 00 00	r1 = *(u64 *)(r0 + 0)
    4068:	07 01 00 00 01 00 00 00	r1 += 1
    4069:	7b 10 00 00 00 00 00 00	*(u64 *)(r0 + 0) = r1
; 		entry->bytes += bytes;
    4070:	79 01 08 00 00 00 00 00	r1 = *(u64 *)(r0 + 8)
    4071:	0f 61 00 00 00 00 00 00	r1 += r6
    4072:	7b 10 08 00 00 00 00 00	*(u64 *)(r0 + 8) = r1
    4073:	05 00 0b 00 00 00 00 00	goto +11 <LBB13_583>

0000000000007f50 <LBB13_582>:
; 		newEntry.bytes = bytes;
    4074:	7b 6a a8 ff 00 00 00 00	*(u64 *)(r10 - 88) = r6
    4075:	b7 01 00 00 01 00 00 00	r1 = 1
; 		newEntry.count = 1;
    4076:	7b 1a a0 ff 00 00 00 00	*(u64 *)(r10 - 96) = r1
    4077:	bf a2 00 00 00 00 00 00	r2 = r10
; 		newEntry.bytes = bytes;
    4078:	07 02 00 00 d8 ff ff ff	r2 += -40
    4079:	bf a3 00 00 00 00 00 00	r3 = r10
    4080:	07 03 00 00 a0 ff ff ff	r3 += -96
; 		map_update_elem(&METRICS_MAP, &key, &newEntry, 0);
    4081:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r1 = 0 ll
    4083:	b7 04 00 00 00 00 00 00	r4 = 0
    4084:	85 00 00 00 02 00 00 00	call 2

0000000000007fa8 <LBB13_583>:
; 	__u64 cap_len = min_t(__u64, monitor ? : TRACE_PAYLOAD_LEN,
    4085:	67 08 00 00 20 00 00 00	r8 <<= 32
    4086:	77 08 00 00 20 00 00 00	r8 >>= 32
    4087:	79 a1 40 ff 00 00 00 00	r1 = *(u64 *)(r10 - 192)
    4088:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
; 	if (!emit_trace_notify(obs_point, monitor))
    4089:	15 08 32 f6 00 00 00 00	if r8 == 0 goto -2510 <LBB13_142>
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    4090:	61 13 44 00 00 00 00 00	r3 = *(u32 *)(r1 + 68)
; 	msg = (typeof(msg)) {
    4091:	79 a2 f8 fe 00 00 00 00	r2 = *(u64 *)(r10 - 264)
    4092:	73 2a ba ff 00 00 00 00	*(u8 *)(r10 - 70) = r2
    4093:	63 5a b4 ff 00 00 00 00	*(u32 *)(r10 - 76) = r5
    4094:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    4096:	63 2a b0 ff 00 00 00 00	*(u32 *)(r10 - 80) = r2
    4097:	b7 02 00 00 01 00 00 00	r2 = 1
    4098:	6b 2a ae ff 00 00 00 00	*(u16 *)(r10 - 82) = r2
    4099:	63 6a a8 ff 00 00 00 00	*(u32 *)(r10 - 88) = r6
    4100:	63 3a a4 ff 00 00 00 00	*(u32 *)(r10 - 92) = r3
    4101:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    4103:	6b 2a a2 ff 00 00 00 00	*(u16 *)(r10 - 94) = r2
    4104:	b7 02 00 00 04 03 00 00	r2 = 772
    4105:	6b 2a a0 ff 00 00 00 00	*(u16 *)(r10 - 96) = r2
    4106:	b7 02 00 00 00 00 00 00	r2 = 0
; 	case  8: jmp_8:  __it_set(d, 64);
    4107:	7b 2a c0 ff 00 00 00 00	*(u64 *)(r10 - 64) = r2
; 	msg = (typeof(msg)) {
    4108:	63 2a bc ff 00 00 00 00	*(u32 *)(r10 - 68) = r2
    4109:	73 2a bb ff 00 00 00 00	*(u8 *)(r10 - 69) = r2
    4110:	6b 2a b8 ff 00 00 00 00	*(u16 *)(r10 - 72) = r2
; 	case  8: jmp_8:  __it_set(d, 64);
    4111:	7b 2a c8 ff 00 00 00 00	*(u64 *)(r10 - 56) = r2
; 	msg = (typeof(msg)) {
    4112:	6b 7a ac ff 00 00 00 00	*(u16 *)(r10 - 84) = r7
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    4113:	67 07 00 00 20 00 00 00	r7 <<= 32
    4114:	18 02 00 00 ff ff ff ff 00 00 00 00 00 00 00 00	r2 = 4294967295 ll
; 			 (cap_len << 32) | BPF_F_CURRENT_CPU,
    4116:	4f 27 00 00 00 00 00 00	r7 |= r2
    4117:	bf a4 00 00 00 00 00 00	r4 = r10
; 		__notify_common_hdr(CILIUM_NOTIFY_TRACE, obs_point),
    4118:	07 04 00 00 a0 ff ff ff	r4 += -96
; 	ctx_event_output(ctx, &EVENTS_MAP,
    4119:	18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00	r2 = 0 ll
    4121:	bf 73 00 00 00 00 00 00	r3 = r7
    4122:	b7 05 00 00 30 00 00 00	r5 = 48
    4123:	85 00 00 00 19 00 00 00	call 25
    4124:	79 a5 30 ff 00 00 00 00	r5 = *(u64 *)(r10 - 208)
    4125:	05 00 0d f6 00 00 00 00	goto -2547 <LBB13_141>

00000000000080f0 <LBB13_586>:
    4126:	18 08 00 00 73 ff ff ff 00 00 00 00 00 00 00 00	r8 = 4294967155 ll
    4128:	05 00 81 fb 00 00 00 00	goto -1151 <LBB13_420>

Disassembly of section 2/6:
